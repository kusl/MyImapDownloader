
===============================================================================
PROJECT EXPORT
Generated: 12/18/2025 17:41:54
Project Path: C:\Users\kushal\source\repos\MyImapDownloader
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\MYIMAPDOWNLOADER
|   .gitignore
|   Directory.Build.props
|   Directory.Build.targets
|   Directory.Packages.props
|   export.ps1
|   MyImapDownloader.sln
|   qodana.yaml
|   README.md
|   
+---docs
|   \---llm
|           .gitkeep
|           claude.md
|           dump.txt
|           ImplementationSummary.md
|           output.txt
|           
+---MyImapDownloader
|   |   appsettings.json
|   |   DownloadOptions.cs
|   |   EmailDownloadException.cs
|   |   EmailDownloadService.cs
|   |   EmailStorageService.cs
|   |   ImapConfiguration.cs
|   |   MyImapDownloader.csproj
|   |   Program.cs
|   |   
|   +---bin
|   |   \---Debug
|   |       \---net10.0
|   |           |   appsettings.json
|   |           |   BouncyCastle.Cryptography.dll
|   |           |   CommandLine.dll
|   |           |   MailKit.dll
|   |           |   Microsoft.Extensions.Configuration.Abstractions.dll
|   |           |   Microsoft.Extensions.Configuration.Binder.dll
|   |           |   Microsoft.Extensions.Configuration.CommandLine.dll
|   |           |   Microsoft.Extensions.Configuration.dll
|   |           |   Microsoft.Extensions.Configuration.EnvironmentVariables.dll
|   |           |   Microsoft.Extensions.Configuration.FileExtensions.dll
|   |           |   Microsoft.Extensions.Configuration.Json.dll
|   |           |   Microsoft.Extensions.Configuration.UserSecrets.dll
|   |           |   Microsoft.Extensions.DependencyInjection.Abstractions.dll
|   |           |   Microsoft.Extensions.DependencyInjection.dll
|   |           |   Microsoft.Extensions.Diagnostics.Abstractions.dll
|   |           |   Microsoft.Extensions.Diagnostics.dll
|   |           |   Microsoft.Extensions.FileProviders.Abstractions.dll
|   |           |   Microsoft.Extensions.FileProviders.Physical.dll
|   |           |   Microsoft.Extensions.FileSystemGlobbing.dll
|   |           |   Microsoft.Extensions.Hosting.Abstractions.dll
|   |           |   Microsoft.Extensions.Hosting.dll
|   |           |   Microsoft.Extensions.Logging.Abstractions.dll
|   |           |   Microsoft.Extensions.Logging.Configuration.dll
|   |           |   Microsoft.Extensions.Logging.Console.dll
|   |           |   Microsoft.Extensions.Logging.Debug.dll
|   |           |   Microsoft.Extensions.Logging.dll
|   |           |   Microsoft.Extensions.Logging.EventLog.dll
|   |           |   Microsoft.Extensions.Logging.EventSource.dll
|   |           |   Microsoft.Extensions.Options.ConfigurationExtensions.dll
|   |           |   Microsoft.Extensions.Options.dll
|   |           |   Microsoft.Extensions.Primitives.dll
|   |           |   MimeKit.dll
|   |           |   MyImapDownloader.deps.json
|   |           |   MyImapDownloader.dll
|   |           |   MyImapDownloader.exe
|   |           |   MyImapDownloader.pdb
|   |           |   MyImapDownloader.runtimeconfig.json
|   |           |   OpenTelemetry.Api.dll
|   |           |   OpenTelemetry.Api.ProviderBuilderExtensions.dll
|   |           |   OpenTelemetry.dll
|   |           |   OpenTelemetry.Exporter.Console.dll
|   |           |   OpenTelemetry.Extensions.Hosting.dll
|   |           |   OpenTelemetry.Instrumentation.Runtime.dll
|   |           |   Polly.Core.dll
|   |           |   Polly.dll
|   |           |   System.Diagnostics.EventLog.dll
|   |           |   System.Security.Cryptography.Pkcs.dll
|   |           |   
|   |           \---runtimes
|   |               \---win
|   |                   \---lib
|   |                       +---net10.0
|   |                       |       System.Diagnostics.EventLog.dll
|   |                       |       System.Diagnostics.EventLog.Messages.dll
|   |                       |       
|   |                       \---net8.0
|   |                               System.Security.Cryptography.Pkcs.dll
|   |                               
|   +---obj
|   |   |   MyImapDownloader.csproj.nuget.dgspec.json
|   |   |   MyImapDownloader.csproj.nuget.g.props
|   |   |   MyImapDownloader.csproj.nuget.g.targets
|   |   |   project.assets.json
|   |   |   project.nuget.cache
|   |   |   
|   |   \---Debug
|   |       \---net10.0
|   |           |   .NETCoreApp,Version=v10.0.AssemblyAttributes.cs
|   |           |   apphost.exe
|   |           |   MyImapDo.0CA68583.Up2Date
|   |           |   MyImapDownloader.AssemblyInfo.cs
|   |           |   MyImapDownloader.AssemblyInfoInputs.cache
|   |           |   MyImapDownloader.assets.cache
|   |           |   MyImapDownloader.csproj.AssemblyReference.cache
|   |           |   MyImapDownloader.csproj.CoreCompileInputs.cache
|   |           |   MyImapDownloader.csproj.FileListAbsolute.txt
|   |           |   MyImapDownloader.dll
|   |           |   MyImapDownloader.GeneratedMSBuildEditorConfig.editorconfig
|   |           |   MyImapDownloader.genruntimeconfig.cache
|   |           |   MyImapDownloader.GlobalUsings.g.cs
|   |           |   MyImapDownloader.pdb
|   |           |   MyImapDownloader.sourcelink.json
|   |           |   
|   |           +---ref
|   |           |       MyImapDownloader.dll
|   |           |       
|   |           \---refint
|   |                   MyImapDownloader.dll
|   |                   
|   \---Telemetry
|           ActivityExtension.cs
|           DiagnosticsConfig.cs
|           JsonFileLogExporter.cs
|           JsonFileMetricsExporter.cs
|           JsonFileTraceExporter.cs
|           JsonTelemetryFileWriter.cs
|           TelemetryConfiguration.cs
|           TelemetryDirectoryResolver.cs
|           TelemetryExtensions.cs
|           
\---MyImapDownloader.Tests
    |   MyImapDownloader.Tests.csproj
    |   
    +---bin
    |   \---Debug
    |       \---net10.0
    |           |   .msCoverageExtensionSourceRootsMapping_MyImapDownloader.Tests
    |           |   appsettings.json
    |           |   BouncyCastle.Cryptography.dll
    |           |   Castle.Core.dll
    |           |   CommandLine.dll
    |           |   EnumerableAsyncProcessor.dll
    |           |   FluentAssertions.dll
    |           |   MailKit.dll
    |           |   Microsoft.CodeCoverage.Core.dll
    |           |   Microsoft.CodeCoverage.Instrumentation.Core.dll
    |           |   Microsoft.CodeCoverage.Instrumentation.dll
    |           |   Microsoft.CodeCoverage.Interprocess.dll
    |           |   Microsoft.DiaSymReader.dll
    |           |   Microsoft.Extensions.Configuration.Abstractions.dll
    |           |   Microsoft.Extensions.Configuration.Binder.dll
    |           |   Microsoft.Extensions.Configuration.CommandLine.dll
    |           |   Microsoft.Extensions.Configuration.dll
    |           |   Microsoft.Extensions.Configuration.EnvironmentVariables.dll
    |           |   Microsoft.Extensions.Configuration.FileExtensions.dll
    |           |   Microsoft.Extensions.Configuration.Json.dll
    |           |   Microsoft.Extensions.Configuration.UserSecrets.dll
    |           |   Microsoft.Extensions.DependencyInjection.Abstractions.dll
    |           |   Microsoft.Extensions.DependencyInjection.dll
    |           |   Microsoft.Extensions.DependencyModel.dll
    |           |   Microsoft.Extensions.Diagnostics.Abstractions.dll
    |           |   Microsoft.Extensions.Diagnostics.dll
    |           |   Microsoft.Extensions.FileProviders.Abstractions.dll
    |           |   Microsoft.Extensions.FileProviders.Physical.dll
    |           |   Microsoft.Extensions.FileSystemGlobbing.dll
    |           |   Microsoft.Extensions.Hosting.Abstractions.dll
    |           |   Microsoft.Extensions.Hosting.dll
    |           |   Microsoft.Extensions.Logging.Abstractions.dll
    |           |   Microsoft.Extensions.Logging.Configuration.dll
    |           |   Microsoft.Extensions.Logging.Console.dll
    |           |   Microsoft.Extensions.Logging.Debug.dll
    |           |   Microsoft.Extensions.Logging.dll
    |           |   Microsoft.Extensions.Logging.EventLog.dll
    |           |   Microsoft.Extensions.Logging.EventSource.dll
    |           |   Microsoft.Extensions.Options.ConfigurationExtensions.dll
    |           |   Microsoft.Extensions.Options.dll
    |           |   Microsoft.Extensions.Primitives.dll
    |           |   Microsoft.Testing.Extensions.CodeCoverage.dll
    |           |   Microsoft.Testing.Extensions.MSBuild.dll
    |           |   Microsoft.Testing.Extensions.TrxReport.Abstractions.dll
    |           |   Microsoft.Testing.Extensions.TrxReport.dll
    |           |   Microsoft.Testing.Platform.dll
    |           |   Microsoft.VisualStudio.CodeCoverage.Shim.dll
    |           |   MimeKit.dll
    |           |   Mono.Cecil.dll
    |           |   Mono.Cecil.Mdb.dll
    |           |   Mono.Cecil.Pdb.dll
    |           |   Mono.Cecil.Rocks.dll
    |           |   MyImapDownloader.deps.json
    |           |   MyImapDownloader.dll
    |           |   MyImapDownloader.exe
    |           |   MyImapDownloader.pdb
    |           |   MyImapDownloader.runtimeconfig.json
    |           |   MyImapDownloader.Tests.deps.json
    |           |   MyImapDownloader.Tests.dll
    |           |   MyImapDownloader.Tests.exe
    |           |   MyImapDownloader.Tests.pdb
    |           |   MyImapDownloader.Tests.runtimeconfig.json
    |           |   NSubstitute.dll
    |           |   OpenTelemetry.Api.dll
    |           |   OpenTelemetry.Api.ProviderBuilderExtensions.dll
    |           |   OpenTelemetry.dll
    |           |   OpenTelemetry.Exporter.Console.dll
    |           |   OpenTelemetry.Extensions.Hosting.dll
    |           |   OpenTelemetry.Instrumentation.Runtime.dll
    |           |   Polly.Core.dll
    |           |   Polly.dll
    |           |   System.Diagnostics.EventLog.dll
    |           |   System.Security.Cryptography.Pkcs.dll
    |           |   TUnit.Assertions.dll
    |           |   TUnit.Core.dll
    |           |   TUnit.dll
    |           |   TUnit.Engine.dll
    |           |   
    |           +---cs
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---de
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---es
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---fr
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---hu
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       
    |           +---it
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---ja
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---ko
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---Log
    |           |       log_251218224048981.diag
    |           |       
    |           +---nl
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       
    |           +---pl
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---pt-BR
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---pt-PT
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       
    |           +---ru
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---runtimes
    |           |   +---linux-musl-x64
    |           |   |   \---native
    |           |   |           Cov_x64.config
    |           |   |           libCoverageInstrumentationMethod.so
    |           |   |           libInstrumentationEngine.so
    |           |   |           
    |           |   +---linux-x64
    |           |   |   \---native
    |           |   |           Cov_x64.config
    |           |   |           libCoverageInstrumentationMethod.so
    |           |   |           libInstrumentationEngine.so
    |           |   |           
    |           |   +---osx-x64
    |           |   |   \---native
    |           |   |           Cov_x64.config
    |           |   |           libCoverageInstrumentationMethod.dylib
    |           |   |           libInstrumentationEngine.dylib
    |           |   |           
    |           |   +---win
    |           |   |   \---lib
    |           |   |       +---net10.0
    |           |   |       |       System.Diagnostics.EventLog.dll
    |           |   |       |       System.Diagnostics.EventLog.Messages.dll
    |           |   |       |       
    |           |   |       \---net8.0
    |           |   |               System.Security.Cryptography.Pkcs.dll
    |           |   |               
    |           |   +---win-arm64
    |           |   |   \---native
    |           |   |           CodeCoverageMessages.dll
    |           |   |           covrun32.dll
    |           |   |           covrun64.dll
    |           |   |           covrunarm64.dll
    |           |   |           Cov_arm64.config
    |           |   |           Cov_x64.config
    |           |   |           Cov_x86.config
    |           |   |           MicrosoftInstrumentationEngine_arm64.dll
    |           |   |           MicrosoftInstrumentationEngine_x64.dll
    |           |   |           MicrosoftInstrumentationEngine_x86.dll
    |           |   |           msdia140.dll
    |           |   |           
    |           |   +---win-x64
    |           |   |   \---native
    |           |   |           CodeCoverageMessages.dll
    |           |   |           covrun32.dll
    |           |   |           covrun64.dll
    |           |   |           covrunarm64.dll
    |           |   |           Cov_arm64.config
    |           |   |           Cov_x64.config
    |           |   |           Cov_x86.config
    |           |   |           MicrosoftInstrumentationEngine_arm64.dll
    |           |   |           MicrosoftInstrumentationEngine_x64.dll
    |           |   |           MicrosoftInstrumentationEngine_x86.dll
    |           |   |           msdia140.dll
    |           |   |           
    |           |   \---win-x86
    |           |       \---native
    |           |               CodeCoverageMessages.dll
    |           |               covrun32.dll
    |           |               covrun64.dll
    |           |               covrunarm64.dll
    |           |               Cov_arm64.config
    |           |               Cov_x64.config
    |           |               Cov_x86.config
    |           |               MicrosoftInstrumentationEngine_arm64.dll
    |           |               MicrosoftInstrumentationEngine_x64.dll
    |           |               MicrosoftInstrumentationEngine_x86.dll
    |           |               msdia140.dll
    |           |               
    |           +---sv
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       
    |           +---TestResults
    |           +---tr
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           +---zh-Hans
    |           |       Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |           |       Microsoft.Testing.Extensions.MSBuild.resources.dll
    |           |       Microsoft.Testing.Extensions.TrxReport.resources.dll
    |           |       Microsoft.Testing.Platform.resources.dll
    |           |       
    |           \---zh-Hant
    |                   Microsoft.Testing.Extensions.CodeCoverage.resources.dll
    |                   Microsoft.Testing.Extensions.MSBuild.resources.dll
    |                   Microsoft.Testing.Extensions.TrxReport.resources.dll
    |                   Microsoft.Testing.Platform.resources.dll
    |                   
    +---obj
    |   |   MyImapDownloader.Tests.csproj.nuget.dgspec.json
    |   |   MyImapDownloader.Tests.csproj.nuget.g.props
    |   |   MyImapDownloader.Tests.csproj.nuget.g.targets
    |   |   project.assets.json
    |   |   project.nuget.cache
    |   |   
    |   \---Debug
    |       \---net10.0
    |           |   .NETCoreApp,Version=v10.0.AssemblyAttributes.cs
    |           |   apphost.exe
    |           |   MicrosoftTestingPlatformEntryPoint.cs
    |           |   MyImapDo.7C8E3919.Up2Date
    |           |   MyImapDownloader.Tests.AssemblyInfo.cs
    |           |   MyImapDownloader.Tests.AssemblyInfoInputs.cache
    |           |   MyImapDownloader.Tests.assets.cache
    |           |   MyImapDownloader.Tests.csproj.AssemblyReference.cache
    |           |   MyImapDownloader.Tests.csproj.CoreCompileInputs.cache
    |           |   MyImapDownloader.Tests.csproj.FileListAbsolute.txt
    |           |   MyImapDownloader.Tests.dll
    |           |   MyImapDownloader.Tests.genautoregisteredextensionsinputcache.cache
    |           |   MyImapDownloader.Tests.GeneratedMSBuildEditorConfig.editorconfig
    |           |   MyImapDownloader.Tests.genruntimeconfig.cache
    |           |   MyImapDownloader.Tests.gentestingplatformentrypointinputcache.cache
    |           |   MyImapDownloader.Tests.GlobalUsings.g.cs
    |           |   MyImapDownloader.Tests.pdb
    |           |   MyImapDownloader.Tests.sourcelink.json
    |           |   SelfRegisteredExtensions.cs
    |           |   
    |           +---ref
    |           |       MyImapDownloader.Tests.dll
    |           |       
    |           \---refint
    |                   MyImapDownloader.Tests.dll
    |                   
    \---Telemetry
            ActivityExtensionsTests.cs
            DiagnosticsConfigTests.cs
            DownloadOptionsTests.cs
            EmailDownloadExceptionTests.cs
            ImapConfigurationTests.cs
            JsonExporterTests.cs
            JsonTelemetryFileWriterTests.cs
            TelemetryConfigurationTests.cs
            TelemetryDirectoryResolverTests.cs
            TelemetryExtensionsTests.cs
            TelemetryWriterProviderTests.cs
            


FILE CONTENTS:
==============

================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\Directory.Build.props
SIZE: 0.51 KB
MODIFIED: 12/18/2025 13:51:47
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\Directory.Packages.props
SIZE: 1.72 KB
MODIFIED: 12/18/2025 14:55:03
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  <ItemGroup>
    <!-- Application packages -->
    <PackageVersion Include="CommandLineParser" Version="2.9.1" />
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="MailKit" Version="4.14.1" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Json" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.UserSecrets" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Console" Version="10.0.1" />
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    <PackageVersion Include="Polly" Version="8.6.5" />
    
    <!-- Test packages -->
    <PackageVersion Include="TUnit" Version="1.5.70" />
    <PackageVersion Include="NSubstitute" Version="5.3.0" />
    <PackageVersion Include="FluentAssertions" Version="8.8.0" />
  </ItemGroup>
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.sln
SIZE: 1.51 KB
MODIFIED: 12/18/2025 14:43:12
================================================================================

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyImapDownloader", "MyImapDownloader\MyImapDownloader.csproj", "{8E3B6382-B4FA-491C-8889-8964BC556B71}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyImapDownloader.Tests", "MyImapDownloader.Tests\MyImapDownloader.Tests.csproj", "{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.Build.0 = Release|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\MyImapDownloader.Tests.csproj
SIZE: 1.02 KB
MODIFIED: 12/18/2025 17:39:30
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TUnit requires the test project to be an Exe -->
    
    <!-- Enable Microsoft Testing Platform for .NET 10+ -->
    <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
    
    <!-- Optional: Shows test output in terminal -->
    <TestingPlatformCaptureOutput>false</TestingPlatformCaptureOutput>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader\MyImapDownloader.csproj" />
  </ItemGroup>

</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\ActivityExtensionsTests.cs
SIZE: 5.75 KB
MODIFIED: 12/18/2025 17:37:48
================================================================================

using System.Diagnostics;
using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class ActivityExtensionsTests : IDisposable
{
    private readonly ActivitySource _activitySource;
    private readonly ActivityListener _listener;
    private readonly List<Activity> _recordedActivities = [];

    public ActivityExtensionsTests()
    {
        _activitySource = new ActivitySource("TestSource");
        _listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded,
            ActivityStopped = activity => _recordedActivities.Add(activity)
        };
        ActivitySource.AddActivityListener(_listener);
    }

    public void Dispose()
    {
        _listener.Dispose();
        _activitySource.Dispose();
    }

    [Test]
    public async Task RecordException_AddsExceptionEvent_ToActivity()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new InvalidOperationException("Test error message");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(1);
        
        var exceptionEvent = events[0];
        await Assert.That(exceptionEvent.Name).IsEqualTo("exception");
    }

    [Test]
    public async Task RecordException_IncludesExceptionType()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new ArgumentNullException("paramName");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.type");
        tags["exception.type"].Should().Be(typeof(ArgumentNullException).FullName);
    }

    [Test]
    public async Task RecordException_IncludesExceptionMessage()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Specific error details");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.message");
        tags["exception.message"]!.ToString().Should().Contain("Specific error details");
    }

    [Test]
    public async Task RecordException_IncludesStackTrace_WhenAvailable()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        
        Exception? capturedException = null;
        try
        {
            throw new Exception("Error with stack trace");
        }
        catch (Exception ex)
        {
            capturedException = ex;
        }

        activity.RecordException(capturedException!);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.stacktrace");
        tags["exception.stacktrace"]!.ToString().Should().Contain("RecordException_IncludesStackTrace");
    }

    [Test]
    public async Task RecordException_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.RecordException(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_WithNullException_DoesNotThrow()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        // Should not throw
        activity.RecordException(null!);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(0);
    }

    [Test]
    public async Task SetErrorStatus_SetsStatusToError()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Operation failed");

        activity.SetErrorStatus(exception);

        await Assert.That(activity!.Status).IsEqualTo(ActivityStatusCode.Error);
    }

    [Test]
    public async Task SetErrorStatus_IncludesExceptionMessage_InStatusDescription()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Detailed failure reason");

        activity.SetErrorStatus(exception);

        activity!.StatusDescription.Should().Contain("Detailed failure reason");
    }

    [Test]
    public async Task SetErrorStatus_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.SetErrorStatus(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_HandlesNestedExceptions()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var inner = new ArgumentException("Inner error");
        var outer = new InvalidOperationException("Outer error", inner);

        activity.RecordException(outer);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        // Should record the outer exception's details
        tags["exception.type"].Should().Be(typeof(InvalidOperationException).FullName);
        tags["exception.message"]!.ToString().Should().Contain("Outer error");
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\DiagnosticsConfigTests.cs
SIZE: 2.62 KB
MODIFIED: 12/18/2025 17:38:28
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class DiagnosticsConfigTests
{
    [Test]
    public async Task ServiceName_IsExpectedValue()
    {
        var serviceName = DiagnosticsConfig.ServiceName;
        await Assert.That(serviceName).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_HasCorrectName()
    {
        var source = DiagnosticsConfig.ActivitySource;

        source.Should().NotBeNull();
        await Assert.That(source.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task Meter_HasCorrectName()
    {
        var meter = DiagnosticsConfig.Meter;

        meter.Should().NotBeNull();
        await Assert.That(meter.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_CanCreateActivity()
    {
        // Need a listener to actually create activities
        using var listener = new ActivityListener
        {
            ShouldListenTo = source => source.Name == DiagnosticsConfig.ServiceName,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("TestOperation");

        activity.Should().NotBeNull();
        await Assert.That(activity!.OperationName).IsEqualTo("TestOperation");
    }

    [Test]
    public async Task Meter_CanCreateCounter()
    {
        var counter = DiagnosticsConfig.Meter.CreateCounter<long>("test_counter");

        counter.Should().NotBeNull();
        counter.Name.Should().Be("test_counter");
    }

    [Test]
    public async Task Meter_CanCreateHistogram()
    {
        var histogram = DiagnosticsConfig.Meter.CreateHistogram<double>("test_histogram");

        histogram.Should().NotBeNull();
        histogram.Name.Should().Be("test_histogram");
    }

    [Test]
    public async Task ActivitySource_IsSingleton()
    {
        var source1 = DiagnosticsConfig.ActivitySource;
        var source2 = DiagnosticsConfig.ActivitySource;

        var areSame = ReferenceEquals(source1, source2);
        await Assert.That(areSame).IsTrue();
    }

    [Test]
    public async Task Meter_IsSingleton()
    {
        var meter1 = DiagnosticsConfig.Meter;
        var meter2 = DiagnosticsConfig.Meter;

        var areSame = ReferenceEquals(meter1, meter2);
        await Assert.That(areSame).IsTrue();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\DownloadOptionsTests.cs
SIZE: 4.12 KB
MODIFIED: 12/18/2025 17:40:07
================================================================================

using FluentAssertions;

namespace MyImapDownloader.Tests;

public class DownloadOptionsTests
{
    [Test]
    public async Task DefaultValues_AreSet()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output"
        };

        await Assert.That(options.Port).IsEqualTo(993);
        await Assert.That(options.StartDate).IsNull();
        await Assert.That(options.EndDate).IsNull();
        await Assert.That(options.AllFolders).IsFalse();
        await Assert.That(options.Verbose).IsFalse();
    }

    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var options = new DownloadOptions
        {
            Server = "mail.test.com",
            Username = "testuser",
            Password = "testpass",
            OutputDirectory = "emails"
        };

        await Assert.That(options.Server).IsEqualTo("mail.test.com");
        await Assert.That(options.Username).IsEqualTo("testuser");
        await Assert.That(options.Password).IsEqualTo("testpass");
        await Assert.That(options.OutputDirectory).IsEqualTo("emails");
    }

    [Test]
    public async Task Port_CanBeCustomized()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            Port = 143
        };

        await Assert.That(options.Port).IsEqualTo(143);
    }

    [Test]
    public async Task DateFilters_CanBeSet()
    {
        var startDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        var endDate = new DateTime(2024, 12, 31, 23, 59, 59, DateTimeKind.Utc);

        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            StartDate = startDate,
            EndDate = endDate
        };

        await Assert.That(options.StartDate).IsEqualTo(startDate);
        await Assert.That(options.EndDate).IsEqualTo(endDate);
    }

    [Test]
    public async Task DateRange_CanBeCalculated()
    {
        var startDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        var endDate = new DateTime(2024, 12, 31, 23, 59, 59, DateTimeKind.Utc);

        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            StartDate = startDate,
            EndDate = endDate
        };

        var daySpan = (options.EndDate!.Value - options.StartDate!.Value).Days;
        await Assert.That(daySpan).IsEqualTo(365);
    }

    [Test]
    public async Task AllFolders_CanBeEnabled()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            AllFolders = true
        };

        await Assert.That(options.AllFolders).IsTrue();
    }

    [Test]
    public async Task Verbose_CanBeEnabled()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            Verbose = true
        };

        await Assert.That(options.Verbose).IsTrue();
    }

    [Test]
    public async Task NullableDateProperties_CanRemainNull()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output"
        };

        await Assert.That(options.StartDate).IsNull();
        await Assert.That(options.EndDate).IsNull();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\EmailDownloadExceptionTests.cs
SIZE: 3.59 KB
MODIFIED: 12/18/2025 17:39:53
================================================================================

using FluentAssertions;

namespace MyImapDownloader.Tests;

public class EmailDownloadExceptionTests
{
    [Test]
    public async Task Constructor_SetsAllProperties()
    {
        var inner = new IOException("Network error");
        var exception = new EmailDownloadException("Download failed", 42, inner);

        await Assert.That(exception.Message).IsEqualTo("Download failed");
        await Assert.That(exception.MessageIndex).IsEqualTo(42);
        await Assert.That(exception.InnerException).IsEqualTo(inner);
    }

    [Test]
    public async Task MessageIndex_IsAccessible()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Error at index", 5, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(5);
    }

    [Test]
    public async Task InheritsFromException()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Test", 0, inner);

        exception.Should().BeAssignableTo<Exception>();
    }

    [Test]
    public async Task CanBeCaughtAsException()
    {
        Exception? caught = null;
        var inner = new Exception("Inner");

        try
        {
            throw new EmailDownloadException("Test error", 1, inner);
        }
        catch (Exception ex)
        {
            caught = ex;
        }

        await Assert.That(caught).IsNotNull();
        caught.Should().BeOfType<EmailDownloadException>();
    }

    [Test]
    public async Task CanBeCaughtSpecifically()
    {
        EmailDownloadException? caught = null;
        var inner = new Exception("Inner");

        try
        {
            throw new EmailDownloadException("Specific error", 10, inner);
        }
        catch (EmailDownloadException ex)
        {
            caught = ex;
        }

        await Assert.That(caught).IsNotNull();
        await Assert.That(caught!.Message).IsEqualTo("Specific error");
        await Assert.That(caught.MessageIndex).IsEqualTo(10);
    }

    [Test]
    public async Task InnerException_ChainIsPreserved()
    {
        var level1 = new InvalidOperationException("Level 1");
        var level2 = new EmailDownloadException("Level 2", 1, level1);
        var level3 = new EmailDownloadException("Level 3", 2, level2);

        await Assert.That(level3.InnerException).IsEqualTo(level2);
        await Assert.That(level3.InnerException!.InnerException).IsEqualTo(level1);
    }

    [Test]
    public async Task StackTrace_IsAvailable_WhenThrown()
    {
        EmailDownloadException? caught = null;

        try
        {
            ThrowHelper();
        }
        catch (EmailDownloadException ex)
        {
            caught = ex;
        }

        caught!.StackTrace.Should().NotBeNullOrEmpty();
        caught.StackTrace.Should().Contain("ThrowHelper");
    }

    [Test]
    public async Task MessageIndex_ZeroIsValid()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("First message failed", 0, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(0);
    }

    [Test]
    public async Task MessageIndex_LargeValueIsValid()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Message failed", 999999, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(999999);
    }

    private static void ThrowHelper()
    {
        var inner = new Exception("Inner");
        throw new EmailDownloadException("From helper", 0, inner);
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\ImapConfigurationTests.cs
SIZE: 4.13 KB
MODIFIED: 12/18/2025 17:39:42
================================================================================

using FluentAssertions;
using Microsoft.Extensions.Configuration;

namespace MyImapDownloader.Tests;

public class ImapConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreSet()
    {
        var config = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };

        await Assert.That(config.Port).IsEqualTo(0); // No default in current implementation
        await Assert.That(config.UseSsl).IsTrue();
        await Assert.That(config.Server).IsEmpty();
        await Assert.That(config.Username).IsEmpty();
        await Assert.That(config.Password).IsEmpty();
    }

    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret123"
        };

        await Assert.That(config.Server).IsEqualTo("imap.example.com");
        await Assert.That(config.Username).IsEqualTo("user@example.com");
        await Assert.That(config.Password).IsEqualTo("secret123");
    }

    [Test]
    public async Task CanBindFromConfiguration()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Imap:Server"] = "imap.example.com",
            ["Imap:Port"] = "587",
            ["Imap:Username"] = "user@example.com",
            ["Imap:Password"] = "secret123",
            ["Imap:UseSsl"] = "false"
        };

        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        var imapConfig = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };
        configuration.GetSection("Imap").Bind(imapConfig);

        await Assert.That(imapConfig.Server).IsEqualTo("imap.example.com");
        await Assert.That(imapConfig.Port).IsEqualTo(587);
        await Assert.That(imapConfig.Username).IsEqualTo("user@example.com");
        await Assert.That(imapConfig.Password).IsEqualTo("secret123");
        await Assert.That(imapConfig.UseSsl).IsFalse();
    }

    [Test]
    public async Task PartialConfiguration_UsesDefaults()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Imap:Server"] = "mail.test.com",
            ["Imap:Username"] = "testuser",
            ["Imap:Password"] = "testpass"
        };

        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        var imapConfig = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };
        configuration.GetSection("Imap").Bind(imapConfig);

        // Configured values
        await Assert.That(imapConfig.Server).IsEqualTo("mail.test.com");
        await Assert.That(imapConfig.Username).IsEqualTo("testuser");
        await Assert.That(imapConfig.Password).IsEqualTo("testpass");
        
        // Default value preserved
        await Assert.That(imapConfig.UseSsl).IsTrue();
    }

    [Test]
    [Arguments(993, true)]   // Standard IMAPS
    [Arguments(143, false)]  // Standard IMAP
    [Arguments(587, true)]   // Custom with SSL
    [Arguments(2993, true)]  // Non-standard with SSL
    public async Task PortAndSslCombinations_AreValid(int port, bool useSsl)
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password",
            Port = port,
            UseSsl = useSsl
        };

        await Assert.That(config.Port).IsEqualTo(port);
        await Assert.That(config.UseSsl).IsEqualTo(useSsl);
    }

    [Test]
    public async Task UseSsl_DefaultsToTrue()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password"
        };

        await Assert.That(config.UseSsl).IsTrue();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\JsonExporterTests.cs
SIZE: 4.97 KB
MODIFIED: 12/18/2025 17:39:19
================================================================================

using System.Diagnostics;
using FluentAssertions;
using MyImapDownloader.Telemetry;
using OpenTelemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonFileTraceExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonFileTraceExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"trace_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }
        
        await Task.Delay(100);
        
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix = "traces")
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileTraceExporter(null);
        
        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }

    [Test]
    public async Task Export_WithWriter_EnqueuesRecords()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        using var activitySource = new ActivitySource("Test");
        using var listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = activitySource.StartActivity("ExportTest");
        activity?.SetTag("test.key", "test.value");
        activity?.Stop();

        var batch = new Batch<Activity>([activity!], 1);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);

        // Flush and verify
        await writer.FlushAsync();
        
        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
        
        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("ExportTest");
    }

    [Test]
    public async Task Export_ReturnsSuccess_EvenOnError()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        // Empty batch should still return success
        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileLogExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileLogExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"log_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileLogExporter(null);
        
        // Test with empty batch
        var batch = new Batch<OpenTelemetry.Logs.LogRecord>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileMetricsExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileMetricsExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"metrics_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileMetricsExporter(null);
        
        var batch = new Batch<OpenTelemetry.Metrics.Metric>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\JsonTelemetryFileWriterTests.cs
SIZE: 6.02 KB
MODIFIED: 12/18/2025 17:39:08
================================================================================

using System.Text.Json;
using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonTelemetryFileWriterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonTelemetryFileWriterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"telemetry_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }
        
        await Task.Delay(100);
        
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string? subDir = null, string prefix = "test", long maxSize = 1024 * 1024)
    {
        var dir = subDir != null ? Path.Combine(_testDirectory, subDir) : _testDirectory;
        var writer = new JsonTelemetryFileWriter(dir, prefix, maxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_CreatesDirectory_WhenItDoesNotExist()
    {
        var newDir = Path.Combine(_testDirectory, "new_subdir");
        
        var writer = new JsonTelemetryFileWriter(newDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        
        await Assert.That(Directory.Exists(newDir)).IsTrue();
    }

    [Test]
    public async Task Enqueue_DoesNotThrow_WhenCalled()
    {
        var writer = CreateWriter();
        
        var record = new { Message = "Test", Timestamp = DateTime.UtcNow };
        
        // Should not throw
        writer.Enqueue(record);
        
        // If we get here, the test passed
        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task FlushAsync_WritesEnqueuedRecords_ToFile()
    {
        var writer = CreateWriter();
        
        var record = new TestRecord { Id = 1, Message = "Hello" };
        writer.Enqueue(record);
        
        await writer.FlushAsync();
        
        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
        
        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("Hello");
        content.Should().Contain("\"id\":1");
    }

    [Test]
    public async Task FlushAsync_WritesMultipleRecords_InJsonlFormat()
    {
        var writer = CreateWriter();
        
        writer.Enqueue(new TestRecord { Id = 1, Message = "First" });
        writer.Enqueue(new TestRecord { Id = 2, Message = "Second" });
        writer.Enqueue(new TestRecord { Id = 3, Message = "Third" });
        
        await writer.FlushAsync();
        
        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        var lines = await File.ReadAllLinesAsync(files[0]);
        
        // Each record should be on its own line (JSONL format)
        await Assert.That(lines.Length).IsEqualTo(3);
        
        // Each line should be valid JSON
        foreach (var line in lines)
        {
            var parsed = JsonSerializer.Deserialize<TestRecord>(line);
            parsed.Should().NotBeNull();
        }
    }

    [Test]
    public async Task Dispose_CanBeCalledMultipleTimes()
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, "dispose", 1024 * 1024, TimeSpan.FromSeconds(30));
        
        // Should not throw when called multiple times
        writer.Dispose();
        writer.Dispose();
        writer.Dispose();
        
        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task Dispose_FlushesRemainingRecords()
    {
        var subDir = Path.Combine(_testDirectory, "dispose_flush");
        Directory.CreateDirectory(subDir);
        
        var writer = new JsonTelemetryFileWriter(subDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));
        
        writer.Enqueue(new { Test = true });
        writer.Dispose();
        
        // Small delay for file operations
        await Task.Delay(100);
        
        var files = Directory.GetFiles(subDir, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }

    [Test]
    public async Task FlushAsync_WithEmptyBuffer_DoesNotCreateFile()
    {
        var emptyDir = Path.Combine(_testDirectory, "empty");
        Directory.CreateDirectory(emptyDir);
        
        var writer = CreateWriter("empty");
        
        await writer.FlushAsync();
        
        var files = Directory.GetFiles(emptyDir, "*.jsonl");
        await Assert.That(files.Length).IsEqualTo(0);
    }

    [Test]
    public async Task FileRotation_OccursWhenSizeExceeded()
    {
        // Small max file size to trigger rotation quickly
        const long smallMaxSize = 500; // 500 bytes
        var rotateDir = Path.Combine(_testDirectory, "rotate");
        Directory.CreateDirectory(rotateDir);
        
        var writer = new JsonTelemetryFileWriter(rotateDir, "rotate", smallMaxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        
        // Write enough data to trigger rotation (each record ~50-100 bytes)
        for (int i = 0; i < 20; i++)
        {
            writer.Enqueue(new TestRecord { Id = i, Message = $"Record number {i} with some padding text" });
        }
        
        await writer.FlushAsync();
        
        var files = Directory.GetFiles(rotateDir, "rotate_*.jsonl");
        
        // Should have created multiple files due to rotation
        await Assert.That(files.Length).IsGreaterThan(1);
    }

    private record TestRecord
    {
        public int Id { get; init; }
        public string? Message { get; init; }
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\TelemetryConfigurationTests.cs
SIZE: 2.74 KB
MODIFIED: 12/18/2025 17:38:18
================================================================================

using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreReasonable()
    {
        var config = new TelemetryConfiguration();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.ServiceVersion).IsEqualTo("1.0.0");
        await Assert.That(config.EnableTracing).IsTrue();
        await Assert.That(config.EnableMetrics).IsTrue();
        await Assert.That(config.EnableLogging).IsTrue();
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(25);
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(5);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(15);
    }

    [Test]
    public async Task MaxFileSizeBytes_CalculatesCorrectly()
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = 10 };

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(10L * 1024L * 1024L);
    }

    [Test]
    [Arguments(1)]
    [Arguments(25)]
    [Arguments(100)]
    [Arguments(1024)]
    public async Task MaxFileSizeBytes_ScalesWithMB(int megabytes)
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = megabytes };
        var expected = (long)megabytes * 1024L * 1024L;

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(expected);
    }

    [Test]
    public async Task SectionName_IsExpectedValue()
    {
        var sectionName = TelemetryConfiguration.SectionName;
        await Assert.That(sectionName).IsEqualTo("Telemetry");
    }

    [Test]
    public async Task AllPropertiesAreMutable()
    {
        var config = new TelemetryConfiguration
        {
            ServiceName = "CustomService",
            ServiceVersion = "2.0.0",
            OutputDirectory = "/custom/path",
            MaxFileSizeMB = 50,
            EnableTracing = false,
            EnableMetrics = false,
            EnableLogging = false,
            FlushIntervalSeconds = 10,
            MetricsExportIntervalSeconds = 30
        };

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.OutputDirectory).IsEqualTo("/custom/path");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableTracing).IsFalse();
        await Assert.That(config.EnableMetrics).IsFalse();
        await Assert.That(config.EnableLogging).IsFalse();
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(10);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(30);
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\TelemetryDirectoryResolverTests.cs
SIZE: 3.55 KB
MODIFIED: 12/18/2025 17:38:04
================================================================================

using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryDirectoryResolverTests
{
    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsNonNullPath()
    {
        // On any normal system, at least one location should be writable
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        // This could be null in a sandboxed environment, but typically won't be
        // We're testing that the method runs without throwing
        result.Should().NotBeNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsWritablePath_WhenSuccessful()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        if (result != null)
        {
            // If a path is returned, it should be writable
            var testFile = Path.Combine(result, $".test_{Guid.NewGuid():N}");
            try
            {
                await File.WriteAllTextAsync(testFile, "test");
                await Assert.That(File.Exists(testFile)).IsTrue();
                File.Delete(testFile);
            }
            finally
            {
                if (File.Exists(testFile))
                    File.Delete(testFile);
            }
        }
        else
        {
            // Null is acceptable if no writable location exists
            await Assert.That(result).IsNull();
        }
    }

    [Test]
    public async Task ResolveTelemetryDirectory_IncludesAppName_InPath()
    {
        const string appName = "MyUniqueTestApp";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        if (result != null)
        {
            result.Should().Contain(appName);
        }
        
        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_UsesDefaultAppName_WhenNotSpecified()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory();

        // Should use "MyImapDownloader" as default
        if (result != null)
        {
            result.Should().Contain("MyImapDownloader");
        }
        
        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_CreatesDirectory_WhenItDoesNotExist()
    {
        var uniqueAppName = $"TestApp_{Guid.NewGuid():N}";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(uniqueAppName);

        try
        {
            if (result != null)
            {
                await Assert.That(Directory.Exists(result)).IsTrue();
            }
        }
        finally
        {
            // Cleanup
            if (result != null && Directory.Exists(result))
            {
                try { Directory.Delete(result, recursive: true); } catch { }
            }
        }
    }

    [Test]
    [Arguments("SimpleApp")]
    [Arguments("App-With-Dashes")]
    [Arguments("App_With_Underscores")]
    [Arguments("AppWithNumbers123")]
    public async Task ResolveTelemetryDirectory_HandlesVariousAppNames(string appName)
    {
        // Should not throw for valid app names
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);
        
        result.Should().NotBeNull();
        
        // Cleanup if directory was created
        if (result != null && Directory.Exists(result))
        {
            try { Directory.Delete(result, recursive: true); } catch { }
        }
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\TelemetryExtensionsTests.cs
SIZE: 4.49 KB
MODIFIED: 12/18/2025 14:47:16
================================================================================

using FluentAssertions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryExtensionsTests
{
    [Test]
    public async Task AddTelemetry_RegistersTelemetryConfiguration()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetService<TelemetryConfiguration>();
        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_RegistersWriterProvider()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_BindsConfigurationValues()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:ServiceName"] = "CustomService",
            ["Telemetry:ServiceVersion"] = "2.0.0",
            ["Telemetry:MaxFileSizeMB"] = "50",
            ["Telemetry:EnableTracing"] = "true",
            ["Telemetry:EnableMetrics"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();
        
        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableMetrics).IsFalse();
    }

    [Test]
    public async Task AddTelemetry_WithDisabledTelemetry_RegistersNullProvider()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:EnableTracing"] = "false",
            ["Telemetry:EnableMetrics"] = "false",
            ["Telemetry:EnableLogging"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_CanBeCalledMultipleTimes_WithoutError()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        // Should not throw on multiple calls
        services.AddTelemetry(configuration);
        services.AddTelemetry(configuration);

        var provider = services.BuildServiceProvider();
        var config = provider.GetService<TelemetryConfiguration>();
        
        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_WithEmptyConfiguration_UsesDefaults()
    {
        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder().Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();
        
        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.EnableTracing).IsTrue();
    }

    [Test]
    public async Task AddTelemetry_ReturnsServiceCollection_ForChaining()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        var result = services.AddTelemetry(configuration);

        result.Should().BeSameAs(services);
    }

    private static IConfiguration CreateConfiguration()
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Telemetry:ServiceName"] = "TestService"
            })
            .Build();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.Tests\Telemetry\TelemetryWriterProviderTests.cs
SIZE: 3.59 KB
MODIFIED: 12/18/2025 14:47:38
================================================================================

using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryWriterProviderTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = new();

    public TelemetryWriterProviderTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"provider_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }
        
        await Task.Delay(100);
        
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix)
    {
        var writer = new JsonTelemetryFileWriter(
            _testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_AcceptsAllWriters()
    {
        var traceWriter = CreateWriter("traces");
        var metricsWriter = CreateWriter("metrics");
        var logsWriter = CreateWriter("logs");

        var provider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsEqualTo(metricsWriter);
        await Assert.That(provider.LogsWriter).IsEqualTo(logsWriter);
    }

    [Test]
    public async Task Constructor_AcceptsNullWriters()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task Constructor_AcceptsMixedNullAndNonNullWriters()
    {
        var traceWriter = CreateWriter("traces");

        var provider = new TelemetryWriterProvider(traceWriter, null, null);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task ImplementsInterface()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task NullProvider_ReturnsAllNull()
    {
        var provider = new NullTelemetryWriterProvider();

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task NullProvider_ImplementsInterface()
    {
        var provider = new NullTelemetryWriterProvider();

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task ProvidersAreInterchangeable()
    {
        ITelemetryWriterProvider provider1 = new NullTelemetryWriterProvider();
        ITelemetryWriterProvider provider2 = new TelemetryWriterProvider(null, null, null);

        // Both should work identically through the interface
        await Assert.That(provider1.TraceWriter).IsNull();
        await Assert.That(provider2.TraceWriter).IsNull();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\appsettings.json
SIZE: 0.45 KB
MODIFIED: 12/18/2025 14:08:04
================================================================================

{
  "Telemetry": {
    "ServiceName": "MyImapDownloader",
    "ServiceVersion": "1.0.0",
    "OutputDirectory": "telemetry",
    "MaxFileSizeMB": 25,
    "EnableTracing": true,
    "EnableMetrics": true,
    "EnableLogging": true,
    "FlushIntervalSeconds": 5,
    "MetricsExportIntervalSeconds": 15
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\DownloadOptions.cs
SIZE: 1.28 KB
MODIFIED: 12/18/2025 13:48:35
================================================================================

using CommandLine;

namespace MyImapDownloader;

public class DownloadOptions
{
    [Option('s', "server", Required = true, HelpText = "IMAP server address")]
    public required string Server { get; set; }

    [Option('u', "username", Required = true, HelpText = "Email username")]
    public required string Username { get; set; }

    [Option('p', "password", Required = true, HelpText = "Email password")]
    public required string Password { get; set; }

    [Option('r', "port", Default = 993, HelpText = "IMAP port (default: 993)")]
    public int Port { get; set; } = 993;

    [Option('o', "output", Default = "EmailArchive", HelpText = "Output directory for archived emails")]
    public required string OutputDirectory { get; set; }

    [Option("start-date", HelpText = "Download emails from this date (yyyy-MM-dd)")]
    public DateTime? StartDate { get; set; }

    [Option("end-date", HelpText = "Download emails until this date (yyyy-MM-dd)")]
    public DateTime? EndDate { get; set; }

    [Option('a', "all-folders", Default = false, HelpText = "Download from all folders, not just INBOX")]
    public bool AllFolders { get; set; }

    [Option('v', "verbose", Default = false, HelpText = "Enable verbose logging")]
    public bool Verbose { get; set; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailDownloadException.cs
SIZE: 0.25 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

namespace MyImapDownloader;

// Custom Exceptions
public class EmailDownloadException(string message, int messageIndex, Exception innerException)
    : Exception(message, innerException)
{
    public int MessageIndex { get; } = messageIndex;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailDownloadService.cs
SIZE: 17.6 KB
MODIFIED: 12/18/2025 14:28:19
================================================================================

using System.Diagnostics;
using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MailKit.Security;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyImapDownloader.Telemetry;
using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;

namespace MyImapDownloader;

public class EmailDownloadService
{
    private readonly ILogger<EmailDownloadService> _logger;
    private readonly ImapConfiguration _config;
    private readonly EmailStorageService _storage;
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    public EmailDownloadService(
        ILogger<EmailDownloadService> logger,
        ImapConfiguration config,
        EmailStorageService storage)
    {
        _logger = logger;
        _config = config;
        _storage = storage;

        _retryPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .WaitAndRetryAsync(
                3,
                retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                (exception, timeSpan, retryCount, _) =>
                {
                    DiagnosticsConfig.RetryAttempts.Add(1,
                        new KeyValuePair<string, object?>("retry_count", retryCount),
                        new KeyValuePair<string, object?>("exception_type", exception.GetType().Name));

                    _logger.LogWarning(exception,
                        "Retry {RetryCount} with delay {Delay}",
                        retryCount, timeSpan);
                });

        _circuitBreakerPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .CircuitBreakerAsync(
                exceptionsAllowedBeforeBreaking: 5,
                durationOfBreak: TimeSpan.FromMinutes(2),
                onBreak: (ex, duration) =>
                {
                    using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
                        "CircuitBreakerOpened", ActivityKind.Internal);
                    activity?.SetTag("duration_seconds", duration.TotalSeconds);
                    activity?.SetTag("exception_type", ex.GetType().Name);
                    activity?.SetStatus(ActivityStatusCode.Error, "Circuit breaker opened");

                    _logger.LogError(ex, "Circuit breaker opened for {Duration}", duration);
                },
                onReset: () =>
                {
                    using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
                        "CircuitBreakerReset", ActivityKind.Internal);
                    _logger.LogInformation("Circuit breaker reset");
                });
    }

    public async Task DownloadEmailsAsync(
        DownloadOptions options,
        CancellationToken cancellationToken = default)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "DownloadEmails", ActivityKind.Client);

        activity?.SetTag("server", _config.Server);
        activity?.SetTag("port", _config.Port);
        activity?.SetTag("all_folders", options.AllFolders);
        activity?.SetTag("output_directory", options.OutputDirectory);

        if (options.StartDate.HasValue)
            activity?.SetTag("start_date", options.StartDate.Value.ToString("yyyy-MM-dd"));
        if (options.EndDate.HasValue)
            activity?.SetTag("end_date", options.EndDate.Value.ToString("yyyy-MM-dd"));

        var policy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);
        var stats = new DownloadStats();
        var sessionStopwatch = Stopwatch.StartNew();

        try
        {
            await policy.ExecuteAsync(async () =>
            {
                using var client = new ImapClient { Timeout = 180_000 };

                try
                {
                    await ConnectAndAuthenticateAsync(client, cancellationToken);

                    var folders = options.AllFolders
                        ? await GetAllFoldersAsync(client, cancellationToken)
                        : [client.Inbox];

                    activity?.SetTag("folder_count", folders.Count());

                    foreach (var folder in folders)
                    {
                        await DownloadFolderAsync(folder, options, stats, cancellationToken);
                    }
                }
                finally
                {
                    await DisconnectSafelyAsync(client);
                    await _storage.SaveIndexAsync(cancellationToken);
                }
            });

            activity?.SetStatus(ActivityStatusCode.Ok);
        }
        catch (AuthenticationException ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, "Authentication failed");
            activity?.RecordException(ex);
            _logger.LogCritical("Aborting: Authentication failed");
            throw;
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            throw;
        }
        finally
        {
            sessionStopwatch.Stop();

            activity?.SetTag("emails_new", stats.NewEmails);
            activity?.SetTag("emails_skipped", stats.SkippedDuplicates);
            activity?.SetTag("emails_errors", stats.Errors);
            activity?.SetTag("total_duration_ms", sessionStopwatch.ElapsedMilliseconds);

            _logger.LogInformation(
                "Download complete. New: {New}, Skipped: {Skipped}, Errors: {Errors}, Duration: {Duration}ms",
                stats.NewEmails, stats.SkippedDuplicates, stats.Errors, sessionStopwatch.ElapsedMilliseconds);
        }
    }

    private async Task<IEnumerable<IMailFolder>> GetAllFoldersAsync(
        ImapClient client, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "GetAllFolders", ActivityKind.Internal);

        var folders = new List<IMailFolder>();
        var personal = client.GetFolder(client.PersonalNamespaces[0]);

        await CollectFoldersRecursiveAsync(personal, folders, ct);

        if (!folders.Contains(client.Inbox))
            folders.Insert(0, client.Inbox);

        activity?.SetTag("folder_count", folders.Count);
        return folders;
    }

    private async Task CollectFoldersRecursiveAsync(
        IMailFolder parent, List<IMailFolder> folders, CancellationToken ct)
    {
        foreach (var folder in await parent.GetSubfoldersAsync(false, ct))
        {
            folders.Add(folder);
            await CollectFoldersRecursiveAsync(folder, folders, ct);
        }
    }

    private async Task DownloadFolderAsync(
        IMailFolder folder,
        DownloadOptions options,
        DownloadStats stats,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "DownloadFolder", ActivityKind.Internal);

        var folderStopwatch = Stopwatch.StartNew();
        activity?.SetTag("folder_name", folder.FullName);

        try
        {
            await folder.OpenAsync(FolderAccess.ReadOnly, ct);

            activity?.SetTag("message_count", folder.Count);
            _logger.LogInformation("Processing folder: {Folder} ({Count} messages)",
                folder.FullName, folder.Count);

            if (folder.Count == 0)
            {
                activity?.AddEvent(new ActivityEvent("EmptyFolder"));
                return;
            }

            var query = BuildSearchQuery(options.StartDate, options.EndDate);
            var uids = query != null
                ? await folder.SearchAsync(query, ct)
                : await folder.SearchAsync(SearchQuery.All, ct);

            activity?.SetTag("matching_messages", uids.Count);
            DiagnosticsConfig.SetQueuedEmails(uids.Count);

            _logger.LogInformation("Found {Count} messages matching criteria", uids.Count);

            const int batchSize = 50;
            for (int i = 0; i < uids.Count; i += batchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = uids.Skip(i).Take(batchSize).ToList();
                await DownloadBatchAsync(folder, batch, stats, ct);

                int processed = Math.Min(i + batchSize, uids.Count);
                double progress = (double)processed / uids.Count * 100;

                activity?.AddEvent(new ActivityEvent("BatchComplete", tags: new ActivityTagsCollection
                {
                    ["batch_end"] = processed,
                    ["total"] = uids.Count,
                    ["progress_percent"] = progress
                }));

                _logger.LogInformation("Progress: {Current}/{Total} ({Percent:F1}%)",
                    processed, uids.Count, progress);
            }

            DiagnosticsConfig.FoldersProcessed.Add(1,
                new KeyValuePair<string, object?>("folder_name", folder.FullName));

            activity?.SetStatus(ActivityStatusCode.Ok);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            _logger.LogError(ex, "Error processing folder: {Folder}", folder.FullName);
        }
        finally
        {
            folderStopwatch.Stop();
            DiagnosticsConfig.FolderProcessingDuration.Record(
                folderStopwatch.Elapsed.TotalMilliseconds,
                new KeyValuePair<string, object?>("folder_name", folder.FullName));
        }
    }

    private async Task DownloadBatchAsync(
        IMailFolder folder,
        IList<UniqueId> uids,
        DownloadStats stats,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "DownloadBatch", ActivityKind.Internal);

        var batchStopwatch = Stopwatch.StartNew();
        activity?.SetTag("folder_name", folder.FullName);
        activity?.SetTag("batch_size", uids.Count);

        int batchNew = 0, batchSkipped = 0, batchErrors = 0;

        foreach (var uid in uids)
        {
            if (ct.IsCancellationRequested) break;

            var emailStopwatch = Stopwatch.StartNew();

            try
            {
                using var emailActivity = DiagnosticsConfig.ActivitySource.StartActivity(
                    "DownloadEmail", ActivityKind.Client);

                emailActivity?.SetTag("folder", folder.FullName);
                emailActivity?.SetTag("uid", uid.Id);

                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2));
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                    timeoutCts.Token, ct);

                var message = await folder.GetMessageAsync(uid, linkedCts.Token);

                emailActivity?.SetTag("message_id", message.MessageId);
                emailActivity?.SetTag("subject", Truncate(message.Subject, 100));
                emailActivity?.SetTag("from", message.From?.ToString());
                emailActivity?.SetTag("date", message.Date.ToString("O"));

                long messageSize = EstimateMessageSize(message);
                DiagnosticsConfig.EmailSize.Record(messageSize,
                    new KeyValuePair<string, object?>("folder", folder.FullName));

                bool isNew = await _storage.StoreEmailAsync(message, folder.FullName, linkedCts.Token);

                emailStopwatch.Stop();
                DiagnosticsConfig.EmailDownloadDuration.Record(
                    emailStopwatch.Elapsed.TotalMilliseconds,
                    new KeyValuePair<string, object?>("folder", folder.FullName),
                    new KeyValuePair<string, object?>("is_new", isNew));

                if (isNew)
                {
                    batchNew++;
                    stats.NewEmails++;
                    DiagnosticsConfig.EmailsDownloaded.Add(1,
                        new KeyValuePair<string, object?>("folder", folder.FullName));
                    DiagnosticsConfig.BytesDownloaded.Add(messageSize,
                        new KeyValuePair<string, object?>("folder", folder.FullName));
                    DiagnosticsConfig.IncrementTotalEmails();
                }
                else
                {
                    batchSkipped++;
                    stats.SkippedDuplicates++;
                    DiagnosticsConfig.EmailsSkipped.Add(1,
                        new KeyValuePair<string, object?>("folder", folder.FullName));
                }

                emailActivity?.SetTag("is_new", isNew);
                emailActivity?.SetStatus(ActivityStatusCode.Ok);
            }
            catch (OperationCanceledException)
            {
                batchErrors++;
                stats.Errors++;
                DiagnosticsConfig.EmailErrors.Add(1,
                    new KeyValuePair<string, object?>("folder", folder.FullName),
                    new KeyValuePair<string, object?>("error_type", "timeout"));

                _logger.LogWarning("Timeout downloading message {Uid} in {Folder}", uid, folder.FullName);
            }
            catch (Exception ex)
            {
                batchErrors++;
                stats.Errors++;
                DiagnosticsConfig.EmailErrors.Add(1,
                    new KeyValuePair<string, object?>("folder", folder.FullName),
                    new KeyValuePair<string, object?>("error_type", ex.GetType().Name));

                _logger.LogError(ex, "Error downloading {Uid} in {Folder}", uid, folder.FullName);
            }
        }

        batchStopwatch.Stop();
        DiagnosticsConfig.BatchProcessingDuration.Record(
            batchStopwatch.Elapsed.TotalMilliseconds,
            new KeyValuePair<string, object?>("folder", folder.FullName),
            new KeyValuePair<string, object?>("batch_size", uids.Count));

        activity?.SetTag("new_emails", batchNew);
        activity?.SetTag("skipped_emails", batchSkipped);
        activity?.SetTag("errors", batchErrors);
        activity?.SetTag("duration_ms", batchStopwatch.ElapsedMilliseconds);
    }

    private static long EstimateMessageSize(MimeMessage message)
    {
        using var stream = new MemoryStream();
        message.WriteTo(stream);
        return stream.Length;
    }

    private static SearchQuery? BuildSearchQuery(DateTime? startDate, DateTime? endDate)
    {
        SearchQuery? query = null;

        if (startDate.HasValue)
            query = SearchQuery.DeliveredAfter(startDate.Value);

        if (endDate.HasValue)
        {
            var endQuery = SearchQuery.DeliveredBefore(endDate.Value.AddDays(1));
            query = query != null ? query.And(endQuery) : endQuery;
        }

        return query;
    }

    private async Task ConnectAndAuthenticateAsync(ImapClient client, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "ConnectAndAuthenticate", ActivityKind.Client);

        activity?.SetTag("server", _config.Server);
        activity?.SetTag("port", _config.Port);

        DiagnosticsConfig.ConnectionAttempts.Add(1,
            new KeyValuePair<string, object?>("server", _config.Server));

        var connectStopwatch = Stopwatch.StartNew();

        try
        {
            _logger.LogInformation("Connecting to {Server}:{Port}", _config.Server, _config.Port);

            await client.ConnectAsync(
                _config.Server,
                _config.Port,
                SecureSocketOptions.SslOnConnect,
                ct);

            activity?.AddEvent(new ActivityEvent("Connected"));

            await client.AuthenticateAsync(_config.Username, _config.Password, ct);

            connectStopwatch.Stop();

            DiagnosticsConfig.IncrementActiveConnections();
            activity?.SetTag("connect_duration_ms", connectStopwatch.ElapsedMilliseconds);
            activity?.SetStatus(ActivityStatusCode.Ok);

            _logger.LogInformation("Connected successfully in {Duration}ms",
                connectStopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            throw;
        }
    }

    private async Task DisconnectSafelyAsync(ImapClient client)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "Disconnect", ActivityKind.Client);

        try
        {
            if (client.IsConnected)
            {
                await client.DisconnectAsync(true);
                DiagnosticsConfig.DecrementActiveConnections();
                activity?.SetStatus(ActivityStatusCode.Ok);
                _logger.LogDebug("Disconnected from server");
            }
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            _logger.LogWarning(ex, "Error during disconnect");
        }
    }

    private static string Truncate(string? input, int maxLength)
    {
        if (string.IsNullOrEmpty(input)) return "(no subject)";
        return input.Length <= maxLength ? input : input[..(maxLength - 3)] + "...";
    }

    private class DownloadStats
    {
        public int NewEmails;
        public int SkippedDuplicates;
        public int Errors;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailStorageService.cs
SIZE: 12.86 KB
MODIFIED: 12/18/2025 14:28:36
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader;

/// <summary>
/// Stores emails in a Maildir-inspired structure with deduplication and metadata tracking.
/// </summary>
public class EmailStorageService
{
    private readonly ILogger<EmailStorageService> _logger;
    private readonly string _baseDirectory;
    private readonly HashSet<string> _knownMessageIds;
    private readonly string _indexPath;

    // Storage-specific metrics
    private static readonly Counter<long> FilesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.files.written", unit: "files", description: "Number of email files written to disk");
    private static readonly Counter<long> BytesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.bytes.written", unit: "bytes", description: "Total bytes written to disk");
    private static readonly Histogram<double> WriteLatency = DiagnosticsConfig.Meter.CreateHistogram<double>(
        "storage.write.latency", unit: "ms", description: "Time to write email to disk");
    private static readonly Counter<long> DuplicatesDetected = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.duplicates.detected", unit: "emails", description: "Number of duplicate emails detected");

    public EmailStorageService(ILogger<EmailStorageService> logger, string baseDirectory)
    {
        _logger = logger;
        _baseDirectory = baseDirectory;
        _indexPath = Path.Combine(baseDirectory, ".email-index.json");
        _knownMessageIds = LoadIndex();
    }

    /// <summary>
    /// Stores an email message, returning true if it was new, false if duplicate.
    /// </summary>
    public async Task<bool> StoreEmailAsync(
        MimeMessage message,
        string folderName,
        CancellationToken ct = default)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "StoreEmail", ActivityKind.Internal);

        var stopwatch = Stopwatch.StartNew();
        string messageId = GetMessageIdentifier(message);

        activity?.SetTag("message_id", messageId);
        activity?.SetTag("folder", folderName);
        activity?.SetTag("subject", Truncate(message.Subject, 100));

        if (_knownMessageIds.Contains(messageId))
        {
            DuplicatesDetected.Add(1, new KeyValuePair<string, object?>("folder", folderName));
            activity?.SetTag("is_duplicate", true);
            activity?.SetStatus(ActivityStatusCode.Ok, "Duplicate skipped");
            _logger.LogDebug("Skipping duplicate: {MessageId}", messageId);
            return false;
        }

        string folderPath = GetFolderPath(folderName);
        EnsureMaildirStructure(folderPath);

        string filename = GenerateFilename(message, messageId);
        string tempPath = Path.Combine(folderPath, "tmp", filename);
        string finalPath = Path.Combine(folderPath, "cur", filename);

        activity?.SetTag("file_path", finalPath);

        try
        {
            long bytesWritten;

            // Write to tmp first (atomic write pattern)
            await using (var stream = File.Create(tempPath))
            {
                await message.WriteToAsync(stream, ct);
                bytesWritten = stream.Length;
            }

            // Move to cur (atomic on most filesystems)
            File.Move(tempPath, finalPath, overwrite: false);

            // Write sidecar metadata
            await WriteMetadataAsync(finalPath, message, folderName, ct);

            _knownMessageIds.Add(messageId);

            stopwatch.Stop();

            // Record metrics
            FilesWritten.Add(1, new KeyValuePair<string, object?>("folder", folderName));
            BytesWritten.Add(bytesWritten, new KeyValuePair<string, object?>("folder", folderName));
            WriteLatency.Record(stopwatch.Elapsed.TotalMilliseconds,
                new KeyValuePair<string, object?>("folder", folderName));

            activity?.SetTag("bytes_written", bytesWritten);
            activity?.SetTag("write_duration_ms", stopwatch.ElapsedMilliseconds);
            activity?.SetTag("is_duplicate", false);
            activity?.SetStatus(ActivityStatusCode.Ok);

            _logger.LogInformation("Stored: {Subject} -> {Path} ({Size} bytes in {Duration}ms)",
                Truncate(message.Subject, 50), finalPath, bytesWritten, stopwatch.ElapsedMilliseconds);

            return true;
        }
        catch (IOException ex) when (File.Exists(finalPath))
        {
            // Race condition - file already exists, treat as duplicate
            activity?.SetTag("race_condition", true);
            activity?.SetStatus(ActivityStatusCode.Ok, "Race condition duplicate");
            _logger.LogDebug("The exception is {message}", ex.Message);
            _logger.LogDebug("File already exists (race): {Path}", finalPath);
            TryDelete(tempPath);
            return false;
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            _logger.LogError(ex, "Failed to store email: {MessageId}", messageId);
            TryDelete(tempPath);
            throw;
        }
    }

    /// <summary>
    /// Gets a unique identifier for the message, preferring Message-ID header.
    /// </summary>
    private static string GetMessageIdentifier(MimeMessage message)
    {
        if (!string.IsNullOrWhiteSpace(message.MessageId))
        {
            return NormalizeMessageId(message.MessageId);
        }

        var sb = new StringBuilder();
        sb.Append(message.Date.ToUniversalTime().ToString("O"));
        sb.Append('|');
        sb.Append(message.From?.ToString() ?? "");
        sb.Append('|');
        sb.Append(message.Subject ?? "");

        return ComputeHash(sb.ToString());
    }

    private static string NormalizeMessageId(string messageId)
    {
        return messageId.Trim().Trim('<', '>').ToLowerInvariant();
    }

    private static string ComputeHash(string input)
    {
        byte[] bytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));
        return Convert.ToHexString(bytes)[..16].ToLowerInvariant();
    }

    private static string GenerateFilename(MimeMessage message, string messageId)
    {
        long timestamp = message.Date.ToUnixTimeSeconds();
        string safeId = SanitizeForFilename(messageId, 40);
        string hostname = SanitizeForFilename(Environment.MachineName, 20);

        return $"{timestamp}.{safeId}.{hostname}:2,S.eml";
    }

    private static string SanitizeForFilename(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input))
            return "unknown";

        var sb = new StringBuilder(Math.Min(input.Length, maxLength));
        foreach (char c in input)
        {
            if (char.IsLetterOrDigit(c) || c == '-' || c == '_' || c == '.')
                sb.Append(c);
            else if (sb.Length > 0 && sb[^1] != '_')
                sb.Append('_');

            if (sb.Length >= maxLength)
                break;
        }

        return sb.ToString().Trim('_');
    }

    private string GetFolderPath(string folderName)
    {
        string safeName = SanitizeForFilename(folderName, 100);
        return Path.Combine(_baseDirectory, safeName);
    }

    private static void EnsureMaildirStructure(string folderPath)
    {
        Directory.CreateDirectory(Path.Combine(folderPath, "cur"));
        Directory.CreateDirectory(Path.Combine(folderPath, "new"));
        Directory.CreateDirectory(Path.Combine(folderPath, "tmp"));
    }

    private static async Task WriteMetadataAsync(
        string emlPath,
        MimeMessage message,
        string folderName,
        CancellationToken ct)
    {
        var metadata = new EmailMetadata
        {
            MessageId = message.MessageId,
            Subject = message.Subject,
            From = message.From?.ToString(),
            To = message.To?.ToString(),
            Date = message.Date.UtcDateTime,
            Folder = folderName,
            ArchivedAt = DateTime.UtcNow,
            HasAttachments = message.Attachments.Any(),
            AttachmentCount = message.Attachments.Count()
        };

        string metaPath = emlPath + ".meta.json";
        await using var stream = File.Create(metaPath);
        await JsonSerializer.SerializeAsync(stream, metadata,
            new JsonSerializerOptions { WriteIndented = true }, ct);
    }

    private HashSet<string> LoadIndex()
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "LoadIndex", ActivityKind.Internal);

        try
        {
            if (File.Exists(_indexPath))
            {
                string json = File.ReadAllText(_indexPath);
                var ids = JsonSerializer.Deserialize<List<string>>(json);
                var result = ids != null ? new HashSet<string>(ids) : [];

                activity?.SetTag("index_count", result.Count);
                activity?.SetTag("source", "file");
                activity?.SetStatus(ActivityStatusCode.Ok);

                return result;
            }
        }
        catch (Exception ex)
        {
            activity?.RecordException(ex);
            _logger.LogWarning(ex, "Could not load index, will rebuild from files");
        }

        activity?.SetTag("source", "rebuild");
        return RebuildIndexFromFiles();
    }

    private HashSet<string> RebuildIndexFromFiles()
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "RebuildIndex", ActivityKind.Internal);

        var stopwatch = Stopwatch.StartNew();
        var ids = new HashSet<string>();

        if (!Directory.Exists(_baseDirectory))
        {
            activity?.SetTag("index_count", 0);
            return ids;
        }

        int filesScanned = 0;
        foreach (var metaFile in Directory.EnumerateFiles(
            _baseDirectory, "*.meta.json", SearchOption.AllDirectories))
        {
            filesScanned++;
            try
            {
                string json = File.ReadAllText(metaFile);
                var meta = JsonSerializer.Deserialize<EmailMetadata>(json);
                if (!string.IsNullOrEmpty(meta?.MessageId))
                    ids.Add(NormalizeMessageId(meta.MessageId));
            }
            catch { /* Skip malformed metadata */ }
        }

        stopwatch.Stop();

        activity?.SetTag("files_scanned", filesScanned);
        activity?.SetTag("index_count", ids.Count);
        activity?.SetTag("rebuild_duration_ms", stopwatch.ElapsedMilliseconds);
        activity?.SetStatus(ActivityStatusCode.Ok);

        _logger.LogInformation("Rebuilt index with {Count} known emails from {Files} files in {Duration}ms",
            ids.Count, filesScanned, stopwatch.ElapsedMilliseconds);

        return ids;
    }

    public async Task SaveIndexAsync(CancellationToken ct = default)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "SaveIndex", ActivityKind.Internal);

        var stopwatch = Stopwatch.StartNew();

        try
        {
            Directory.CreateDirectory(_baseDirectory);
            await using var stream = File.Create(_indexPath);
            await JsonSerializer.SerializeAsync(stream, _knownMessageIds.ToList(), cancellationToken: ct);

            stopwatch.Stop();

            activity?.SetTag("index_count", _knownMessageIds.Count);
            activity?.SetTag("save_duration_ms", stopwatch.ElapsedMilliseconds);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            throw;
        }
    }

    private static void TryDelete(string path)
    {
        try { File.Delete(path); } catch { /* Ignore cleanup failures */ }
    }

    private static string Truncate(string? input, int maxLength)
    {
        if (string.IsNullOrEmpty(input)) return "(no subject)";
        return input.Length <= maxLength ? input : input[..(maxLength - 3)] + "...";
    }
}

public record EmailMetadata
{
    public string? MessageId { get; init; }
    public string? Subject { get; init; }
    public string? From { get; init; }
    public string? To { get; init; }
    public DateTime Date { get; init; }
    public string? Folder { get; init; }
    public DateTime ArchivedAt { get; init; }
    public bool HasAttachments { get; init; }
    public int AttachmentCount { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\ImapConfiguration.cs
SIZE: 0.32 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

namespace MyImapDownloader;

// Configuration Model
public class ImapConfiguration
{
    public required string Server { get; set; }
    public int Port { get; set; }
    public required string Username { get; set; }
    public required string Password { get; set; }
    public bool UseSsl { get; set; } = true;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\MyImapDownloader.csproj
SIZE: 1.2 KB
MODIFIED: 12/18/2025 14:24:43
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TargetFramework, ImplicitUsings, Nullable, LangVersion come from Directory.Build.props -->
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CommandLineParser" />
    <PackageReference Include="MailKit" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    <PackageReference Include="Polly" />
  </ItemGroup>
  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Program.cs
SIZE: 4.42 KB
MODIFIED: 12/18/2025 14:24:55
================================================================================

using System.Diagnostics;
using CommandLine;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyImapDownloader;
using MyImapDownloader.Telemetry;

var parseResult = Parser.Default.ParseArguments<DownloadOptions>(args);

await parseResult.WithParsedAsync(async options =>
{
    var host = Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, config) =>
        {
            config.SetBasePath(AppContext.BaseDirectory);
            config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((context, logging) =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.SetMinimumLevel(options.Verbose ? LogLevel.Debug : LogLevel.Information);
            logging.AddTelemetryLogging(context.Configuration);
        })
        .ConfigureServices((context, services) =>
        {
            // Add telemetry
            services.AddTelemetry(context.Configuration);

            services.AddSingleton(options);
            services.AddSingleton(new ImapConfiguration
            {
                Server = options.Server,
                Username = options.Username,
                Password = options.Password,
                Port = options.Port
            });
            services.AddSingleton(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<EmailStorageService>>();
                return new EmailStorageService(logger, options.OutputDirectory);
            });
            services.AddTransient<EmailDownloadService>();
        })
        .Build();

    var downloadService = host.Services.GetRequiredService<EmailDownloadService>();
    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    var telemetryConfig = host.Services.GetRequiredService<TelemetryConfiguration>();

    // Create root activity for the entire session
    using var rootActivity = DiagnosticsConfig.ActivitySource.StartActivity(
        "EmailArchiveSession", ActivityKind.Server);

    rootActivity?.SetTag("service.name", telemetryConfig.ServiceName);
    rootActivity?.SetTag("service.version", telemetryConfig.ServiceVersion);
    rootActivity?.SetTag("host.name", Environment.MachineName);
    rootActivity?.SetTag("process.pid", Environment.ProcessId);
    rootActivity?.SetTag("telemetry.directory", telemetryConfig.OutputDirectory);

    var sessionStopwatch = Stopwatch.StartNew();

    try
    {
        logger.LogInformation("Starting email archive download...");
        logger.LogInformation("Output: {Output}", Path.GetFullPath(options.OutputDirectory));
        logger.LogInformation("Telemetry output: {TelemetryOutput}",
            Path.GetFullPath(telemetryConfig.OutputDirectory));

        rootActivity?.AddEvent(new ActivityEvent("DownloadStarted"));

        await downloadService.DownloadEmailsAsync(options);

        sessionStopwatch.Stop();

        rootActivity?.SetTag("session_duration_ms", sessionStopwatch.ElapsedMilliseconds);
        rootActivity?.SetStatus(ActivityStatusCode.Ok);
        rootActivity?.AddEvent(new ActivityEvent("DownloadCompleted"));

        logger.LogInformation("Archive complete! Session duration: {Duration}ms",
            sessionStopwatch.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        rootActivity?.SetStatus(ActivityStatusCode.Error, ex.Message);
        rootActivity?.RecordException(ex);
        rootActivity?.AddEvent(new ActivityEvent("DownloadFailed", tags: new ActivityTagsCollection
        {
            ["exception.type"] = ex.GetType().FullName,
            ["exception.message"] = ex.Message
        }));

        logger.LogCritical(ex, "Fatal error during download");
        Environment.ExitCode = 1;
    }
    finally
    {
        // Ensure all telemetry is flushed before exit
        logger.LogInformation("Flushing telemetry data...");

        // Give time for async exporters to flush
        await Task.Delay(TimeSpan.FromSeconds(2));

        // Dispose file writers to flush remaining data
        var traceWriter = host.Services.GetService<JsonTelemetryFileWriter>();
        traceWriter?.Dispose();
    }
});

parseResult.WithNotParsed(errors =>
{
    Environment.ExitCode = 1;
});



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\ActivityExtension.cs
SIZE: 1.33 KB
MODIFIED: 12/18/2025 14:26:06
================================================================================

using System.Diagnostics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for Activity to provide RecordException functionality
/// that works across OpenTelemetry versions.
/// </summary>
public static class ActivityExtensions
{
    /// <summary>
    /// Records an exception as an event on the activity with standard attributes.
    /// </summary>
    public static void RecordException(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        var tags = new ActivityTagsCollection
        {
            ["exception.type"] = exception.GetType().FullName,
            ["exception.message"] = exception.Message,
        };

        if (!string.IsNullOrEmpty(exception.StackTrace))
        {
            tags["exception.stacktrace"] = exception.StackTrace;
        }

        activity.AddEvent(new ActivityEvent("exception", tags: tags));
    }

    /// <summary>
    /// Sets the activity status to error with the exception message.
    /// </summary>
    public static void SetErrorStatus(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
        activity.RecordException(exception);
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\DiagnosticsConfig.cs
SIZE: 4.31 KB
MODIFIED: 12/18/2025 14:06:08
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Central configuration for all diagnostics sources used in the application.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyImapDownloader";
    public const string ServiceVersion = "1.0.0";

    // ActivitySource for distributed tracing
    public static readonly ActivitySource ActivitySource = new(ServiceName, ServiceVersion);

    // Meter for metrics
    public static readonly Meter Meter = new(ServiceName, ServiceVersion);

    // Counters
    public static readonly Counter<long> EmailsDownloaded = Meter.CreateCounter<long>(
        "emails.downloaded",
        unit: "emails",
        description: "Total number of emails successfully downloaded");

    public static readonly Counter<long> EmailsSkipped = Meter.CreateCounter<long>(
        "emails.skipped",
        unit: "emails",
        description: "Number of emails skipped (duplicates)");

    public static readonly Counter<long> EmailErrors = Meter.CreateCounter<long>(
        "emails.errors",
        unit: "errors",
        description: "Number of email download errors");

    public static readonly Counter<long> BytesDownloaded = Meter.CreateCounter<long>(
        "bytes.downloaded",
        unit: "bytes",
        description: "Total bytes downloaded");

    public static readonly Counter<long> FoldersProcessed = Meter.CreateCounter<long>(
        "folders.processed",
        unit: "folders",
        description: "Number of folders processed");

    public static readonly Counter<long> ConnectionAttempts = Meter.CreateCounter<long>(
        "connection.attempts",
        unit: "attempts",
        description: "Number of IMAP connection attempts");

    public static readonly Counter<long> RetryAttempts = Meter.CreateCounter<long>(
        "retry.attempts",
        unit: "retries",
        description: "Number of retry attempts due to failures");

    // Histograms
    public static readonly Histogram<double> EmailDownloadDuration = Meter.CreateHistogram<double>(
        "email.download.duration",
        unit: "ms",
        description: "Time taken to download individual emails");

    public static readonly Histogram<double> FolderProcessingDuration = Meter.CreateHistogram<double>(
        "folder.processing.duration",
        unit: "ms",
        description: "Time taken to process entire folders");

    public static readonly Histogram<double> BatchProcessingDuration = Meter.CreateHistogram<double>(
        "batch.processing.duration",
        unit: "ms",
        description: "Time taken to process email batches");

    public static readonly Histogram<long> EmailSize = Meter.CreateHistogram<long>(
        "email.size",
        unit: "bytes",
        description: "Size of downloaded emails");

    // Gauges (using ObservableGauge for current state)
    private static int _activeConnections;
    private static int _queuedEmails;
    private static long _totalEmailsInSession;

    public static readonly ObservableGauge<int> ActiveConnections = Meter.CreateObservableGauge(
        "connections.active",
        () => _activeConnections,
        unit: "connections",
        description: "Number of active IMAP connections");

    public static readonly ObservableGauge<int> QueuedEmails = Meter.CreateObservableGauge(
        "emails.queued",
        () => _queuedEmails,
        unit: "emails",
        description: "Number of emails queued for processing");

    public static readonly ObservableGauge<long> TotalEmailsInSession = Meter.CreateObservableGauge(
        "emails.total.session",
        () => _totalEmailsInSession,
        unit: "emails",
        description: "Total emails processed in current session");

    // Methods to update gauge values
    public static void SetActiveConnections(int count) => _activeConnections = count;
    public static void IncrementActiveConnections() => Interlocked.Increment(ref _activeConnections);
    public static void DecrementActiveConnections() => Interlocked.Decrement(ref _activeConnections);
    public static void SetQueuedEmails(int count) => _queuedEmails = count;
    public static void IncrementTotalEmails() => Interlocked.Increment(ref _totalEmailsInSession);
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonFileLogExporter.cs
SIZE: 3.14 KB
MODIFIED: 12/18/2025 14:24:19
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter : BaseExporter<LogRecord>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileLogExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonFileMetricsExporter.cs
SIZE: 6.78 KB
MODIFIED: 12/18/2025 14:35:39
================================================================================

using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter : BaseExporter<Metric>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileMetricsExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        MeterVersion = metric.MeterVersion,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    _writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?> ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags;
    }

    private static MetricValue ExtractValue(Metric metric, MetricPoint point)
    {
        var value = new MetricValue();

        try
        {
            switch (metric.MetricType)
            {
                case MetricType.LongSum:
                    value.LongValue = point.GetSumLong();
                    break;
                case MetricType.DoubleSum:
                    value.DoubleValue = point.GetSumDouble();
                    break;
                case MetricType.LongGauge:
                    value.LongValue = point.GetGaugeLastValueLong();
                    break;
                case MetricType.DoubleGauge:
                    value.DoubleValue = point.GetGaugeLastValueDouble();
                    break;
                case MetricType.Histogram:
                    value.DoubleValue = point.GetHistogramSum();
                    value.Count = (long)point.GetHistogramCount();
                    value.Buckets = ExtractHistogramBuckets(point);
                    break;
                case MetricType.ExponentialHistogram:
                    // ExponentialHistogramData in OpenTelemetry 1.14.0 uses different API
                    // Access count and sum through the MetricPoint directly
                    var expHistData = point.GetExponentialHistogramData();
                    value.Count = GetExponentialHistogramCount(expHistData);
                    value.DoubleValue = GetExponentialHistogramSum(expHistData);
                    break;
            }
        }
        catch
        {
            // If extraction fails, return partial data
        }

        return value;
    }

    private static long GetExponentialHistogramCount(ExponentialHistogramData data)
    {
        try
        {
            // Try accessing via reflection for API compatibility
            var countProperty = typeof(ExponentialHistogramData).GetProperty("Count");
            if (countProperty != null)
            {
                var val = countProperty.GetValue(data);
                if (val is long l) return l;
                if (val is ulong ul) return (long)ul;
                if (val is int i) return i;
            }
            
            // Try ZeroCount + positive/negative bucket counts as fallback
            var zeroCountProp = typeof(ExponentialHistogramData).GetProperty("ZeroCount");
            if (zeroCountProp != null)
            {
                var zeroCount = Convert.ToInt64(zeroCountProp.GetValue(data) ?? 0);
                return zeroCount; // This is a partial count but better than nothing
            }
        }
        catch
        {
            // Ignore reflection errors
        }
        
        return 0;
    }

    private static double GetExponentialHistogramSum(ExponentialHistogramData data)
    {
        try
        {
            // Try to access Sum via reflection for API compatibility
            var sumProperty = typeof(ExponentialHistogramData).GetProperty("Sum");
            if (sumProperty != null)
            {
                var val = sumProperty.GetValue(data);
                if (val is double d) return d;
            }
        }
        catch
        {
            // Ignore reflection errors
        }
        
        return 0.0;
    }

    private static List<HistogramBucket>? ExtractHistogramBuckets(MetricPoint point)
    {
        try
        {
            var buckets = new List<HistogramBucket>();
            foreach (var bucket in point.GetHistogramBuckets())
            {
                buckets.Add(new HistogramBucket
                {
                    ExplicitBound = bucket.ExplicitBound,
                    BucketCount = bucket.BucketCount
                });
            }
            return buckets.Count > 0 ? buckets : null;
        }
        catch
        {
            return null;
        }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public string? MeterVersion { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public MetricValue? Value { get; init; }
}

public record MetricValue
{
    public long? LongValue { get; set; }
    public double? DoubleValue { get; set; }
    public long? Count { get; set; }
    public List<HistogramBucket>? Buckets { get; set; }
}

public record HistogramBucket
{
    public double ExplicitBound { get; init; }
    public long BucketCount { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonFileTraceExporter.cs
SIZE: 4.05 KB
MODIFIED: 12/18/2025 14:51:32
================================================================================

using System.Diagnostics;
using OpenTelemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter : BaseExporter<Activity>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileTraceExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList(),
                    Links = activity.Links.Select(l => new SpanLink
                    {
                        TraceId = l.Context.TraceId.ToString(),
                        SpanId = l.Context.SpanId.ToString()
                    }).ToList(),
                    Resource = new ResourceInfo
                    {
                        ServiceName = activity.GetTagItem("service.name")?.ToString(),
                        ServiceVersion = activity.GetTagItem("service.version")?.ToString()
                    }
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
    public List<SpanLink>? Links { get; init; }
    public ResourceInfo? Resource { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}

public record SpanLink
{
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
}

public record ResourceInfo
{
    public string? ServiceName { get; init; }
    public string? ServiceVersion { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonTelemetryFileWriter.cs
SIZE: 5.17 KB
MODIFIED: 12/18/2025 14:23:58
================================================================================

using System.Collections.Concurrent;
using System.Text.Json;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Thread-safe JSON file writer that manages daily files with size limits.
/// Each telemetry record is written as a separate JSON line (JSONL format).
/// Gracefully handles write failures without crashing the application.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _baseDirectory;
    private readonly string _prefix;
    private readonly long _maxFileSizeBytes;
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly ConcurrentQueue<object> _buffer = new();
    private readonly Timer _flushTimer;
    private readonly JsonSerializerOptions _jsonOptions;

    private string _currentDate = "";
    private string _currentFilePath = "";
    private int _fileSequence;
    private long _currentFileSize;
    private bool _disposed;
    private bool _writeEnabled = true;

    public JsonTelemetryFileWriter(
        string baseDirectory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _baseDirectory = baseDirectory;
        _prefix = prefix;
        _maxFileSizeBytes = maxFileSizeBytes;

        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = false, // JSONL format - single line per record
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };

        // Try to create base directory - if it fails, disable writes
        try
        {
            Directory.CreateDirectory(_baseDirectory);
        }
        catch
        {
            _writeEnabled = false;
        }

        _flushTimer = new Timer(_ => FlushAsync().ConfigureAwait(false), null, flushInterval, flushInterval);
    }

    public void Enqueue(object record)
    {
        if (_disposed || !_writeEnabled) return;
        _buffer.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        if (_disposed || !_writeEnabled || _buffer.IsEmpty) return;

        if (!await _writeLock.WaitAsync(TimeSpan.FromSeconds(5)))
            return; // Skip this flush cycle if we can't get the lock

        try
        {
            var records = new List<object>();
            while (_buffer.TryDequeue(out var record))
            {
                records.Add(record);
            }

            foreach (var record in records)
            {
                await WriteRecordAsync(record);
            }
        }
        catch
        {
            // If we consistently fail to write, disable future writes
            // to avoid accumulating memory
            if (_buffer.Count > 10000)
            {
                _writeEnabled = false;
                while (_buffer.TryDequeue(out _)) { } // Clear buffer
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordAsync(object record)
    {
        if (!_writeEnabled) return;

        try
        {
            string today = DateTime.UtcNow.ToString("yyyy-MM-dd");

            // Check if we need a new file (new day or size exceeded)
            if (today != _currentDate || _currentFileSize >= _maxFileSizeBytes)
            {
                if (today != _currentDate)
                {
                    _currentDate = today;
                    _fileSequence = 0;
                }
                RotateFile();
            }

            // Each record is a complete JSON object on a single line (JSONL format)
            string json = JsonSerializer.Serialize(record, record.GetType(), _jsonOptions);
            string line = json + Environment.NewLine;
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(line);

            // Check if adding this record would exceed size limit
            if (_currentFileSize + bytes.Length > _maxFileSizeBytes && _currentFileSize > 0)
            {
                RotateFile();
            }

            await File.AppendAllTextAsync(_currentFilePath, line);
            _currentFileSize += bytes.Length;
        }
        catch
        {
            // Individual write failures are silently ignored
            // The application continues normally
        }
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = Path.Combine(
            _baseDirectory,
            $"{_prefix}_{_currentDate}_{_fileSequence:D4}.jsonl");
        
        try
        {
            _currentFileSize = File.Exists(_currentFilePath) ? new FileInfo(_currentFilePath).Length : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _flushTimer.Dispose();
        
        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }
        
        _writeLock.Dispose();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\TelemetryConfiguration.cs
SIZE: 0.79 KB
MODIFIED: 12/18/2025 14:07:42
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\TelemetryDirectoryResolver.cs
SIZE: 3.32 KB
MODIFIED: 12/18/2025 14:26:39
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification
/// with graceful fallback behavior.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName = "MyImapDownloader")
    {
        // Try locations in order of preference
        var candidates = GetCandidateDirectories(appName);
        
        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }
        
        return null; // No writable location found - telemetry will be disabled
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        // 1. XDG_DATA_HOME (Linux/macOS) or LocalApplicationData (Windows)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, appName, "telemetry");
        }
        
        // 2. Platform-specific user data directory
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            yield return Path.Combine(localAppData, appName, "telemetry");
        }
        
        // 3. XDG_STATE_HOME for state/log data (more appropriate for telemetry)
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, appName, "telemetry");
        }
        
        // 4. Fallback to ~/.local/state on Unix-like systems
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            yield return Path.Combine(homeDir, ".local", "state", appName, "telemetry");
            yield return Path.Combine(homeDir, ".local", "share", appName, "telemetry");
        }
        
        // 5. Directory relative to executable
        var exeDir = AppContext.BaseDirectory;
        if (!string.IsNullOrEmpty(exeDir))
        {
            yield return Path.Combine(exeDir, "telemetry");
        }
        
        // 6. Current working directory as last resort
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            // Attempt to create the directory
            Directory.CreateDirectory(path);
            
            // Verify we can write to it
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\TelemetryExtensions.cs
SIZE: 8.61 KB
MODIFIED: 12/18/2025 14:50:58
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for configuring OpenTelemetry with JSON file exporters.
/// </summary>
public static class TelemetryExtensions
{
    public static IServiceCollection AddTelemetry(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);
        services.AddSingleton(config);

        // Resolve telemetry directory with XDG compliance and fallback
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        
        if (telemetryBaseDir == null)
        {
            // No writable location found - register placeholder services
            // Telemetry will be effectively disabled but app continues normally
            services.AddSingleton<ITelemetryWriterProvider>(new NullTelemetryWriterProvider());
            config.EnableTracing = false;
            config.EnableMetrics = false;
            config.EnableLogging = false;
            
            return services;
        }

        // Update config with resolved directory
        config.OutputDirectory = telemetryBaseDir;

        var tracesDir = Path.Combine(telemetryBaseDir, "traces");
        var metricsDir = Path.Combine(telemetryBaseDir, "metrics");
        var logsDir = Path.Combine(telemetryBaseDir, "logs");

        TryCreateDirectory(tracesDir);
        TryCreateDirectory(metricsDir);
        TryCreateDirectory(logsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        // Create file writers
        JsonTelemetryFileWriter? traceWriter = null;
        JsonTelemetryFileWriter? metricsWriter = null;
        JsonTelemetryFileWriter? logsWriter = null;

        try
        {
            traceWriter = new JsonTelemetryFileWriter(
                tracesDir, "traces", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Trace writing disabled */ }

        try
        {
            metricsWriter = new JsonTelemetryFileWriter(
                metricsDir, "metrics", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Metrics writing disabled */ }

        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Log writing disabled */ }

        // Register the writer provider instead of nullable writers directly
        var writerProvider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);
        services.AddSingleton<ITelemetryWriterProvider>(writerProvider);
        
        // Also register the trace writer directly for Program.cs disposal
        if (traceWriter != null)
        {
            services.AddSingleton(traceWriter);
        }

        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(
                serviceName: config.ServiceName,
                serviceVersion: config.ServiceVersion)
            .AddAttributes(new Dictionary<string, object>
            {
                ["host.name"] = Environment.MachineName,
                ["os.type"] = Environment.OSVersion.Platform.ToString(),
                ["os.version"] = Environment.OSVersion.VersionString,
                ["process.runtime.name"] = ".NET",
                ["process.runtime.version"] = Environment.Version.ToString(),
                ["telemetry.directory"] = telemetryBaseDir
            });

        // Configure OpenTelemetry
        var otelBuilder = services.AddOpenTelemetry()
            .ConfigureResource(r => r.AddService(config.ServiceName, serviceVersion: config.ServiceVersion));

        if (config.EnableTracing && traceWriter != null)
        {
            otelBuilder.WithTracing(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddSource(DiagnosticsConfig.ServiceName)
                    .SetSampler(new AlwaysOnSampler())
                    .AddProcessor(new BatchActivityExportProcessor(
                        new JsonFileTraceExporter(traceWriter),
                        maxQueueSize: 2048,
                        scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                        exporterTimeoutMilliseconds: 30000,
                        maxExportBatchSize: 512));
            });
        }

        if (config.EnableMetrics && metricsWriter != null)
        {
            otelBuilder.WithMetrics(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddMeter(DiagnosticsConfig.ServiceName)
                    .AddRuntimeInstrumentation()
                    .AddReader(new PeriodicExportingMetricReader(
                        new JsonFileMetricsExporter(metricsWriter),
                        exportIntervalMilliseconds: config.MetricsExportIntervalSeconds * 1000));
            });
        }

        return services;
    }

    public static ILoggingBuilder AddTelemetryLogging(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);

        if (!config.EnableLogging)
            return builder;

        // Resolve telemetry directory
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        if (telemetryBaseDir == null)
            return builder; // No writable location - skip telemetry logging

        var logsDir = Path.Combine(telemetryBaseDir, "logs");
        if (!TryCreateDirectory(logsDir))
            return builder;

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);
        
        JsonTelemetryFileWriter? logsWriter = null;
        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch
        {
            return builder; // Failed to create writer - skip telemetry logging
        }

        builder.AddOpenTelemetry(options =>
        {
            options.IncludeFormattedMessage = true;
            options.IncludeScopes = true;
            options.ParseStateValues = true;
            options.AddProcessor(new BatchLogRecordExportProcessor(
                new JsonFileLogExporter(logsWriter),
                maxQueueSize: 2048,
                scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                exporterTimeoutMilliseconds: 30000,
                maxExportBatchSize: 512));
        });

        return builder;
    }

    private static bool TryCreateDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

/// <summary>
/// Interface for accessing telemetry file writers.
/// </summary>
public interface ITelemetryWriterProvider
{
    JsonTelemetryFileWriter? TraceWriter { get; }
    JsonTelemetryFileWriter? MetricsWriter { get; }
    JsonTelemetryFileWriter? LogsWriter { get; }
}

/// <summary>
/// Provides access to telemetry file writers.
/// </summary>
public sealed class TelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter { get; }
    public JsonTelemetryFileWriter? MetricsWriter { get; }
    public JsonTelemetryFileWriter? LogsWriter { get; }

    public TelemetryWriterProvider(
        JsonTelemetryFileWriter? traceWriter,
        JsonTelemetryFileWriter? metricsWriter,
        JsonTelemetryFileWriter? logsWriter)
    {
        TraceWriter = traceWriter;
        MetricsWriter = metricsWriter;
        LogsWriter = logsWriter;
    }
}

/// <summary>
/// Null implementation when telemetry is disabled.
/// </summary>
public sealed class NullTelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => null;
    public JsonTelemetryFileWriter? MetricsWriter => null;
    public JsonTelemetryFileWriter? LogsWriter => null;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\qodana.yaml
SIZE: 0.99 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify IDE code to run analysis without container (Applied in CI/CD pipeline)
ide: QDNET

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)



===============================================================================
EXPORT COMPLETED: 12/18/2025 17:41:55
Total Files Exported: 33
Output File: .\docs\llm\dump.txt
===============================================================================
