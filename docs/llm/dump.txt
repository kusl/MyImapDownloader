
===============================================================================
PROJECT EXPORT
Generated: 12/18/2025 13:52:17
Project Path: C:\Users\kushal\source\repos\MyImapDownloader
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\MYIMAPDOWNLOADER
|   .gitignore
|   Directory.Build.props
|   Directory.Build.targets
|   Directory.Packages.props
|   export.ps1
|   MyImapDownloader.sln
|   qodana.yaml
|   README.md
|   
+---docs
|   \---llm
|           .gitkeep
|           claude.md
|           dump.txt
|           output.txt
|           
\---MyImapDownloader
    |   DownloadOptions.cs
    |   EmailDownloadException.cs
    |   EmailDownloadService.cs
    |   EmailStorageService.cs
    |   ImapConfiguration.cs
    |   MyImapDownloader.csproj
    |   Program.cs
    |   
    +---bin
    |   \---Debug
    |       +---net10.0
    |       |   |   BouncyCastle.Cryptography.dll
    |       |   |   CommandLine.dll
    |       |   |   MailKit.dll
    |       |   |   Microsoft.Extensions.Configuration.Abstractions.dll
    |       |   |   Microsoft.Extensions.Configuration.Binder.dll
    |       |   |   Microsoft.Extensions.Configuration.CommandLine.dll
    |       |   |   Microsoft.Extensions.Configuration.dll
    |       |   |   Microsoft.Extensions.Configuration.EnvironmentVariables.dll
    |       |   |   Microsoft.Extensions.Configuration.FileExtensions.dll
    |       |   |   Microsoft.Extensions.Configuration.Json.dll
    |       |   |   Microsoft.Extensions.Configuration.UserSecrets.dll
    |       |   |   Microsoft.Extensions.DependencyInjection.Abstractions.dll
    |       |   |   Microsoft.Extensions.DependencyInjection.dll
    |       |   |   Microsoft.Extensions.Diagnostics.Abstractions.dll
    |       |   |   Microsoft.Extensions.Diagnostics.dll
    |       |   |   Microsoft.Extensions.FileProviders.Abstractions.dll
    |       |   |   Microsoft.Extensions.FileProviders.Physical.dll
    |       |   |   Microsoft.Extensions.FileSystemGlobbing.dll
    |       |   |   Microsoft.Extensions.Hosting.Abstractions.dll
    |       |   |   Microsoft.Extensions.Hosting.dll
    |       |   |   Microsoft.Extensions.Logging.Abstractions.dll
    |       |   |   Microsoft.Extensions.Logging.Configuration.dll
    |       |   |   Microsoft.Extensions.Logging.Console.dll
    |       |   |   Microsoft.Extensions.Logging.Debug.dll
    |       |   |   Microsoft.Extensions.Logging.dll
    |       |   |   Microsoft.Extensions.Logging.EventLog.dll
    |       |   |   Microsoft.Extensions.Logging.EventSource.dll
    |       |   |   Microsoft.Extensions.Options.ConfigurationExtensions.dll
    |       |   |   Microsoft.Extensions.Options.dll
    |       |   |   Microsoft.Extensions.Primitives.dll
    |       |   |   MimeKit.dll
    |       |   |   MyImapDownloader.deps.json
    |       |   |   MyImapDownloader.dll
    |       |   |   MyImapDownloader.exe
    |       |   |   MyImapDownloader.pdb
    |       |   |   MyImapDownloader.runtimeconfig.json
    |       |   |   Polly.Core.dll
    |       |   |   Polly.dll
    |       |   |   System.Diagnostics.EventLog.dll
    |       |   |   System.Security.Cryptography.Pkcs.dll
    |       |   |   
    |       |   \---runtimes
    |       |       \---win
    |       |           \---lib
    |       |               +---net10.0
    |       |               |       System.Diagnostics.EventLog.dll
    |       |               |       System.Diagnostics.EventLog.Messages.dll
    |       |               |       
    |       |               \---net8.0
    |       |                       System.Security.Cryptography.Pkcs.dll
    |       |                       
    |       \---net9.0
    |           |   BouncyCastle.Cryptography.dll
    |           |   CommandLine.dll
    |           |   MailKit.dll
    |           |   Microsoft.Extensions.Configuration.Abstractions.dll
    |           |   Microsoft.Extensions.Configuration.Binder.dll
    |           |   Microsoft.Extensions.Configuration.CommandLine.dll
    |           |   Microsoft.Extensions.Configuration.dll
    |           |   Microsoft.Extensions.Configuration.EnvironmentVariables.dll
    |           |   Microsoft.Extensions.Configuration.FileExtensions.dll
    |           |   Microsoft.Extensions.Configuration.Json.dll
    |           |   Microsoft.Extensions.Configuration.UserSecrets.dll
    |           |   Microsoft.Extensions.DependencyInjection.Abstractions.dll
    |           |   Microsoft.Extensions.DependencyInjection.dll
    |           |   Microsoft.Extensions.Diagnostics.Abstractions.dll
    |           |   Microsoft.Extensions.Diagnostics.dll
    |           |   Microsoft.Extensions.FileProviders.Abstractions.dll
    |           |   Microsoft.Extensions.FileProviders.Physical.dll
    |           |   Microsoft.Extensions.FileSystemGlobbing.dll
    |           |   Microsoft.Extensions.Hosting.Abstractions.dll
    |           |   Microsoft.Extensions.Hosting.dll
    |           |   Microsoft.Extensions.Logging.Abstractions.dll
    |           |   Microsoft.Extensions.Logging.Configuration.dll
    |           |   Microsoft.Extensions.Logging.Console.dll
    |           |   Microsoft.Extensions.Logging.Debug.dll
    |           |   Microsoft.Extensions.Logging.dll
    |           |   Microsoft.Extensions.Logging.EventLog.dll
    |           |   Microsoft.Extensions.Logging.EventSource.dll
    |           |   Microsoft.Extensions.Options.ConfigurationExtensions.dll
    |           |   Microsoft.Extensions.Options.dll
    |           |   Microsoft.Extensions.Primitives.dll
    |           |   MimeKit.dll
    |           |   MyImapDownloader.deps.json
    |           |   MyImapDownloader.dll
    |           |   MyImapDownloader.exe
    |           |   MyImapDownloader.pdb
    |           |   MyImapDownloader.runtimeconfig.json
    |           |   Polly.Core.dll
    |           |   Polly.dll
    |           |   System.Diagnostics.EventLog.dll
    |           |   System.Security.Cryptography.Pkcs.dll
    |           |   
    |           \---runtimes
    |               \---win
    |                   \---lib
    |                       +---net8.0
    |                       |       System.Security.Cryptography.Pkcs.dll
    |                       |       
    |                       \---net9.0
    |                               System.Diagnostics.EventLog.dll
    |                               System.Diagnostics.EventLog.Messages.dll
    |                               
    \---obj
        |   MyImapDownloader.csproj.nuget.dgspec.json
        |   MyImapDownloader.csproj.nuget.g.props
        |   MyImapDownloader.csproj.nuget.g.targets
        |   project.assets.json
        |   project.nuget.cache
        |   
        \---Debug
            +---net10.0
            |   |   .NETCoreApp,Version=v10.0.AssemblyAttributes.cs
            |   |   apphost.exe
            |   |   MyImapDo.0CA68583.Up2Date
            |   |   MyImapDownloader.AssemblyInfo.cs
            |   |   MyImapDownloader.AssemblyInfoInputs.cache
            |   |   MyImapDownloader.assets.cache
            |   |   MyImapDownloader.csproj.AssemblyReference.cache
            |   |   MyImapDownloader.csproj.CoreCompileInputs.cache
            |   |   MyImapDownloader.csproj.FileListAbsolute.txt
            |   |   MyImapDownloader.dll
            |   |   MyImapDownloader.GeneratedMSBuildEditorConfig.editorconfig
            |   |   MyImapDownloader.genruntimeconfig.cache
            |   |   MyImapDownloader.GlobalUsings.g.cs
            |   |   MyImapDownloader.pdb
            |   |   MyImapDownloader.sourcelink.json
            |   |   
            |   +---ref
            |   |       MyImapDownloader.dll
            |   |       
            |   \---refint
            |           MyImapDownloader.dll
            |           
            \---net9.0
                |   .NETCoreApp,Version=v9.0.AssemblyAttributes.cs
                |   apphost.exe
                |   MyImapDo.0CA68583.Up2Date
                |   MyImapDownloader.AssemblyInfo.cs
                |   MyImapDownloader.AssemblyInfoInputs.cache
                |   MyImapDownloader.assets.cache
                |   MyImapDownloader.csproj.AssemblyReference.cache
                |   MyImapDownloader.csproj.CoreCompileInputs.cache
                |   MyImapDownloader.csproj.FileListAbsolute.txt
                |   MyImapDownloader.dll
                |   MyImapDownloader.GeneratedMSBuildEditorConfig.editorconfig
                |   MyImapDownloader.genruntimeconfig.cache
                |   MyImapDownloader.GlobalUsings.g.cs
                |   MyImapDownloader.pdb
                |   MyImapDownloader.sourcelink.json
                |   
                +---ref
                |       MyImapDownloader.dll
                |       
                \---refint
                        MyImapDownloader.dll
                        


FILE CONTENTS:
==============

================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\Directory.Build.props
SIZE: 0.51 KB
MODIFIED: 12/18/2025 13:51:47
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\Directory.Packages.props
SIZE: 0.98 KB
MODIFIED: 12/18/2025 13:30:35
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  <ItemGroup>
    <PackageVersion Include="CommandLineParser" Version="2.9.1" />
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="MailKit" Version="4.14.1" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.UserSecrets" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Console" Version="10.0.1" />
    <PackageVersion Include="Polly" Version="8.6.5" />
  </ItemGroup>
</Project>


================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.sln
SIZE: 1 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================


Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyImapDownloader", "MyImapDownloader\MyImapDownloader.csproj", "{8E3B6382-B4FA-491C-8889-8964BC556B71}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\DownloadOptions.cs
SIZE: 1.28 KB
MODIFIED: 12/18/2025 13:48:35
================================================================================

using CommandLine;

namespace MyImapDownloader;

public class DownloadOptions
{
    [Option('s', "server", Required = true, HelpText = "IMAP server address")]
    public required string Server { get; set; }

    [Option('u', "username", Required = true, HelpText = "Email username")]
    public required string Username { get; set; }

    [Option('p', "password", Required = true, HelpText = "Email password")]
    public required string Password { get; set; }

    [Option('r', "port", Default = 993, HelpText = "IMAP port (default: 993)")]
    public int Port { get; set; } = 993;

    [Option('o', "output", Default = "EmailArchive", HelpText = "Output directory for archived emails")]
    public required string OutputDirectory { get; set; }

    [Option("start-date", HelpText = "Download emails from this date (yyyy-MM-dd)")]
    public DateTime? StartDate { get; set; }

    [Option("end-date", HelpText = "Download emails until this date (yyyy-MM-dd)")]
    public DateTime? EndDate { get; set; }

    [Option('a', "all-folders", Default = false, HelpText = "Download from all folders, not just INBOX")]
    public bool AllFolders { get; set; }

    [Option('v', "verbose", Default = false, HelpText = "Enable verbose logging")]
    public bool Verbose { get; set; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailDownloadException.cs
SIZE: 0.25 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

namespace MyImapDownloader;

// Custom Exceptions
public class EmailDownloadException(string message, int messageIndex, Exception innerException)
    : Exception(message, innerException)
{
    public int MessageIndex { get; } = messageIndex;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailDownloadService.cs
SIZE: 8.52 KB
MODIFIED: 12/18/2025 13:48:48
================================================================================

using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MailKit.Security;
using Microsoft.Extensions.Logging;
using MimeKit;
using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;

namespace MyImapDownloader;

public class EmailDownloadService
{
    private readonly ILogger<EmailDownloadService> _logger;
    private readonly ImapConfiguration _config;
    private readonly EmailStorageService _storage;
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    public EmailDownloadService(
        ILogger<EmailDownloadService> logger, 
        ImapConfiguration config,
        EmailStorageService storage)
    {
        _logger = logger;
        _config = config;
        _storage = storage;
        
        _retryPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .WaitAndRetryAsync(
                3,
                retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                (exception, timeSpan, retryCount, _) =>
                {
                    _logger.LogWarning(exception,
                        "Retry {RetryCount} with delay {Delay}",
                        retryCount, timeSpan);
                });

        _circuitBreakerPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .CircuitBreakerAsync(
                exceptionsAllowedBeforeBreaking: 5,
                durationOfBreak: TimeSpan.FromMinutes(2));
    }

    public async Task DownloadEmailsAsync(
        DownloadOptions options,
        CancellationToken cancellationToken = default)
    {
        var policy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);
        var stats = new DownloadStats();

        try
        {
            await policy.ExecuteAsync(async () =>
            {
                using var client = new ImapClient { Timeout = 180_000 };

                try
                {
                    await ConnectAndAuthenticateAsync(client, cancellationToken);
                    
                    // Download all folders, or just INBOX
                    var folders = options.AllFolders 
                        ? await GetAllFoldersAsync(client, cancellationToken)
                        : [client.Inbox];

                    foreach (var folder in folders)
                    {
                        await DownloadFolderAsync(
                            folder, options, stats, cancellationToken);
                    }
                }
                finally
                {
                    await DisconnectSafelyAsync(client);
                    await _storage.SaveIndexAsync(cancellationToken);
                }
            });
        }
        catch (AuthenticationException)
        {
            _logger.LogCritical("Aborting: Authentication failed");
            throw;
        }
        finally
        {
            _logger.LogInformation(
                "Download complete. New: {New}, Skipped: {Skipped}, Errors: {Errors}",
                stats.NewEmails, stats.SkippedDuplicates, stats.Errors);
        }
    }

    private async Task<IEnumerable<IMailFolder>> GetAllFoldersAsync(
        ImapClient client, CancellationToken ct)
    {
        var folders = new List<IMailFolder>();
        var personal = client.GetFolder(client.PersonalNamespaces[0]);
        
        await CollectFoldersRecursiveAsync(personal, folders, ct);
        
        // Always include INBOX
        if (!folders.Contains(client.Inbox))
            folders.Insert(0, client.Inbox);
            
        return folders;
    }

    private async Task CollectFoldersRecursiveAsync(
        IMailFolder parent, List<IMailFolder> folders, CancellationToken ct)
    {
        foreach (var folder in await parent.GetSubfoldersAsync(false, ct))
        {
            folders.Add(folder);
            await CollectFoldersRecursiveAsync(folder, folders, ct);
        }
    }

    private async Task DownloadFolderAsync(
        IMailFolder folder,
        DownloadOptions options,
        DownloadStats stats,
        CancellationToken ct)
    {
        try
        {
            await folder.OpenAsync(FolderAccess.ReadOnly, ct);
            _logger.LogInformation("Processing folder: {Folder} ({Count} messages)",
                folder.FullName, folder.Count);

            if (folder.Count == 0)
                return;

            // Build search query for date filtering
            var query = BuildSearchQuery(options.StartDate, options.EndDate);
            var uids = query != null
                ? await folder.SearchAsync(query, ct)
                : await folder.SearchAsync(SearchQuery.All, ct);

            _logger.LogInformation("Found {Count} messages matching criteria", uids.Count);

            const int batchSize = 50;
            for (int i = 0; i < uids.Count; i += batchSize)
            {
                if (ct.IsCancellationRequested)
                    break;

                var batch = uids.Skip(i).Take(batchSize).ToList();
                await DownloadBatchAsync(folder, batch, stats, ct);
                
                // Progress update
                _logger.LogInformation("Progress: {Current}/{Total} ({Percent:F1}%)",
                    Math.Min(i + batchSize, uids.Count), uids.Count,
                    (double)Math.Min(i + batchSize, uids.Count) / uids.Count * 100);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing folder: {Folder}", folder.FullName);
        }
    }

    private async Task DownloadBatchAsync(
        IMailFolder folder,
        IList<UniqueId> uids,
        DownloadStats stats,
        CancellationToken ct)
    {
        foreach (var uid in uids)
        {
            if (ct.IsCancellationRequested)
                break;

            try
            {
                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2));
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                    timeoutCts.Token, ct);

                var message = await folder.GetMessageAsync(uid, linkedCts.Token);
                bool isNew = await _storage.StoreEmailAsync(
                    message, folder.FullName, linkedCts.Token);

                if (isNew)
                    stats.NewEmails++;
                else
                    stats.SkippedDuplicates++;
            }
            catch (OperationCanceledException)
            {
                _logger.LogWarning("Timeout downloading message {Uid} in {Folder}",
                    uid, folder.FullName);
                stats.Errors++;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error downloading {Uid} in {Folder}",
                    uid, folder.FullName);
                stats.Errors++;
            }
        }
    }

    private static SearchQuery? BuildSearchQuery(DateTime? startDate, DateTime? endDate)
    {
        SearchQuery? query = null;

        if (startDate.HasValue)
            query = SearchQuery.DeliveredAfter(startDate.Value);

        if (endDate.HasValue)
        {
            var endQuery = SearchQuery.DeliveredBefore(endDate.Value.AddDays(1));
            query = query != null ? query.And(endQuery) : endQuery;
        }

        return query;
    }

    private async Task ConnectAndAuthenticateAsync(ImapClient client, CancellationToken ct)
    {
        _logger.LogInformation("Connecting to {Server}:{Port}", _config.Server, _config.Port);
        
        await client.ConnectAsync(
            _config.Server,
            _config.Port,
            SecureSocketOptions.SslOnConnect,
            ct);

        await client.AuthenticateAsync(_config.Username, _config.Password, ct);
        _logger.LogInformation("Connected successfully");
    }

    private async Task DisconnectSafelyAsync(ImapClient client)
    {
        try
        {
            if (client.IsConnected)
            {
                await client.DisconnectAsync(true);
                _logger.LogDebug("Disconnected from server");
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error during disconnect");
        }
    }

    private class DownloadStats
    {
        public int NewEmails;
        public int SkippedDuplicates;
        public int Errors;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailStorageService.cs
SIZE: 8.93 KB
MODIFIED: 12/18/2025 13:50:07
================================================================================

using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using MimeKit;

namespace MyImapDownloader;

/// <summary>
/// Stores emails in a Maildir-inspired structure with deduplication and metadata tracking.
/// </summary>
public class EmailStorageService
{
    private readonly ILogger<EmailStorageService> _logger;
    private readonly string _baseDirectory;
    private readonly HashSet<string> _knownMessageIds;
    private readonly string _indexPath;

    public EmailStorageService(ILogger<EmailStorageService> logger, string baseDirectory)
    {
        _logger = logger;
        _baseDirectory = baseDirectory;
        _indexPath = Path.Combine(baseDirectory, ".email-index.json");
        _knownMessageIds = LoadIndex();
    }

    /// <summary>
    /// Stores an email message, returning true if it was new, false if duplicate.
    /// </summary>
    public async Task<bool> StoreEmailAsync(
        MimeMessage message,
        string folderName,
        CancellationToken ct = default)
    {
        string messageId = GetMessageIdentifier(message);
        
        if (_knownMessageIds.Contains(messageId))
        {
            _logger.LogDebug("Skipping duplicate: {MessageId}", messageId);
            return false;
        }

        string folderPath = GetFolderPath(folderName);
        EnsureMaildirStructure(folderPath);

        string filename = GenerateFilename(message, messageId);
        string tempPath = Path.Combine(folderPath, "tmp", filename);
        string finalPath = Path.Combine(folderPath, "cur", filename);

        try
        {
            // Write to tmp first (atomic write pattern)
            await using (var stream = File.Create(tempPath))
            {
                await message.WriteToAsync(stream, ct);
            }

            // Move to cur (atomic on most filesystems)
            File.Move(tempPath, finalPath, overwrite: false);

            // Write sidecar metadata
            await WriteMetadataAsync(finalPath, message, folderName, ct);

            _knownMessageIds.Add(messageId);
            _logger.LogInformation("Stored: {Subject} -> {Path}", 
                Truncate(message.Subject, 50), finalPath);
            
            return true;
        }
        catch (IOException ex) when (File.Exists(finalPath))
        {
            // Race condition - file already exists, treat as duplicate
            _logger.LogDebug("File already exists (race): {Path}", finalPath);
            TryDelete(tempPath);
            return false;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to store email: {MessageId}", messageId);
            TryDelete(tempPath);
            throw;
        }
    }

    /// <summary>
    /// Gets a unique identifier for the message, preferring Message-ID header.
    /// </summary>
    private static string GetMessageIdentifier(MimeMessage message)
    {
        // Prefer the standard Message-ID header
        if (!string.IsNullOrWhiteSpace(message.MessageId))
        {
            return NormalizeMessageId(message.MessageId);
        }

        // Fallback: hash of date + from + subject (for malformed emails)
        var sb = new StringBuilder();
        sb.Append(message.Date.ToUniversalTime().ToString("O"));
        sb.Append('|');
        sb.Append(message.From?.ToString() ?? "");
        sb.Append('|');
        sb.Append(message.Subject ?? "");
        
        return ComputeHash(sb.ToString());
    }

    private static string NormalizeMessageId(string messageId)
    {
        // Remove angle brackets and normalize
        return messageId.Trim().Trim('<', '>').ToLowerInvariant();
    }

    private static string ComputeHash(string input)
    {
        byte[] bytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));
        return Convert.ToHexString(bytes)[..16].ToLowerInvariant();
    }

    /// <summary>
    /// Generates a Maildir-style filename: timestamp.uniqueid.hostname:2,flags
    /// </summary>
    private static string GenerateFilename(MimeMessage message, string messageId)
    {
        long timestamp = message.Date.ToUnixTimeSeconds();
        string safeId = SanitizeForFilename(messageId, 40);
        string hostname = SanitizeForFilename(Environment.MachineName, 20);
        
        // Maildir format: time.uniqueid.host:2,flags
        // We use 'S' flag (seen) since we're archiving
        return $"{timestamp}.{safeId}.{hostname}:2,S.eml";
    }

    private static string SanitizeForFilename(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input))
            return "unknown";

        var sb = new StringBuilder(Math.Min(input.Length, maxLength));
        foreach (char c in input)
        {
            if (char.IsLetterOrDigit(c) || c == '-' || c == '_' || c == '.')
                sb.Append(c);
            else if (sb.Length > 0 && sb[^1] != '_')
                sb.Append('_');
            
            if (sb.Length >= maxLength)
                break;
        }
        
        return sb.ToString().Trim('_');
    }

    private string GetFolderPath(string folderName)
    {
        string safeName = SanitizeForFilename(folderName, 100);
        return Path.Combine(_baseDirectory, safeName);
    }

    private static void EnsureMaildirStructure(string folderPath)
    {
        Directory.CreateDirectory(Path.Combine(folderPath, "cur"));
        Directory.CreateDirectory(Path.Combine(folderPath, "new"));
        Directory.CreateDirectory(Path.Combine(folderPath, "tmp"));
    }

    private static async Task WriteMetadataAsync(
        string emlPath, 
        MimeMessage message, 
        string folderName,
        CancellationToken ct)
    {
        var metadata = new EmailMetadata
        {
            MessageId = message.MessageId,
            Subject = message.Subject,
            From = message.From?.ToString(),
            To = message.To?.ToString(),
            Date = message.Date.UtcDateTime,
            Folder = folderName,
            ArchivedAt = DateTime.UtcNow,
            HasAttachments = message.Attachments.Any(),
            AttachmentCount = message.Attachments.Count()
        };

        string metaPath = emlPath + ".meta.json";
        await using var stream = File.Create(metaPath);
        await JsonSerializer.SerializeAsync(stream, metadata, 
            new JsonSerializerOptions { WriteIndented = true }, ct);
    }

    private HashSet<string> LoadIndex()
    {
        try
        {
            if (File.Exists(_indexPath))
            {
                string json = File.ReadAllText(_indexPath);
                var ids = JsonSerializer.Deserialize<List<string>>(json);
                return ids != null ? new HashSet<string>(ids) : [];
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Could not load index, will rebuild from files");
        }
        
        return RebuildIndexFromFiles();
    }

    private HashSet<string> RebuildIndexFromFiles()
    {
        var ids = new HashSet<string>();
        
        if (!Directory.Exists(_baseDirectory))
            return ids;

        foreach (var metaFile in Directory.EnumerateFiles(
            _baseDirectory, "*.meta.json", SearchOption.AllDirectories))
        {
            try
            {
                string json = File.ReadAllText(metaFile);
                var meta = JsonSerializer.Deserialize<EmailMetadata>(json);
                if (!string.IsNullOrEmpty(meta?.MessageId))
                    ids.Add(NormalizeMessageId(meta.MessageId));
            }
            catch { /* Skip malformed metadata */ }
        }
        
        _logger.LogInformation("Rebuilt index with {Count} known emails", ids.Count);
        return ids;
    }

    public async Task SaveIndexAsync(CancellationToken ct = default)
    {
        Directory.CreateDirectory(_baseDirectory);
        await using var stream = File.Create(_indexPath);
        await JsonSerializer.SerializeAsync(stream, _knownMessageIds.ToList(), 
            cancellationToken: ct);
    }

    private static void TryDelete(string path)
    {
        try { File.Delete(path); } catch { /* Ignore cleanup failures */ }
    }

    private static string Truncate(string? input, int maxLength)
    {
        if (string.IsNullOrEmpty(input)) return "(no subject)";
        return input.Length <= maxLength ? input : input[..(maxLength - 3)] + "...";
    }
}

public record EmailMetadata
{
    public string? MessageId { get; init; }
    public string? Subject { get; init; }
    public string? From { get; init; }
    public string? To { get; init; }
    public DateTime Date { get; init; }
    public string? Folder { get; init; }
    public DateTime ArchivedAt { get; init; }
    public bool HasAttachments { get; init; }
    public int AttachmentCount { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\ImapConfiguration.cs
SIZE: 0.32 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

namespace MyImapDownloader;

// Configuration Model
public class ImapConfiguration
{
    public required string Server { get; set; }
    public int Port { get; set; }
    public required string Username { get; set; }
    public required string Password { get; set; }
    public bool UseSsl { get; set; } = true;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\MyImapDownloader.csproj
SIZE: 0.75 KB
MODIFIED: 12/18/2025 13:29:24
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CommandLineParser" />
    <PackageReference Include="MailKit" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
    <PackageReference Include="Polly" />
  </ItemGroup>
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Program.cs
SIZE: 1.93 KB
MODIFIED: 12/18/2025 13:46:46
================================================================================

using CommandLine;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyImapDownloader;

var parseResult = Parser.Default.ParseArguments<DownloadOptions>(args);

await parseResult.WithParsedAsync(async options =>
{
    var host = Host.CreateDefaultBuilder(args)
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.SetMinimumLevel(options.Verbose ? LogLevel.Debug : LogLevel.Information);
        })
        .ConfigureServices(services =>
        {
            services.AddSingleton(options);
            services.AddSingleton(new ImapConfiguration
            {
                Server = options.Server,
                Username = options.Username,
                Password = options.Password,
                Port = options.Port
            });
            services.AddSingleton(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<EmailStorageService>>();
                return new EmailStorageService(logger, options.OutputDirectory);
            });
            services.AddTransient<EmailDownloadService>();
        })
        .Build();

    var downloadService = host.Services.GetRequiredService<EmailDownloadService>();
    var logger = host.Services.GetRequiredService<ILogger<Program>>();

    try
    {
        logger.LogInformation("Starting email archive download...");
        logger.LogInformation("Output: {Output}", Path.GetFullPath(options.OutputDirectory));
        
        await downloadService.DownloadEmailsAsync(options);
        
        logger.LogInformation("Archive complete!");
    }
    catch (Exception ex)
    {
        logger.LogCritical(ex, "Fatal error during download");
        Environment.ExitCode = 1;
    }
});

parseResult.WithNotParsed(errors =>
{
    Environment.ExitCode = 1;
});



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\qodana.yaml
SIZE: 0.99 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify IDE code to run analysis without container (Applied in CI/CD pipeline)
ide: QDNET

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)



===============================================================================
EXPORT COMPLETED: 12/18/2025 13:52:17
Total Files Exported: 11
Output File: .\docs\llm\dump.txt
===============================================================================
