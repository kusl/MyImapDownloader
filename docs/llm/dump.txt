===============================================================================
PROJECT EXPORT
Generated: Thu Jan  1 09:57:54 AM CST 2026
Project Path: /home/kushal/src/dotnet/MyImapDownloader
===============================================================================

DIRECTORY STRUCTURE:
===================

/home/kushal/src/dotnet/MyImapDownloader
├── Directory.Build.props
├── Directory.Build.targets
├── Directory.Packages.props
├── Directory.Packages.props.bak
├── export.ps1
├── export.sh
├── fix-all-errors.sh
├── fix-build-errors.sh
├── fix-global-option.sh
├── fix_myemailsearch_commands.sh
├── fix-myemailsearch.sh
├── generate_myemailsearch.sh
├── .github
│   └── workflows
│       └── ci.yml
├── .gitignore
├── global.json
├── LICENSE
├── MyEmailSearch
│   ├── appsettings.json
│   ├── .backup
│   │   ├── IndexCommand.cs
│   │   ├── Program.cs
│   │   ├── Program.cs.20260101_091808
│   │   ├── RebuildCommand.cs
│   │   ├── SearchCommand.cs
│   │   └── StatusCommand.cs
│   ├── Commands
│   │   ├── IndexCommand.cs
│   │   ├── RebuildCommand.cs
│   │   ├── SearchCommand.cs
│   │   └── StatusCommand.cs
│   ├── Configuration
│   │   └── PathResolver.cs
│   ├── Data
│   │   ├── EmailDocument.cs
│   │   ├── IndexStatistics.cs
│   │   ├── Migrations
│   │   ├── Repositories
│   │   ├── SearchDatabase.cs
│   │   ├── SearchQuery.cs
│   │   └── SearchResult.cs
│   ├── Indexing
│   │   ├── ArchiveScanner.cs
│   │   ├── EmailParser.cs
│   │   └── IndexManager.cs
│   ├── Infrastructure
│   ├── MyEmailSearch.csproj
│   ├── Program.cs
│   ├── Search
│   │   ├── QueryParser.cs
│   │   ├── SearchEngine.cs
│   │   └── SnippetGenerator.cs
│   └── Telemetry
├── MyEmailSearch.Tests
│   ├── Data
│   │   ├── Fts5HelperTests.cs
│   │   ├── SearchDatabaseEscapingTests.cs
│   │   └── SearchDatabaseTests.cs
│   ├── Indexing
│   ├── Integration
│   ├── MyEmailSearch.Tests.csproj
│   ├── Search
│   │   ├── QueryParserTests.cs
│   │   └── SnippetGeneratorTests.cs
│   ├── SmokeTests.cs
│   ├── Telemetry
│   └── TestFixtures
│       └── SampleEmails
│           ├── sample1.eml
│           └── sample2.eml
├── MyImapDownloader
│   ├── appsettings.json
│   ├── DownloadOptions.cs
│   ├── EmailDownloadException.cs
│   ├── EmailDownloadService.cs
│   ├── EmailMetadata.cs
│   ├── EmailStorageService.cs
│   ├── ImapConfiguration.cs
│   ├── MyImapDownloader.csproj
│   ├── Program.cs
│   └── Telemetry
│       ├── ActivityExtension.cs
│       ├── DiagnosticsConfig.cs
│       ├── JsonFileLogExporter.cs
│       ├── JsonFileMetricsExporter.cs
│       ├── JsonFileTraceExporter.cs
│       ├── JsonTelemetryFileWriter.cs
│       ├── TelemetryConfiguration.cs
│       ├── TelemetryDirectoryResolver.cs
│       └── TelemetryExtensions.cs
├── MyImapDownloader.slnx
├── MyImapDownloader.Tests
│   ├── DownloadOptionsTests.cs
│   ├── EmailDownloadExceptionTests.cs
│   ├── ImapConfigurationTests.cs
│   ├── MyImapDownloader.Tests.csproj
│   └── Telemetry
│       ├── ActivityExtensionsTests.cs
│       ├── DiagnosticsConfigTests.cs
│       ├── JsonExporterTests.cs
│       ├── JsonTelemetryFileWriterTests.cs
│       ├── TelemetryConfigurationTests.cs
│       ├── TelemetryDirectoryResolverTests.cs
│       ├── TelemetryExtensionsTests.cs
│       └── TelemetryWriterProviderTests.cs
├── qodana.yaml
├── README.md
└── setup-myemailsearch.sh


FILE CONTENTS:
==============

================================================================================
FILE: Directory.Build.props
SIZE: 0.79 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  <PropertyGroup>
    <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
    <TestingPlatformCaptureOutput>false</TestingPlatformCaptureOutput>
  </PropertyGroup>
  <PropertyGroup>
    <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
  </PropertyGroup>
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>

================================================================================
FILE: Directory.Packages.props
SIZE: 3.04 KB
MODIFIED: 2025-12-31 09:07:00
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- =========================================================================
         SHARED PACKAGES (used by multiple projects)
         ========================================================================= -->
    
    <!-- Microsoft.Extensions.* - Core infrastructure -->
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Json" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.UserSecrets" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Console" Version="10.0.1" />
    
    <!-- Database -->
    <PackageVersion Include="Microsoft.Data.Sqlite" Version="10.0.1" />
    
    <!-- OpenTelemetry -->
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    
    <!-- Resilience -->
    <PackageVersion Include="Polly" Version="8.6.5" />
    
    <!-- CLI -->
    <PackageVersion Include="CommandLineParser" Version="2.9.1" />
    <PackageVersion Include="System.CommandLine" Version="2.0.1" />
    
    <!-- =========================================================================
         MyImapDownloader SPECIFIC PACKAGES
         ========================================================================= -->
    <PackageVersion Include="MailKit" Version="4.14.1" />
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.0.1" />
    
    <!-- =========================================================================
         MyEmailSearch SPECIFIC PACKAGES
         ========================================================================= -->
    <PackageVersion Include="MimeKit" Version="4.14.0" />
    
    <!-- =========================================================================
         TEST PACKAGES (shared by all test projects)
         ========================================================================= -->
    <PackageVersion Include="TUnit" Version="1.7.7" />
    <PackageVersion Include="NSubstitute" Version="5.3.0" />
    <PackageVersion Include="AwesomeAssertions" Version="9.3.0" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
  </ItemGroup>
</Project>


================================================================================
FILE: .github/workflows/ci.yml
SIZE: 4.95 KB
MODIFIED: 2025-12-31 09:01:56
================================================================================

# =============================================================================
# CI/CD Pipeline for MyImapDownloader and MyEmailSearch
# =============================================================================
# This workflow:
#   - Builds and tests on every push/PR to any branch
#   - Runs on Windows, macOS, and Linux
#   - Publishes artifacts on pushes to main/master/develop
# =============================================================================

name: Build and Test

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  # ===========================================================================
  # Build and Test Job
  # ===========================================================================
  build-and-test:
    name: ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'ga'
      
      - name: Display .NET info
        run: dotnet --info
      
      # Build entire solution (all projects)
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build solution
        run: dotnet build --no-restore --configuration Release
      
      # Run all tests across all test projects
      - name: Run tests
        run: dotnet test --no-build --configuration Release --verbosity normal
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: '**/TestResults/**'
          retention-days: 7

  # ===========================================================================
  # Publish Job (only on main/master/develop branches)
  # ===========================================================================
  publish:
    name: Publish
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'ga'
      
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build Release
        run: dotnet build --configuration Release
      
      # Publish MyImapDownloader
      - name: Publish MyImapDownloader (Linux x64)
        run: |
          dotnet publish MyImapDownloader/MyImapDownloader.csproj \
            --configuration Release \
            --runtime linux-x64 \
            --self-contained false \
            --output ./publish/MyImapDownloader/linux-x64
      
      - name: Publish MyImapDownloader (Windows x64)
        run: |
          dotnet publish MyImapDownloader/MyImapDownloader.csproj \
            --configuration Release \
            --runtime win-x64 \
            --self-contained false \
            --output ./publish/MyImapDownloader/win-x64
      
      - name: Publish MyImapDownloader (macOS ARM64)
        run: |
          dotnet publish MyImapDownloader/MyImapDownloader.csproj \
            --configuration Release \
            --runtime osx-arm64 \
            --self-contained false \
            --output ./publish/MyImapDownloader/osx-arm64
      
      # Publish MyEmailSearch
      - name: Publish MyEmailSearch (Linux x64)
        run: |
          dotnet publish MyEmailSearch/MyEmailSearch.csproj \
            --configuration Release \
            --runtime linux-x64 \
            --self-contained false \
            --output ./publish/MyEmailSearch/linux-x64
      
      - name: Publish MyEmailSearch (Windows x64)
        run: |
          dotnet publish MyEmailSearch/MyEmailSearch.csproj \
            --configuration Release \
            --runtime win-x64 \
            --self-contained false \
            --output ./publish/MyEmailSearch/win-x64
      
      - name: Publish MyEmailSearch (macOS ARM64)
        run: |
          dotnet publish MyEmailSearch/MyEmailSearch.csproj \
            --configuration Release \
            --runtime osx-arm64 \
            --self-contained false \
            --output ./publish/MyEmailSearch/osx-arm64
      
      # Upload all artifacts
      - name: Upload MyImapDownloader artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MyImapDownloader
          path: ./publish/MyImapDownloader/
          retention-days: 30
      
      - name: Upload MyEmailSearch artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MyEmailSearch
          path: ./publish/MyEmailSearch/
          retention-days: 30


================================================================================
FILE: global.json
SIZE: 0.07 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

{
    "test": {
        "runner": "Microsoft.Testing.Platform"
    }
}


================================================================================
FILE: MyEmailSearch/appsettings.json
SIZE: 0.31 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  },
  "Search": {
    "DefaultResultLimit": 100,
    "MaxResultLimit": 1000,
    "SnippetLength": 200
  },
  "Indexing": {
    "BatchSize": 100,
    "IncludeContentByDefault": false
  }
}


================================================================================
FILE: MyEmailSearch/.backup/IndexCommand.cs
SIZE: 3.59 KB
MODIFIED: 2025-12-31 17:35:01
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'index' command for building/updating the search index.
/// </summary>
public static class IndexCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var fullOption = new Option<bool>("--full")
        {
            Description = "Perform full reindex instead of incremental update"
        };

        var contentOption = new Option<bool>("--content")
        {
            Description = "Also index email body content (slower but enables full-text search)"
        };

        var command = new Command("index", "Build or update the search index");
        command.Options.Add(fullOption);
        command.Options.Add(contentOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var full = parseResult.GetValue(fullOption);
            var content = parseResult.GetValue(contentOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(full, content, archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        bool full,
        bool content,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        Console.WriteLine($"Archive path: {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine($"Mode: {(full ? "Full rebuild" : "Incremental")}");
        Console.WriteLine($"Index content: {content}");
        Console.WriteLine();

        if (!Directory.Exists(archivePath))
        {
            Console.WriteLine($"Error: Archive path does not exist: {archivePath}");
            return;
        }

        // Ensure database directory exists
        var dbDir = Path.GetDirectoryName(databasePath);
        if (!string.IsNullOrEmpty(dbDir) && !Directory.Exists(dbDir))
        {
            Directory.CreateDirectory(dbDir);
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var indexManager = sp.GetRequiredService<IndexManager>();

        // Initialize database
        await database.InitializeAsync(ct);

        // Create progress reporter
        var progress = new Progress<IndexingProgress>(p =>
        {
            Console.Write($"\rProcessing: {p.Processed}/{p.Total} ({p.Percentage:F1}%)");
        });

        // Run indexing
        IndexingResult result;
        if (full)
        {
            result = await indexManager.RebuildIndexAsync(archivePath, content, progress, ct);
        }
        else
        {
            result = await indexManager.IndexAsync(archivePath, content, progress, ct);
        }

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine("Indexing complete:");
        Console.WriteLine($"  Indexed: {result.Indexed}");
        Console.WriteLine($"  Skipped: {result.Skipped}");
        Console.WriteLine($"  Errors:  {result.Errors}");
        Console.WriteLine($"  Time:    {result.Duration}");
    }
}


================================================================================
FILE: MyEmailSearch/.backup/Program.cs
SIZE: 3.25 KB
MODIFIED: 2025-12-31 17:35:01
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using MyEmailSearch.Commands;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;
using MyEmailSearch.Search;

namespace MyEmailSearch;

public static class Program
{
    public static async Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("MyEmailSearch - Search your email archive")
        {
            Name = "myemailsearch"
        };

        // Global options
        var archiveOption = new Option<string?>(["--archive", "-a"])
        {
            Description = "Path to the email archive directory"
        };

        var databaseOption = new Option<string?>(["--database", "-d"])
        {
            Description = "Path to the search database file"
        };

        var verboseOption = new Option<bool>(["--verbose", "-v"])
        {
            Description = "Enable verbose output"
        };

        rootCommand.Options.Add(archiveOption);
        rootCommand.Options.Add(databaseOption);
        rootCommand.Options.Add(verboseOption);

        // Add subcommands
        rootCommand.Subcommands.Add(SearchCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(IndexCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(StatusCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(RebuildCommand.Create(archiveOption, databaseOption, verboseOption));

        return await rootCommand.Parse(args).InvokeAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Creates a service provider with all required dependencies.
    /// </summary>
    public static ServiceProvider CreateServiceProvider(
        string archivePath,
        string databasePath,
        bool verbose)
    {
        var services = new ServiceCollection();

        // Logging
        services.AddLogging(builder =>
        {
            builder.AddConsole();
            builder.SetMinimumLevel(verbose ? LogLevel.Debug : LogLevel.Information);
        });

        // Database
        services.AddSingleton(sp =>
            new SearchDatabase(databasePath, sp.GetRequiredService<ILogger<SearchDatabase>>()));

        // Search components
        services.AddSingleton<QueryParser>();
        services.AddSingleton<SnippetGenerator>();
        services.AddSingleton(sp => new SearchEngine(
            sp.GetRequiredService<SearchDatabase>(),
            sp.GetRequiredService<QueryParser>(),
            sp.GetRequiredService<SnippetGenerator>(),
            sp.GetRequiredService<ILogger<SearchEngine>>()));

        // Indexing components
        services.AddSingleton(sp =>
            new ArchiveScanner(sp.GetRequiredService<ILogger<ArchiveScanner>>()));
        services.AddSingleton(sp =>
            new EmailParser(archivePath, sp.GetRequiredService<ILogger<EmailParser>>()));
        services.AddSingleton(sp => new IndexManager(
            sp.GetRequiredService<SearchDatabase>(),
            sp.GetRequiredService<ArchiveScanner>(),
            sp.GetRequiredService<EmailParser>(),
            sp.GetRequiredService<ILogger<IndexManager>>()));

        return services.BuildServiceProvider();
    }
}


================================================================================
FILE: MyEmailSearch/.backup/RebuildCommand.cs
SIZE: 3.30 KB
MODIFIED: 2025-12-31 17:35:01
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'rebuild' command to rebuild the index from scratch.
/// </summary>
public static class RebuildCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var confirmOption = new Option<bool>(["--yes", "-y"])
        {
            Description = "Skip confirmation prompt"
        };

        var contentOption = new Option<bool>("--content")
        {
            Description = "Also index email body content"
        };

        var command = new Command("rebuild", "Rebuild the entire search index from scratch");
        command.Options.Add(confirmOption);
        command.Options.Add(contentOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var confirm = parseResult.GetValue(confirmOption);
            var content = parseResult.GetValue(contentOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(confirm, content, archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        bool confirm,
        bool content,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        if (!confirm)
        {
            Console.Write("This will delete and rebuild the entire index. Continue? [y/N]: ");
            var response = Console.ReadLine();
            if (!string.Equals(response, "y", StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine("Cancelled.");
                return;
            }
        }

        Console.WriteLine("Rebuilding index...");
        Console.WriteLine($"Archive path: {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine();

        // Ensure database directory exists
        var dbDir = Path.GetDirectoryName(databasePath);
        if (!string.IsNullOrEmpty(dbDir) && !Directory.Exists(dbDir))
        {
            Directory.CreateDirectory(dbDir);
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var indexManager = sp.GetRequiredService<IndexManager>();

        var progress = new Progress<IndexingProgress>(p =>
        {
            Console.Write($"\rProcessing: {p.Processed}/{p.Total} ({p.Percentage:F1}%)");
        });

        var result = await indexManager.RebuildIndexAsync(archivePath, content, progress, ct);

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine("Rebuild complete:");
        Console.WriteLine($"  Indexed: {result.Indexed}");
        Console.WriteLine($"  Errors:  {result.Errors}");
        Console.WriteLine($"  Time:    {result.Duration}");
    }
}


================================================================================
FILE: MyEmailSearch/.backup/SearchCommand.cs
SIZE: 6.99 KB
MODIFIED: 2025-12-31 17:35:01
================================================================================

using System.CommandLine;
using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Search;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'search' command for querying the email index.
/// </summary>
public static class SearchCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var queryArgument = new Argument<string>("query")
        {
            Description = "Search query (e.g., 'from:alice@example.com subject:report kafka')"
        };

        var limitOption = new Option<int>(["--limit", "-l"])
        {
            Description = "Maximum number of results to return",
            DefaultValueFactory = _ => 100
        };

        var formatOption = new Option<string>(["--format", "-f"])
        {
            Description = "Output format: table, json, or csv",
            DefaultValueFactory = _ => "table"
        };

        var command = new Command("search", "Search emails in the archive");
        command.Arguments.Add(queryArgument);
        command.Options.Add(limitOption);
        command.Options.Add(formatOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var query = parseResult.GetValue(queryArgument)!;
            var limit = parseResult.GetValue(limitOption);
            var format = parseResult.GetValue(formatOption)!;
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(query, limit, format, archivePath, databasePath, verbose, ct)
                .ConfigureAwait(false);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        string query,
        int limit,
        string format,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        // Validate input
        if (string.IsNullOrWhiteSpace(query))
        {
            Console.Error.WriteLine("Error: Search query cannot be empty");
            return;
        }

        if (!File.Exists(databasePath))
        {
            Console.Error.WriteLine($"Error: No index exists at {databasePath}");
            Console.Error.WriteLine("Run 'myemailsearch index' first to create the index.");
            return;
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var searchEngine = sp.GetRequiredService<SearchEngine>();

        // Ensure database is initialized
        await database.InitializeAsync(ct).ConfigureAwait(false);

        // Execute search
        var results = await searchEngine.SearchAsync(query, limit, 0, ct).ConfigureAwait(false);

        // Output results with error handling
        try
        {
            switch (format.ToLowerInvariant())
            {
                case "json":
                    OutputJson(results);
                    break;
                case "csv":
                    OutputCsv(results);
                    break;
                default:
                    OutputTable(results);
                    break;
            }
        }
        catch (IOException ex)
        {
            // Handle broken pipe or other I/O errors gracefully
            if (verbose)
            {
                Console.Error.WriteLine($"Output error: {ex.Message}");
            }
        }
    }

    private static void OutputTable(SearchResultSet results)
    {
        Console.WriteLine($"Found {results.Results.Count} results in {results.QueryTime.TotalMilliseconds:F0}ms");
        Console.WriteLine(new string('-', 100));

        if (results.Results.Count == 0)
        {
            Console.WriteLine("No results found.");
            return;
        }

        foreach (var result in results.Results)
        {
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd HH:mm") ?? "Unknown";
            var from = TruncateString(result.Email.FromAddress ?? "Unknown", 30);
            var subject = TruncateString(result.Email.Subject ?? "(No subject)", 50);

            Console.WriteLine($"{date}  {from,-30}  {subject}");

            if (!string.IsNullOrWhiteSpace(result.Snippet))
            {
                Console.WriteLine($"    {TruncateString(result.Snippet, 90)}");
            }

            Console.WriteLine();
        }

        if (results.HasMore)
        {
            Console.WriteLine($"... and {results.TotalCount - results.Results.Count} more results");
        }
    }

    private static void OutputJson(SearchResultSet results)
    {
        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        var output = new
        {
            results.TotalCount,
            QueryTimeMs = results.QueryTime.TotalMilliseconds,
            Results = results.Results.Select(r => new
            {
                r.Email.MessageId,
                r.Email.FromAddress,
                r.Email.Subject,
                DateSent = r.Email.DateSent?.ToString("O"),
                r.Email.Folder,
                r.Email.Account,
                r.Email.FilePath,
                r.Snippet
            })
        };

        Console.WriteLine(JsonSerializer.Serialize(output, options));
    }

    private static void OutputCsv(SearchResultSet results)
    {
        // Header
        Console.WriteLine("\"MessageId\",\"From\",\"Subject\",\"Date\",\"Folder\",\"Account\",\"FilePath\"");

        foreach (var result in results.Results)
        {
            var messageId = EscapeCsvField(result.Email.MessageId);
            var from = EscapeCsvField(result.Email.FromAddress ?? "");
            var subject = EscapeCsvField(result.Email.Subject ?? "");
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd HH:mm:ss") ?? "";
            var folder = EscapeCsvField(result.Email.Folder ?? "");
            var account = EscapeCsvField(result.Email.Account ?? "");
            var filePath = EscapeCsvField(result.Email.FilePath);

            Console.WriteLine($"{messageId},{from},{subject},\"{date}\",{folder},{account},{filePath}");
        }
    }

    private static string TruncateString(string value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        if (value.Length <= maxLength) return value;
        return value[..(maxLength - 3)] + "...";
    }

    private static string EscapeCsvField(string value)
    {
        if (string.IsNullOrEmpty(value)) return "\"\"";

        // Escape quotes by doubling them and wrap in quotes
        var escaped = value.Replace("\"", "\"\"");
        return $"\"{escaped}\"";
    }
}


================================================================================
FILE: MyEmailSearch/.backup/StatusCommand.cs
SIZE: 3.13 KB
MODIFIED: 2025-12-31 17:35:01
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'status' command to show index statistics.
/// </summary>
public static class StatusCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var command = new Command("status", "Show index status and statistics");

        command.SetAction(async (parseResult, ct) =>
        {
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        Console.WriteLine("MyEmailSearch - Index Status");
        Console.WriteLine(new string('=', 40));
        Console.WriteLine();

        Console.WriteLine($"Archive path:  {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine();

        if (!File.Exists(databasePath))
        {
            Console.WriteLine("Status: No index exists yet");
            Console.WriteLine("Run 'myemailsearch index' to create the index");
            return;
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();

        try
        {
            await database.InitializeAsync(ct);

            var emailCount = await database.GetEmailCountAsync(ct);
            var dbSize = database.GetDatabaseSize();
            var lastIndexed = await database.GetMetadataAsync("last_indexed_time", ct);
            var lastIndexedTime = lastIndexed != null
                ? DateTimeOffset.FromUnixTimeSeconds(long.Parse(lastIndexed))
                : (DateTimeOffset?)null;

            Console.WriteLine($"Total emails indexed: {emailCount:N0}");
            Console.WriteLine($"Index size:           {FormatBytes(dbSize)}");
            Console.WriteLine($"Last indexed:         {lastIndexedTime?.ToString("yyyy-MM-dd HH:mm:ss") ?? "Never"}");

            var healthy = await database.IsHealthyAsync(ct);
            Console.WriteLine($"Database health:      {(healthy ? "OK" : "ERROR")}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading database: {ex.Message}");
        }
    }

    private static string FormatBytes(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB", "TB"];
        var i = 0;
        var size = (double)bytes;
        while (size >= 1024 && i < suffixes.Length - 1)
        {
            size /= 1024;
            i++;
        }
        return $"{size:F2} {suffixes[i]}";
    }
}


================================================================================
FILE: MyEmailSearch/Commands/IndexCommand.cs
SIZE: 3.54 KB
MODIFIED: 2025-12-31 17:45:57
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'index' command for building/updating the search index.
/// </summary>
public static class IndexCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var fullOption = new Option<bool>("--full", "-f")
        {
            Description = "Force full re-index (ignore incremental state)"
        };

        var contentOption = new Option<bool>("--content")
        {
            Description = "Index email body content for full-text search"
        };

        var command = new Command("index", "Build or update the search index");
        command.Options.Add(fullOption);
        command.Options.Add(contentOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var full = parseResult.GetValue(fullOption);
            var content = parseResult.GetValue(contentOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(full, content, archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        bool full,
        bool content,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        Console.WriteLine($"Indexing emails from: {archivePath}");
        Console.WriteLine($"Database location:    {databasePath}");
        Console.WriteLine($"Mode:                 {(full ? "Full rebuild" : "Incremental")}");
        Console.WriteLine($"Index content:        {(content ? "Yes" : "No")}");
        Console.WriteLine();

        // Ensure database directory exists
        var dbDir = Path.GetDirectoryName(databasePath);
        if (!string.IsNullOrEmpty(dbDir) && !Directory.Exists(dbDir))
        {
            Directory.CreateDirectory(dbDir);
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var indexManager = sp.GetRequiredService<IndexManager>();

        await database.InitializeAsync(ct);

        var progress = new Progress<IndexingProgress>(p =>
        {
            var pct = p.Total > 0 ? (double)p.Processed / p.Total * 100 : 0;
            Console.Write($"\rProcessing: {p.Processed:N0}/{p.Total:N0} ({pct:F1}%) - {p.CurrentFile ?? ""}".PadRight(100)[..100]);
        });

        IndexingResult result;
        if (full)
        {
            result = await indexManager.RebuildIndexAsync(archivePath, content, progress, ct);
        }
        else
        {
            result = await indexManager.IndexAsync(archivePath, content, progress, ct);
        }

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine("Indexing complete:");
        Console.WriteLine($"  New emails indexed: {result.Indexed:N0}");
        Console.WriteLine($"  Skipped (existing): {result.Skipped:N0}");
        Console.WriteLine($"  Errors:             {result.Errors:N0}");
        Console.WriteLine($"  Duration:           {result.Duration}");
    }
}


================================================================================
FILE: MyEmailSearch/Commands/RebuildCommand.cs
SIZE: 3.40 KB
MODIFIED: 2025-12-31 17:45:57
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'rebuild' command for completely rebuilding the search index.
/// </summary>
public static class RebuildCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var confirmOption = new Option<bool>("--yes", "-y")
        {
            Description = "Skip confirmation prompt"
        };

        var contentOption = new Option<bool>("--content")
        {
            Description = "Also index email body content"
        };

        var command = new Command("rebuild", "Rebuild the entire search index from scratch");
        command.Options.Add(confirmOption);
        command.Options.Add(contentOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var confirm = parseResult.GetValue(confirmOption);
            var content = parseResult.GetValue(contentOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(confirm, content, archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        bool confirm,
        bool content,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        if (!confirm)
        {
            Console.Write("This will delete and rebuild the entire index. Continue? [y/N]: ");
            var response = Console.ReadLine();
            if (!string.Equals(response, "y", StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine("Cancelled.");
                return;
            }
        }

        Console.WriteLine("Rebuilding index...");
        Console.WriteLine($"Archive path: {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine();

        // Ensure database directory exists
        var dbDir = Path.GetDirectoryName(databasePath);
        if (!string.IsNullOrEmpty(dbDir) && !Directory.Exists(dbDir))
        {
            Directory.CreateDirectory(dbDir);
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var indexManager = sp.GetRequiredService<IndexManager>();

        var progress = new Progress<IndexingProgress>(p =>
        {
            var pct = p.Total > 0 ? (double)p.Processed / p.Total * 100 : 0;
            Console.Write($"\rProcessing: {p.Processed:N0}/{p.Total:N0} ({pct:F1}%)".PadRight(60));
        });

        var result = await indexManager.RebuildIndexAsync(archivePath, content, progress, ct);

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine("Rebuild complete:");
        Console.WriteLine($"  Indexed: {result.Indexed:N0}");
        Console.WriteLine($"  Errors:  {result.Errors:N0}");
        Console.WriteLine($"  Time:    {result.Duration}");
    }
}


================================================================================
FILE: MyEmailSearch/Commands/SearchCommand.cs
SIZE: 5.82 KB
MODIFIED: 2025-12-31 17:45:57
================================================================================

using System.CommandLine;
using System.Text.Json;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Search;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'search' command for querying the email index.
/// </summary>
public static class SearchCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var queryArgument = new Argument<string>("query")
        {
            Description = "Search query (e.g., 'from:alice@example.com subject:report kafka')"
        };

        var limitOption = new Option<int>("--limit", "-l")
        {
            Description = "Maximum number of results to return",
            DefaultValueFactory = _ => 100
        };

        var formatOption = new Option<string>("--format", "-f")
        {
            Description = "Output format: table, json, or csv",
            DefaultValueFactory = _ => "table"
        };

        var command = new Command("search", "Search emails in the archive");
        command.Arguments.Add(queryArgument);
        command.Options.Add(limitOption);
        command.Options.Add(formatOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var query = parseResult.GetValue(queryArgument)!;
            var limit = parseResult.GetValue(limitOption);
            var format = parseResult.GetValue(formatOption)!;
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(query, limit, format, archivePath, databasePath, verbose, ct)
                .ConfigureAwait(false);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        string query,
        int limit,
        string format,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(query))
        {
            Console.Error.WriteLine("Error: Search query cannot be empty");
            return;
        }

        if (!File.Exists(databasePath))
        {
            Console.Error.WriteLine($"Error: No index exists at {databasePath}");
            Console.Error.WriteLine("Run 'myemailsearch index' first to create the index.");
            return;
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var searchEngine = sp.GetRequiredService<SearchEngine>();

        await database.InitializeAsync(ct);

        var results = await searchEngine.SearchAsync(query, limit, 0, ct);

        switch (format.ToLowerInvariant())
        {
            case "json":
                OutputJson(results);
                break;
            case "csv":
                OutputCsv(results);
                break;
            default:
                OutputTable(results);
                break;
        }
    }

    private static void OutputTable(SearchResultSet results)
    {
        if (results.TotalCount == 0)
        {
            Console.WriteLine("No results found.");
            return;
        }

        Console.WriteLine($"Found {results.TotalCount} results ({results.QueryTime.TotalMilliseconds:F0}ms):");
        Console.WriteLine();
        Console.WriteLine($"{"Date",-12} {"From",-30} {"Subject",-50}");
        Console.WriteLine(new string('-', 94));

        foreach (var result in results.Results)
        {
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd") ?? "Unknown";
            var from = TruncateString(result.Email.FromAddress ?? "Unknown", 28);
            var subject = TruncateString(result.Email.Subject ?? "(no subject)", 48);

            Console.WriteLine($"{date,-12} {from,-30} {subject,-50}");

            if (!string.IsNullOrWhiteSpace(result.Snippet))
            {
                Console.WriteLine($"             {result.Snippet}");
            }
        }

        Console.WriteLine();
        Console.WriteLine($"Showing {results.Results.Count} of {results.TotalCount} results");
    }

    private static void OutputJson(SearchResultSet results)
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        Console.WriteLine(JsonSerializer.Serialize(results, options));
    }

    private static void OutputCsv(SearchResultSet results)
    {
        Console.WriteLine("MessageId,From,Subject,Date,Folder,Account,FilePath");
        foreach (var result in results.Results)
        {
            var messageId = EscapeCsvField(result.Email.MessageId ?? "");
            var from = EscapeCsvField(result.Email.FromAddress ?? "");
            var subject = EscapeCsvField(result.Email.Subject ?? "");
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd HH:mm:ss") ?? "";
            var folder = EscapeCsvField(result.Email.Folder ?? "");
            var account = EscapeCsvField(result.Email.Account ?? "");
            var filePath = EscapeCsvField(result.Email.FilePath);

            Console.WriteLine($"{messageId},{from},{subject},\"{date}\",{folder},{account},{filePath}");
        }
    }

    private static string TruncateString(string value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        if (value.Length <= maxLength) return value;
        return value[..(maxLength - 3)] + "...";
    }

    private static string EscapeCsvField(string value)
    {
        if (string.IsNullOrEmpty(value)) return "\"\"";
        var escaped = value.Replace("\"", "\"\"");
        return $"\"{escaped}\"";
    }
}


================================================================================
FILE: MyEmailSearch/Commands/StatusCommand.cs
SIZE: 3.14 KB
MODIFIED: 2025-12-31 17:45:57
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'status' command for displaying index statistics.
/// </summary>
public static class StatusCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var command = new Command("status", "Show index status and statistics");

        command.SetAction(async (parseResult, ct) =>
        {
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        Console.WriteLine("MyEmailSearch - Index Status");
        Console.WriteLine(new string('=', 40));
        Console.WriteLine();

        Console.WriteLine($"Archive path:  {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine();

        if (!File.Exists(databasePath))
        {
            Console.WriteLine("Status: No index exists yet");
            Console.WriteLine("Run 'myemailsearch index' to create the index");
            return;
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();

        try
        {
            await database.InitializeAsync(ct);

            var emailCount = await database.GetEmailCountAsync(ct);
            var dbSize = database.GetDatabaseSize();
            var lastIndexed = await database.GetMetadataAsync("last_indexed_time", ct);
            var lastIndexedTime = lastIndexed != null
                ? DateTimeOffset.FromUnixTimeSeconds(long.Parse(lastIndexed))
                : (DateTimeOffset?)null;

            Console.WriteLine($"Total emails indexed: {emailCount:N0}");
            Console.WriteLine($"Index size:           {FormatBytes(dbSize)}");
            Console.WriteLine($"Last indexed:         {lastIndexedTime?.ToString("yyyy-MM-dd HH:mm:ss") ?? "Never"}");

            var healthy = await database.IsHealthyAsync(ct);
            Console.WriteLine($"Database health:      {(healthy ? "OK" : "ERROR")}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading database: {ex.Message}");
        }
    }

    private static string FormatBytes(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB", "TB"];
        var i = 0;
        var size = (double)bytes;
        while (size >= 1024 && i < suffixes.Length - 1)
        {
            size /= 1024;
            i++;
        }
        return $"{size:F2} {suffixes[i]}";
    }
}


================================================================================
FILE: MyEmailSearch/Configuration/PathResolver.cs
SIZE: 4.36 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

namespace MyEmailSearch.Configuration;

/// <summary>
/// Resolves paths following XDG Base Directory Specification.
/// </summary>
public static class PathResolver
{
    private const string AppName = "myemailsearch";

    /// <summary>
    /// Gets the default archive path, checking environment and common locations.
    /// </summary>
    public static string GetDefaultArchivePath()
    {
        // Check environment variable first
        var envPath = Environment.GetEnvironmentVariable("MYIMAPDOWNLOADER_ARCHIVE");
        if (!string.IsNullOrWhiteSpace(envPath) && Directory.Exists(envPath))
        {
            return envPath;
        }

        // Check XDG_DATA_HOME
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrWhiteSpace(xdgDataHome))
        {
            var xdgPath = Path.Combine(xdgDataHome, "myimapdownloader");
            if (Directory.Exists(xdgPath))
            {
                return xdgPath;
            }
        }

        // Check common locations
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var commonPaths = new[]
        {
            Path.Combine(home, ".local", "share", "myimapdownloader"),
            Path.Combine(home, "Documents", "mail"),
            Path.Combine(home, "mail"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "mail")
        };

        foreach (var path in commonPaths)
        {
            if (Directory.Exists(path))
            {
                return path;
            }
        }

        // Default to XDG location even if it doesn't exist
        return Path.Combine(
            xdgDataHome ?? Path.Combine(home, ".local", "share"),
            "myimapdownloader");
    }

    /// <summary>
    /// Gets the default database path following XDG specification.
    /// </summary>
    public static string GetDefaultDatabasePath()
    {
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        var dataDir = !string.IsNullOrWhiteSpace(xdgDataHome)
            ? Path.Combine(xdgDataHome, AppName)
            : Path.Combine(home, ".local", "share", AppName);

        return Path.Combine(dataDir, "search.db");
    }

    /// <summary>
    /// Gets the telemetry directory following XDG specification.
    /// </summary>
    public static string? GetTelemetryDirectory()
    {
        var candidates = GetCandidateDirectories("telemetry");

        foreach (var dir in candidates)
        {
            try
            {
                if (!Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir);
                }

                // Test write access
                var testFile = Path.Combine(dir, ".write_test");
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);

                return dir;
            }
            catch
            {
                // Try next candidate
            }
        }

        return null; // No writable location found
    }

    private static IEnumerable<string> GetCandidateDirectories(string subdir)
    {
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        // XDG_DATA_HOME
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrWhiteSpace(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, AppName, subdir);
        }

        // LocalApplicationData (works on Windows too)
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrWhiteSpace(localAppData))
        {
            yield return Path.Combine(localAppData, AppName, subdir);
        }

        // XDG_STATE_HOME
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrWhiteSpace(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, AppName, subdir);
        }

        // Fallbacks
        yield return Path.Combine(home, ".local", "state", AppName, subdir);
        yield return Path.Combine(home, ".local", "share", AppName, subdir);

        // Current directory as last resort
        yield return Path.Combine(Directory.GetCurrentDirectory(), subdir);
    }
}


================================================================================
FILE: MyEmailSearch/Data/EmailDocument.cs
SIZE: 2.24 KB
MODIFIED: 2025-12-31 17:56:07
================================================================================

using System.Text.Json;
using System.Text.Json.Serialization;

namespace MyEmailSearch.Data;

/// <summary>
/// Represents an email document stored in the search index.
/// </summary>
public sealed record EmailDocument
{
    public long Id { get; init; }
    public required string MessageId { get; init; }
    public required string FilePath { get; init; }
    public string? FromAddress { get; init; }
    public string? FromName { get; init; }
    public string? ToAddressesJson { get; init; }
    public string? CcAddressesJson { get; init; }
    public string? BccAddressesJson { get; init; }
    public string? Subject { get; init; }
    public long? DateSentUnix { get; init; }
    public long? DateReceivedUnix { get; init; }
    public string? Folder { get; init; }
    public string? Account { get; init; }
    public bool HasAttachments { get; init; }
    public string? AttachmentNamesJson { get; init; }
    public string? BodyPreview { get; init; }
    public string? BodyText { get; init; }
    public long IndexedAtUnix { get; init; }

    // Computed properties
    [JsonIgnore]
    public DateTimeOffset? DateSent => DateSentUnix.HasValue
        ? DateTimeOffset.FromUnixTimeSeconds(DateSentUnix.Value)
        : null;

    [JsonIgnore]
    public DateTimeOffset? DateReceived => DateReceivedUnix.HasValue
        ? DateTimeOffset.FromUnixTimeSeconds(DateReceivedUnix.Value)
        : null;

    [JsonIgnore]
    public IReadOnlyList<string> ToAddresses => ParseJsonArray(ToAddressesJson);

    [JsonIgnore]
    public IReadOnlyList<string> CcAddresses => ParseJsonArray(CcAddressesJson);

    [JsonIgnore]
    public IReadOnlyList<string> BccAddresses => ParseJsonArray(BccAddressesJson);

    [JsonIgnore]
    public IReadOnlyList<string> AttachmentNames => ParseJsonArray(AttachmentNamesJson);

    private static IReadOnlyList<string> ParseJsonArray(string? json)
    {
        if (string.IsNullOrWhiteSpace(json)) return [];
        try
        {
            return JsonSerializer.Deserialize<List<string>>(json) ?? [];
        }
        catch
        {
            return [];
        }
    }

    public static string ToJsonArray(IEnumerable<string>? items)
    {
        if (items == null) return "[]";
        return JsonSerializer.Serialize(items.ToList());
    }
}


================================================================================
FILE: MyEmailSearch/Data/IndexStatistics.cs
SIZE: 0.52 KB
MODIFIED: 2025-12-31 17:35:01
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Statistics about the search index.
/// </summary>
public sealed record IndexStatistics
{
    public long TotalEmails { get; init; }
    public long UniqueSenders { get; init; }
    public DateTimeOffset OldestEmail { get; init; }
    public DateTimeOffset NewestEmail { get; init; }
    public long EmailsWithAttachments { get; init; }
    public Dictionary<string, long> AccountCounts { get; init; } = new();
    public Dictionary<string, long> FolderCounts { get; init; } = new();
}


================================================================================
FILE: MyEmailSearch/Data/SearchDatabase.cs
SIZE: 22.80 KB
MODIFIED: 2025-12-31 18:02:48
================================================================================

using System.Data;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;

namespace MyEmailSearch.Data;

/// <summary>
/// Manages the SQLite database for email search indexing.
/// Uses FTS5 for full-text search and B-tree indexes for structured queries.
/// </summary>
public sealed class SearchDatabase : IAsyncDisposable
{
    private readonly string _connectionString;
    private readonly ILogger<SearchDatabase> _logger;
    private SqliteConnection? _connection;
    private bool _disposed;

    public string DatabasePath { get; }

    public SearchDatabase(string databasePath, ILogger<SearchDatabase> logger)
    {
        DatabasePath = databasePath ?? throw new ArgumentNullException(nameof(databasePath));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _connectionString = new SqliteConnectionStringBuilder
        {
            DataSource = databasePath,
            Mode = SqliteOpenMode.ReadWriteCreate,
            Cache = SqliteCacheMode.Shared
        }.ToString();
    }

    /// <summary>
    /// Initializes the database, creating tables if they don't exist.
    /// </summary>
    public async Task InitializeAsync(CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        _logger.LogInformation("Initializing search database at {Path}", DatabasePath);

        // Enable WAL mode for better concurrent access
        await ExecuteNonQueryAsync("PRAGMA journal_mode=WAL;", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync("PRAGMA synchronous=NORMAL;", ct).ConfigureAwait(false);

        // Create main emails table
        const string createEmailsTable = """
            CREATE TABLE IF NOT EXISTS emails (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                message_id TEXT NOT NULL UNIQUE,
                file_path TEXT NOT NULL,
                from_address TEXT,
                from_name TEXT,
                to_addresses TEXT,
                cc_addresses TEXT,
                bcc_addresses TEXT,
                subject TEXT,
                date_sent_unix INTEGER,
                date_received_unix INTEGER,
                folder TEXT,
                account TEXT,
                has_attachments INTEGER DEFAULT 0,
                attachment_names TEXT,
                body_preview TEXT,
                body_text TEXT,
                indexed_at_unix INTEGER NOT NULL
            );
            """;
        await ExecuteNonQueryAsync(createEmailsTable, ct).ConfigureAwait(false);

        // Create indexes for common queries
        await ExecuteNonQueryAsync(
            "CREATE INDEX IF NOT EXISTS idx_emails_from ON emails(from_address);", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync(
            "CREATE INDEX IF NOT EXISTS idx_emails_date ON emails(date_sent_unix);", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync(
            "CREATE INDEX IF NOT EXISTS idx_emails_folder ON emails(folder);", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync(
            "CREATE INDEX IF NOT EXISTS idx_emails_account ON emails(account);", ct).ConfigureAwait(false);

        // Create FTS5 virtual table for full-text search
        const string createFtsTable = """
            CREATE VIRTUAL TABLE IF NOT EXISTS emails_fts USING fts5(
                subject,
                body_text,
                from_address,
                to_addresses,
                content='emails',
                content_rowid='id',
                tokenize='porter unicode61'
            );
            """;
        await ExecuteNonQueryAsync(createFtsTable, ct).ConfigureAwait(false);

        // Create triggers to keep FTS index in sync
        const string createInsertTrigger = """
            CREATE TRIGGER IF NOT EXISTS emails_ai AFTER INSERT ON emails BEGIN
                INSERT INTO emails_fts(rowid, subject, body_text, from_address, to_addresses)
                VALUES (new.id, new.subject, new.body_text, new.from_address, new.to_addresses);
            END;
            """;
        await ExecuteNonQueryAsync(createInsertTrigger, ct).ConfigureAwait(false);

        const string createDeleteTrigger = """
            CREATE TRIGGER IF NOT EXISTS emails_ad AFTER DELETE ON emails BEGIN
                INSERT INTO emails_fts(emails_fts, rowid, subject, body_text, from_address, to_addresses)
                VALUES ('delete', old.id, old.subject, old.body_text, old.from_address, old.to_addresses);
            END;
            """;
        await ExecuteNonQueryAsync(createDeleteTrigger, ct).ConfigureAwait(false);

        const string createUpdateTrigger = """
            CREATE TRIGGER IF NOT EXISTS emails_au AFTER UPDATE ON emails BEGIN
                INSERT INTO emails_fts(emails_fts, rowid, subject, body_text, from_address, to_addresses)
                VALUES ('delete', old.id, old.subject, old.body_text, old.from_address, old.to_addresses);
                INSERT INTO emails_fts(rowid, subject, body_text, from_address, to_addresses)
                VALUES (new.id, new.subject, new.body_text, new.from_address, new.to_addresses);
            END;
            """;
        await ExecuteNonQueryAsync(createUpdateTrigger, ct).ConfigureAwait(false);

        // Create metadata table for tracking index state
        const string createMetadataTable = """
            CREATE TABLE IF NOT EXISTS index_metadata (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL
            );
            """;
        await ExecuteNonQueryAsync(createMetadataTable, ct).ConfigureAwait(false);

        _logger.LogInformation("Search database initialized successfully");
    }

    /// <summary>
    /// Gets the total number of indexed emails.
    /// </summary>
    public async Task<long> GetEmailCountAsync(CancellationToken ct = default)
    {
        return await ExecuteScalarAsync<long>("SELECT COUNT(*) FROM emails;", ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Gets the database file size in bytes.
    /// </summary>
    public long GetDatabaseSize()
    {
        if (!File.Exists(DatabasePath)) return 0;
        return new FileInfo(DatabasePath).Length;
    }

    /// <summary>
    /// Queries emails based on search criteria.
    /// </summary>
    public async Task<List<EmailDocument>> QueryAsync(SearchQuery query, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        var conditions = new List<string>();
        var parameters = new Dictionary<string, object>();

        // Build WHERE conditions
        if (!string.IsNullOrWhiteSpace(query.FromAddress))
        {
            if (query.FromAddress.Contains('*'))
            {
                conditions.Add("from_address LIKE @fromAddress");
                parameters["@fromAddress"] = query.FromAddress.Replace('*', '%');
            }
            else
            {
                conditions.Add("from_address = @fromAddress");
                parameters["@fromAddress"] = query.FromAddress;
            }
        }

        if (!string.IsNullOrWhiteSpace(query.ToAddress))
        {
            conditions.Add("to_addresses LIKE @toAddress");
            parameters["@toAddress"] = $"%{query.ToAddress}%";
        }

        if (!string.IsNullOrWhiteSpace(query.Subject))
        {
            conditions.Add("subject LIKE @subject");
            parameters["@subject"] = $"%{query.Subject}%";
        }

        if (query.DateFrom.HasValue)
        {
            conditions.Add("date_sent_unix >= @dateFrom");
            parameters["@dateFrom"] = query.DateFrom.Value.ToUnixTimeSeconds();
        }

        if (query.DateTo.HasValue)
        {
            conditions.Add("date_sent_unix <= @dateTo");
            parameters["@dateTo"] = query.DateTo.Value.ToUnixTimeSeconds();
        }

        if (!string.IsNullOrWhiteSpace(query.Account))
        {
            conditions.Add("account = @account");
            parameters["@account"] = query.Account;
        }

        if (!string.IsNullOrWhiteSpace(query.Folder))
        {
            conditions.Add("folder = @folder");
            parameters["@folder"] = query.Folder;
        }

        string sql;
        var ftsQuery = PrepareFts5MatchQuery(query.ContentTerms);

        if (!string.IsNullOrWhiteSpace(ftsQuery))
        {
            // Full-text search with optional structured conditions
            var whereClause = conditions.Count > 0
                ? $"AND {string.Join(" AND ", conditions)}" : "";

            sql = $"""
                SELECT emails.*
                FROM emails
                INNER JOIN emails_fts ON emails.id = emails_fts.rowid
                WHERE emails_fts MATCH @ftsQuery {whereClause}
                ORDER BY bm25(emails_fts) 
                LIMIT @limit OFFSET @offset;
                """;
            parameters["@ftsQuery"] = ftsQuery;
        }
        else
        {
            // Structured query only
            var whereClause = conditions.Count > 0 ? $"WHERE {string.Join(" AND ", conditions)}" : "";
            var orderBy = query.SortOrder switch
            {
                SearchSortOrder.DateAscending => "ORDER BY date_sent_unix ASC",
                _ => "ORDER BY date_sent_unix DESC"
            };

            sql = $"""
                SELECT * FROM emails
                {whereClause}
                {orderBy}
                LIMIT @limit OFFSET @offset;
                """;
        }

        parameters["@limit"] = query.Take;
        parameters["@offset"] = query.Skip;

        var results = new List<EmailDocument>();
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;

        foreach (var (key, value) in parameters)
        {
            cmd.Parameters.AddWithValue(key, value);
        }

        await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);
        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {
            results.Add(MapToEmailDocument(reader));
        }

        return results;
    }

    /// <summary>
    /// Checks if an email with the given message ID already exists.
    /// </summary>
    public async Task<bool> EmailExistsAsync(string messageId, CancellationToken ct = default)
    {
        const string sql = "SELECT COUNT(1) FROM emails WHERE message_id = @messageId;";
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@messageId", messageId);

        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return Convert.ToInt64(result) > 0;
    }

    /// <summary>
    /// Inserts or updates a single email.
    /// </summary>
    public async Task UpsertEmailAsync(EmailDocument email, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);
        await UpsertEmailInternalAsync(email, ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Inserts or updates a batch of emails.
    /// </summary>
    public async Task BatchUpsertEmailsAsync(
        IReadOnlyList<EmailDocument> emails,
        CancellationToken ct = default)
    {
        if (emails.Count == 0) return;

        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        await using var transaction = await _connection!.BeginTransactionAsync(ct).ConfigureAwait(false);

        try
        {
            foreach (var email in emails)
            {
                await UpsertEmailInternalAsync(email, ct).ConfigureAwait(false);
            }

            await transaction.CommitAsync(ct).ConfigureAwait(false);
        }
        catch
        {
            await transaction.RollbackAsync(ct).ConfigureAwait(false);
            throw;
        }
    }

    private async Task UpsertEmailInternalAsync(EmailDocument email, CancellationToken ct)
    {
        const string sql = """
            INSERT INTO emails (
                message_id, file_path, from_address, from_name,
                to_addresses, cc_addresses, bcc_addresses,
                subject, date_sent_unix, date_received_unix,
                folder, account, has_attachments, attachment_names,
                body_preview, body_text, indexed_at_unix
            ) VALUES (
                @messageId, @filePath, @fromAddress, @fromName,
                @toAddresses, @ccAddresses, @bccAddresses,
                @subject, @dateSentUnix, @dateReceivedUnix,
                @folder, @account, @hasAttachments, @attachmentNames,
                @bodyPreview, @bodyText, @indexedAtUnix
            )
            ON CONFLICT(message_id) DO UPDATE SET
                file_path = excluded.file_path,
                from_address = excluded.from_address,
                from_name = excluded.from_name,
                to_addresses = excluded.to_addresses,
                cc_addresses = excluded.cc_addresses,
                bcc_addresses = excluded.bcc_addresses,
                subject = excluded.subject,
                date_sent_unix = excluded.date_sent_unix,
                date_received_unix = excluded.date_received_unix,
                folder = excluded.folder,
                account = excluded.account,
                has_attachments = excluded.has_attachments,
                attachment_names = excluded.attachment_names,
                body_preview = excluded.body_preview,
                body_text = excluded.body_text,
                indexed_at_unix = excluded.indexed_at_unix;
            """;

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@messageId", email.MessageId);
        cmd.Parameters.AddWithValue("@filePath", email.FilePath);
        cmd.Parameters.AddWithValue("@fromAddress", (object?)email.FromAddress ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@fromName", (object?)email.FromName ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@toAddresses", (object?)email.ToAddressesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@ccAddresses", (object?)email.CcAddressesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@bccAddresses", (object?)email.BccAddressesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@subject", (object?)email.Subject ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@dateSentUnix", (object?)email.DateSentUnix ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@dateReceivedUnix", (object?)email.DateReceivedUnix ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@folder", (object?)email.Folder ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@account", (object?)email.Account ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@hasAttachments", email.HasAttachments ? 1 : 0);
        cmd.Parameters.AddWithValue("@attachmentNames", (object?)email.AttachmentNamesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@bodyPreview", (object?)email.BodyPreview ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@bodyText", (object?)email.BodyText ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@indexedAtUnix", email.IndexedAtUnix);

        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Rebuilds the database, dropping all data.
    /// </summary>
    public async Task RebuildAsync(CancellationToken ct = default)
    {
        _logger.LogWarning("Rebuilding database - all existing data will be deleted");

        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        // Drop triggers first
        await ExecuteNonQueryAsync("DROP TRIGGER IF EXISTS emails_ai;", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync("DROP TRIGGER IF EXISTS emails_ad;", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync("DROP TRIGGER IF EXISTS emails_au;", ct).ConfigureAwait(false);

        // Drop tables
        await ExecuteNonQueryAsync("DROP TABLE IF EXISTS emails_fts;", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync("DROP TABLE IF EXISTS emails;", ct).ConfigureAwait(false);
        await ExecuteNonQueryAsync("DROP TABLE IF EXISTS index_metadata;", ct).ConfigureAwait(false);

        // Vacuum to reclaim space
        await ExecuteNonQueryAsync("VACUUM;", ct).ConfigureAwait(false);

        // Reinitialize
        await InitializeAsync(ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Checks database health by running integrity check.
    /// </summary>
    public async Task<bool> IsHealthyAsync(CancellationToken ct = default)
    {
        try
        {
            await EnsureConnectionAsync(ct).ConfigureAwait(false);

            await using var cmd = _connection!.CreateCommand();
            cmd.CommandText = "PRAGMA integrity_check;";

            var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
            return result?.ToString() == "ok";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Database health check failed");
            return false;
        }
    }

    /// <summary>
    /// Prepares a search string for FTS5 MATCH query.
    /// Escapes special characters and handles wildcards.
    /// </summary>
    public static string? PrepareFts5MatchQuery(string? searchTerms)
    {
        if (string.IsNullOrWhiteSpace(searchTerms))
            return null;

        var trimmed = searchTerms.Trim();

        // Check if ends with wildcard
        var hasWildcard = trimmed.EndsWith('*');
        if (hasWildcard)
        {
            trimmed = trimmed[..^1]; // Remove the trailing *
        }

        // Wrap in quotes to escape FTS5 operators
        var escaped = $"\"{trimmed}\"";

        // Re-add wildcard outside quotes if needed
        if (hasWildcard)
        {
            escaped += "*";
        }

        return escaped;
    }


    /// <summary>
    /// Escapes a query string for safe use in FTS5.
    /// Wraps in quotes and escapes internal quotes.
    /// </summary>
    public static string? EscapeFts5Query(string? input)
    {
        if (input == null)
            return null;

        if (string.IsNullOrEmpty(input))
            return "";

        // Escape internal quotes by doubling them, then wrap in quotes
        var escaped = input.Replace("\"", "\"\"");
        return "\"" + escaped + "\"";
    }

    private static EmailDocument MapToEmailDocument(SqliteDataReader reader) => new()
    {
        Id = reader.GetInt64(reader.GetOrdinal("id")),
        MessageId = reader.GetString(reader.GetOrdinal("message_id")),
        FilePath = reader.GetString(reader.GetOrdinal("file_path")),
        FromAddress = reader.IsDBNull(reader.GetOrdinal("from_address"))
            ? null : reader.GetString(reader.GetOrdinal("from_address")),
        FromName = reader.IsDBNull(reader.GetOrdinal("from_name"))
            ? null : reader.GetString(reader.GetOrdinal("from_name")),
        ToAddressesJson = reader.IsDBNull(reader.GetOrdinal("to_addresses"))
            ? null : reader.GetString(reader.GetOrdinal("to_addresses")),
        CcAddressesJson = reader.IsDBNull(reader.GetOrdinal("cc_addresses"))
            ? null : reader.GetString(reader.GetOrdinal("cc_addresses")),
        BccAddressesJson = reader.IsDBNull(reader.GetOrdinal("bcc_addresses"))
            ? null : reader.GetString(reader.GetOrdinal("bcc_addresses")),
        Subject = reader.IsDBNull(reader.GetOrdinal("subject"))
            ? null : reader.GetString(reader.GetOrdinal("subject")),
        DateSentUnix = reader.IsDBNull(reader.GetOrdinal("date_sent_unix"))
            ? null : reader.GetInt64(reader.GetOrdinal("date_sent_unix")),
        DateReceivedUnix = reader.IsDBNull(reader.GetOrdinal("date_received_unix"))
            ? null : reader.GetInt64(reader.GetOrdinal("date_received_unix")),
        Folder = reader.IsDBNull(reader.GetOrdinal("folder"))
            ? null : reader.GetString(reader.GetOrdinal("folder")),
        Account = reader.IsDBNull(reader.GetOrdinal("account"))
            ? null : reader.GetString(reader.GetOrdinal("account")),
        HasAttachments = reader.GetInt64(reader.GetOrdinal("has_attachments")) == 1,
        AttachmentNamesJson = reader.IsDBNull(reader.GetOrdinal("attachment_names"))
            ? null : reader.GetString(reader.GetOrdinal("attachment_names")),
        BodyPreview = reader.IsDBNull(reader.GetOrdinal("body_preview"))
            ? null : reader.GetString(reader.GetOrdinal("body_preview")),
        BodyText = reader.IsDBNull(reader.GetOrdinal("body_text"))
            ? null : reader.GetString(reader.GetOrdinal("body_text")),
        IndexedAtUnix = reader.GetInt64(reader.GetOrdinal("indexed_at_unix"))
    };

    /// <summary>
    /// Gets metadata value by key.
    /// </summary>
    public async Task<string?> GetMetadataAsync(string key, CancellationToken ct = default)
    {
        const string sql = "SELECT value FROM index_metadata WHERE key = @key;";
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@key", key);

        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return result as string;
    }

    /// <summary>
    /// Sets metadata value by key.
    /// </summary>
    public async Task SetMetadataAsync(string key, string value, CancellationToken ct = default)
    {
        const string sql = """
            INSERT INTO index_metadata (key, value) VALUES (@key, @value)
            ON CONFLICT(key) DO UPDATE SET value = excluded.value;
            """;
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@key", key);
        cmd.Parameters.AddWithValue("@value", value);

        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    private async Task EnsureConnectionAsync(CancellationToken ct)
    {
        if (_connection != null && _connection.State == ConnectionState.Open)
            return;

        _connection?.Dispose();
        _connection = new SqliteConnection(_connectionString);
        await _connection.OpenAsync(ct).ConfigureAwait(false);
    }

    private async Task ExecuteNonQueryAsync(string sql, CancellationToken ct)
    {
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    private async Task<T> ExecuteScalarAsync<T>(string sql, CancellationToken ct)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return (T)Convert.ChangeType(result!, typeof(T));
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        if (_connection != null)
        {
            await _connection.DisposeAsync().ConfigureAwait(false);
            _connection = null;
        }
    }
}


================================================================================
FILE: MyEmailSearch/Data/SearchQuery.cs
SIZE: 0.73 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Represents parsed search criteria.
/// </summary>
public sealed record SearchQuery
{
    public string? FromAddress { get; init; }
    public string? ToAddress { get; init; }
    public string? Subject { get; init; }
    public string? ContentTerms { get; init; }
    public DateTimeOffset? DateFrom { get; init; }
    public DateTimeOffset? DateTo { get; init; }
    public string? Account { get; init; }
    public string? Folder { get; init; }
    public int Skip { get; init; } = 0;
    public int Take { get; init; } = 100;
    public SearchSortOrder SortOrder { get; init; } = SearchSortOrder.DateDescending;
}

public enum SearchSortOrder
{
    DateDescending,
    DateAscending,
    Relevance
}


================================================================================
FILE: MyEmailSearch/Data/SearchResult.cs
SIZE: 0.76 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Represents a single search result with optional snippet.
/// </summary>
public sealed record SearchResult
{
    public required EmailDocument Email { get; init; }
    public string? Snippet { get; init; }
    public IReadOnlyList<string> MatchedTerms { get; init; } = [];
    public double? Score { get; init; }
}

/// <summary>
/// Represents a set of search results with pagination info.
/// </summary>
public sealed record SearchResultSet
{
    public IReadOnlyList<SearchResult> Results { get; init; } = [];
    public int TotalCount { get; init; }
    public int Skip { get; init; }
    public int Take { get; init; }
    public TimeSpan QueryTime { get; init; }

    public bool HasMore => Skip + Results.Count < TotalCount;
}


================================================================================
FILE: MyEmailSearch/Indexing/ArchiveScanner.cs
SIZE: 1.96 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

using Microsoft.Extensions.Logging;

namespace MyEmailSearch.Indexing;

/// <summary>
/// Scans the email archive directory for .eml files.
/// </summary>
public sealed class ArchiveScanner
{
    private readonly ILogger<ArchiveScanner> _logger;

    public ArchiveScanner(ILogger<ArchiveScanner> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Scans the archive path for all .eml files.
    /// </summary>
    public IEnumerable<string> ScanForEmails(string archivePath)
    {
        if (!Directory.Exists(archivePath))
        {
            _logger.LogWarning("Archive path does not exist: {Path}", archivePath);
            yield break;
        }

        _logger.LogInformation("Scanning for emails in {Path}", archivePath);

        var options = new EnumerationOptions
        {
            RecurseSubdirectories = true,
            IgnoreInaccessible = true,
            MatchCasing = MatchCasing.CaseInsensitive
        };

        foreach (var file in Directory.EnumerateFiles(archivePath, "*.eml", options))
        {
            yield return file;
        }
    }

    /// <summary>
    /// Gets the account name from a file path (assumes account folder structure).
    /// </summary>
    public static string? ExtractAccountName(string filePath, string archivePath)
    {
        var relativePath = Path.GetRelativePath(archivePath, filePath);
        var parts = relativePath.Split(Path.DirectorySeparatorChar);

        // Expected structure: account_name/folder/cur/file.eml
        return parts.Length >= 2 ? parts[0] : null;
    }

    /// <summary>
    /// Gets the folder name from a file path.
    /// </summary>
    public static string? ExtractFolderName(string filePath, string archivePath)
    {
        var relativePath = Path.GetRelativePath(archivePath, filePath);
        var parts = relativePath.Split(Path.DirectorySeparatorChar);

        // Expected structure: account_name/folder/cur/file.eml
        return parts.Length >= 3 ? parts[1] : null;
    }
}


================================================================================
FILE: MyEmailSearch/Indexing/EmailParser.cs
SIZE: 5.18 KB
MODIFIED: 2025-12-31 10:50:08
================================================================================

using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyEmailSearch.Data;

namespace MyEmailSearch.Indexing;

/// <summary>
/// Parses .eml files and extracts structured data for indexing.
/// </summary>
public sealed class EmailParser
{
    private readonly ILogger<EmailParser> _logger;
    private readonly string _archivePath;
    private const int BodyPreviewLength = 500;

    public EmailParser(string archivePath, ILogger<EmailParser> logger)
    {
        _archivePath = archivePath;
        _logger = logger;
    }

    /// <summary>
    /// Parses an .eml file and returns an EmailDocument.
    /// </summary>
    public async Task<EmailDocument?> ParseAsync(
        string filePath,
        bool includeFullBody,
        CancellationToken ct = default)
    {
        try
        {
            var message = await MimeMessage.LoadAsync(filePath, ct).ConfigureAwait(false);

            var bodyText = GetBodyText(message);
            var bodyPreview = bodyText != null
                ? Truncate(bodyText, BodyPreviewLength)
                : null;

            var attachmentNames = message.Attachments
                .Select(a => a is MimePart mp ? mp.FileName : null)
                .Where(n => n != null)
                .Cast<string>()
                .ToList();

            return new EmailDocument
            {
                MessageId = message.MessageId ?? Path.GetFileNameWithoutExtension(filePath),
                FilePath = filePath,
                FromAddress = message.From.Mailboxes.FirstOrDefault()?.Address,
                FromName = message.From.Mailboxes.FirstOrDefault()?.Name,
                ToAddressesJson = EmailDocument.ToJsonArray(
                    message.To.Mailboxes.Select(m => m.Address)),
                CcAddressesJson = EmailDocument.ToJsonArray(
                    message.Cc.Mailboxes.Select(m => m.Address)),
                BccAddressesJson = EmailDocument.ToJsonArray(
                    message.Bcc.Mailboxes.Select(m => m.Address)),
                Subject = message.Subject,
                DateSentUnix = message.Date != DateTimeOffset.MinValue
                    ? message.Date.ToUnixTimeSeconds()
                    : null,
                Folder = ArchiveScanner.ExtractFolderName(filePath, _archivePath),
                Account = ArchiveScanner.ExtractAccountName(filePath, _archivePath),
                HasAttachments = attachmentNames.Count > 0,
                AttachmentNamesJson = attachmentNames.Count > 0
                    ? EmailDocument.ToJsonArray(attachmentNames)
                    : null,
                BodyPreview = bodyPreview,
                BodyText = includeFullBody ? bodyText : null,
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to parse email: {Path}", filePath);
            return null;
        }
    }

    /// <summary>
    /// Attempts to read metadata from sidecar .meta.json file.
    /// </summary>
    public async Task<EmailMetadata?> ReadMetadataAsync(string emlPath, CancellationToken ct)
    {
        var metaPath = emlPath + ".meta.json";
        if (!File.Exists(metaPath))
        {
            return null;
        }

        try
        {
            var json = await File.ReadAllTextAsync(metaPath, ct).ConfigureAwait(false);
            return JsonSerializer.Deserialize<EmailMetadata>(json);
        }
        catch
        {
            return null;
        }
    }

    private static string? GetBodyText(MimeMessage message)
    {
        // Prefer plain text body
        if (!string.IsNullOrWhiteSpace(message.TextBody))
        {
            return NormalizeWhitespace(message.TextBody);
        }

        // Fall back to HTML body stripped of tags
        if (!string.IsNullOrWhiteSpace(message.HtmlBody))
        {
            return NormalizeWhitespace(StripHtml(message.HtmlBody));
        }

        return null;
    }

    private static string StripHtml(string html)
    {
        // Simple HTML tag stripping - for more robust parsing, use a proper library
        var result = System.Text.RegularExpressions.Regex.Replace(html, "<[^>]+>", " ");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&nbsp;", " ");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&amp;", "&");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&lt;", "<");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&gt;", ">");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&quot;", "\"");
        return result;
    }

    private static string NormalizeWhitespace(string text)
    {
        return System.Text.RegularExpressions.Regex.Replace(text, @"\s+", " ").Trim();
    }

    private static string Truncate(string text, int maxLength)
    {
        if (text.Length <= maxLength) return text;
        return text[..maxLength] + "...";
    }
}

public sealed record EmailMetadata
{
    public string? MessageId { get; init; }
    public string? Subject { get; init; }
    public string? From { get; init; }
    public DateTimeOffset? Date { get; init; }
    public long? Uid { get; init; }
}


================================================================================
FILE: MyEmailSearch/Indexing/IndexManager.cs
SIZE: 4.83 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

using System.Diagnostics;
using Microsoft.Extensions.Logging;
using MyEmailSearch.Data;

namespace MyEmailSearch.Indexing;

/// <summary>
/// Manages the email search index lifecycle.
/// </summary>
public sealed class IndexManager
{
    private readonly SearchDatabase _database;
    private readonly ArchiveScanner _scanner;
    private readonly EmailParser _parser;
    private readonly ILogger<IndexManager> _logger;

    public IndexManager(
        SearchDatabase database,
        ArchiveScanner scanner,
        EmailParser parser,
        ILogger<IndexManager> logger)
    {
        _database = database;
        _scanner = scanner;
        _parser = parser;
        _logger = logger;
    }

    /// <summary>
    /// Performs incremental indexing - only indexes new emails.
    /// </summary>
    public async Task<IndexingResult> IndexAsync(
        string archivePath,
        bool includeContent,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();
        var result = new IndexingResult();

        _logger.LogInformation("Starting incremental index of {Path}", archivePath);

        var lastIndexed = await _database.GetMetadataAsync("last_indexed_time", ct)
            .ConfigureAwait(false);
        var lastIndexedTime = lastIndexed != null
            ? DateTimeOffset.FromUnixTimeSeconds(long.Parse(lastIndexed))
            : DateTimeOffset.MinValue;

        var emailFiles = _scanner.ScanForEmails(archivePath);
        var batch = new List<EmailDocument>();
        var processed = 0;
        var total = emailFiles.Count();

        foreach (var file in emailFiles)
        {
            ct.ThrowIfCancellationRequested();

            try
            {
                // Skip already indexed files (based on modification time)
                var fileInfo = new FileInfo(file);
                if (fileInfo.LastWriteTimeUtc < lastIndexedTime.UtcDateTime)
                {
                    // Check if already in database
                    var messageId = Path.GetFileNameWithoutExtension(file);
                    if (await _database.EmailExistsAsync(messageId, ct).ConfigureAwait(false))
                    {
                        result.Skipped++;
                        continue;
                    }
                }

                var email = await _parser.ParseAsync(file, includeContent, ct)
                    .ConfigureAwait(false);

                if (email != null)
                {
                    batch.Add(email);
                    result.Indexed++;

                    if (batch.Count >= 100)
                    {
                        await _database.BatchUpsertEmailsAsync(batch, ct).ConfigureAwait(false);
                        batch.Clear();
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to parse {File}", file);
                result.Errors++;
            }

            processed++;
            progress?.Report(new IndexingProgress
            {
                Processed = processed,
                Total = total,
                CurrentFile = file
            });
        }

        // Insert remaining batch
        if (batch.Count > 0)
        {
            await _database.BatchUpsertEmailsAsync(batch, ct).ConfigureAwait(false);
        }

        // Update last indexed time
        await _database.SetMetadataAsync(
            "last_indexed_time",
            DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(),
            ct).ConfigureAwait(false);

        stopwatch.Stop();
        result.Duration = stopwatch.Elapsed;

        _logger.LogInformation(
            "Indexing complete: {Indexed} indexed, {Skipped} skipped, {Errors} errors in {Duration}",
            result.Indexed, result.Skipped, result.Errors, result.Duration);

        return result;
    }

    /// <summary>
    /// Performs a full reindex, deleting all existing data.
    /// </summary>
    public async Task<IndexingResult> RebuildIndexAsync(
        string archivePath,
        bool includeContent,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default)
    {
        _logger.LogWarning("Rebuilding entire index from scratch");

        await _database.RebuildAsync(ct).ConfigureAwait(false);
        return await IndexAsync(archivePath, includeContent, progress, ct).ConfigureAwait(false);
    }
}

public sealed record IndexingResult
{
    public int Indexed { get; set; }
    public int Skipped { get; set; }
    public int Errors { get; set; }
    public TimeSpan Duration { get; set; }
}

public sealed record IndexingProgress
{
    public int Processed { get; init; }
    public int Total { get; init; }
    public string? CurrentFile { get; init; }
    public double Percentage => Total > 0 ? (double)Processed / Total * 100 : 0;
}


================================================================================
FILE: MyEmailSearch/MyEmailSearch.csproj
SIZE: 1.77 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!-- 
    MyEmailSearch - Email Archive Search Utility
    
    This project provides search capabilities over the email archive created by MyImapDownloader.
    It uses SQLite FTS5 for full-text search and shares telemetry/infrastructure patterns.
    
    Note: Most properties (TargetFramework, Nullable, etc.) are inherited from Directory.Build.props
    Package versions are managed centrally in Directory.Packages.props
  -->
  
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <RootNamespace>MyEmailSearch</RootNamespace>
    <AssemblyName>MyEmailSearch</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <!-- CLI Framework - Using System.CommandLine for modern CLI experience -->
    <PackageReference Include="System.CommandLine" />
    
    <!-- Database - SQLite with FTS5 for search -->
    <PackageReference Include="Microsoft.Data.Sqlite" />
    
    <!-- Email Parsing - MimeKit for extracting body text from .eml files -->
    <PackageReference Include="MimeKit" />
    
    <!-- Configuration -->
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" />
    
    <!-- Dependency Injection & Hosting -->
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    
    <!-- Logging -->
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
  </ItemGroup>

  <ItemGroup>
    <!-- Copy appsettings.json to output directory -->
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: MyEmailSearch/Program.cs
SIZE: 3.57 KB
MODIFIED: 2026-01-01 09:27:02
================================================================================

using System.CommandLine;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using MyEmailSearch.Commands;
using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;
using MyEmailSearch.Search;

namespace MyEmailSearch;

public static class Program
{
    public static async Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("MyEmailSearch - Search your email archive");
        // {
        //     Name = "myemailsearch"
        // };

        // Define Global options
        var archiveOption = new Option<string?>("--archive", "-a")
        {
            Description = "Path to the email archive directory"
        };

        var databaseOption = new Option<string?>("--database", "-d")
        {
            Description = "Path to the search database file"
        };

        var verboseOption = new Option<bool>("--verbose", "-v")
        {
            Description = "Enable verbose output"
        };

        // Add options to the root command (acting as global options)
        rootCommand.Options.Add(archiveOption);
        rootCommand.Options.Add(databaseOption);
        rootCommand.Options.Add(verboseOption);

        // Add subcommands using the Subcommands collection
        rootCommand.Subcommands.Add(SearchCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(IndexCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(StatusCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(RebuildCommand.Create(archiveOption, databaseOption, verboseOption));

        // Use the modern invocation pattern for System.CommandLine 2.0.x
        return await rootCommand.Parse(args).InvokeAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Creates a service provider with all required dependencies, manually resolving path-based dependencies.
    /// </summary>
    public static ServiceProvider CreateServiceProvider(
        string archivePath,
        string databasePath,
        bool verbose)
    {
        var services = new ServiceCollection();

        // Logging
        services.AddLogging(builder =>
        {
            builder.AddConsole();
            builder.SetMinimumLevel(verbose ? LogLevel.Debug : LogLevel.Information);
        });

        // Database - manually passing the databasePath
        services.AddSingleton(sp =>
            new SearchDatabase(databasePath, sp.GetRequiredService<ILogger<SearchDatabase>>()));

        // Search components
        services.AddSingleton<QueryParser>();
        services.AddSingleton<SnippetGenerator>();
        services.AddSingleton(sp => new SearchEngine(
            sp.GetRequiredService<SearchDatabase>(),
            sp.GetRequiredService<QueryParser>(),
            sp.GetRequiredService<SnippetGenerator>(),
            sp.GetRequiredService<ILogger<SearchEngine>>()));

        // Indexing components - manually passing the archivePath to EmailParser
        services.AddSingleton(sp =>
            new ArchiveScanner(sp.GetRequiredService<ILogger<ArchiveScanner>>()));

        services.AddSingleton(sp =>
            new EmailParser(archivePath, sp.GetRequiredService<ILogger<EmailParser>>()));

        services.AddSingleton(sp => new IndexManager(
            sp.GetRequiredService<SearchDatabase>(),
            sp.GetRequiredService<ArchiveScanner>(),
            sp.GetRequiredService<EmailParser>(),
            sp.GetRequiredService<ILogger<IndexManager>>()));

        return services.BuildServiceProvider();
    }
}


================================================================================
FILE: MyEmailSearch/Search/QueryParser.cs
SIZE: 4.27 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

using System.Text.RegularExpressions;
using MyEmailSearch.Data;

namespace MyEmailSearch.Search;

/// <summary>
/// Parses user search queries into structured SearchQuery objects.
/// Supports syntax like: from:alice@example.com subject:"project update" kafka
/// </summary>
public sealed partial class QueryParser
{
    [GeneratedRegex(@"from:(?<value>""[^""]+""|\S+)", RegexOptions.IgnoreCase)]
    private static partial Regex FromPattern();

    [GeneratedRegex(@"to:(?<value>""[^""]+""|\S+)", RegexOptions.IgnoreCase)]
    private static partial Regex ToPattern();

    [GeneratedRegex(@"subject:(?<value>""[^""]+""|\S+)", RegexOptions.IgnoreCase)]
    private static partial Regex SubjectPattern();

    [GeneratedRegex(@"date:(?<from>\d{4}-\d{2}-\d{2})(?:\.\.(?<to>\d{4}-\d{2}-\d{2}))?", RegexOptions.IgnoreCase)]
    private static partial Regex DatePattern();

    [GeneratedRegex(@"account:(?<value>\S+)", RegexOptions.IgnoreCase)]
    private static partial Regex AccountPattern();

    [GeneratedRegex(@"folder:(?<value>""[^""]+""|\S+)", RegexOptions.IgnoreCase)]
    private static partial Regex FolderPattern();

    /// <summary>
    /// Parses a user query string into a SearchQuery object.
    /// </summary>
    public SearchQuery Parse(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return new SearchQuery();
        }

        var remaining = input;
        string? fromAddress = null;
        string? toAddress = null;
        string? subject = null;
        string? account = null;
        string? folder = null;
        DateTimeOffset? dateFrom = null;
        DateTimeOffset? dateTo = null;

        // Extract from: field
        var fromMatch = FromPattern().Match(remaining);
        if (fromMatch.Success)
        {
            fromAddress = ExtractValue(fromMatch.Groups["value"].Value);
            remaining = FromPattern().Replace(remaining, "", 1);
        }

        // Extract to: field
        var toMatch = ToPattern().Match(remaining);
        if (toMatch.Success)
        {
            toAddress = ExtractValue(toMatch.Groups["value"].Value);
            remaining = ToPattern().Replace(remaining, "", 1);
        }

        // Extract subject: field
        var subjectMatch = SubjectPattern().Match(remaining);
        if (subjectMatch.Success)
        {
            subject = ExtractValue(subjectMatch.Groups["value"].Value);
            remaining = SubjectPattern().Replace(remaining, "", 1);
        }

        // Extract date: field
        var dateMatch = DatePattern().Match(remaining);
        if (dateMatch.Success)
        {
            if (DateTimeOffset.TryParse(dateMatch.Groups["from"].Value, out var from))
            {
                dateFrom = from;
            }
            if (dateMatch.Groups["to"].Success &&
                DateTimeOffset.TryParse(dateMatch.Groups["to"].Value, out var to))
            {
                dateTo = to.AddDays(1).AddTicks(-1); // End of day
            }
            remaining = DatePattern().Replace(remaining, "", 1);
        }

        // Extract account: field
        var accountMatch = AccountPattern().Match(remaining);
        if (accountMatch.Success)
        {
            account = accountMatch.Groups["value"].Value;
            remaining = AccountPattern().Replace(remaining, "", 1);
        }

        // Extract folder: field
        var folderMatch = FolderPattern().Match(remaining);
        if (folderMatch.Success)
        {
            folder = ExtractValue(folderMatch.Groups["value"].Value);
            remaining = FolderPattern().Replace(remaining, "", 1);
        }

        // Remaining text is full-text content search
        var contentTerms = remaining.Trim();

        return new SearchQuery
        {
            FromAddress = fromAddress,
            ToAddress = toAddress,
            Subject = subject,
            ContentTerms = string.IsNullOrWhiteSpace(contentTerms) ? null : contentTerms,
            DateFrom = dateFrom,
            DateTo = dateTo,
            Account = account,
            Folder = folder
        };
    }

    private static string ExtractValue(string value)
    {
        // Remove surrounding quotes if present
        if (value.StartsWith('"') && value.EndsWith('"') && value.Length > 2)
        {
            return value[1..^1];
        }
        return value;
    }
}


================================================================================
FILE: MyEmailSearch/Search/SearchEngine.cs
SIZE: 3.13 KB
MODIFIED: 2025-12-31 10:56:40
================================================================================

using System.Diagnostics;
using Microsoft.Extensions.Logging;
using MyEmailSearch.Data;

namespace MyEmailSearch.Search;

/// <summary>
/// Main search engine that coordinates queries against the SQLite database.
/// </summary>
public sealed class SearchEngine
{
    private readonly SearchDatabase _database;
    private readonly QueryParser _queryParser;
    private readonly SnippetGenerator _snippetGenerator;
    private readonly ILogger<SearchEngine> _logger;

    public SearchEngine(
        SearchDatabase database,
        QueryParser queryParser,
        SnippetGenerator snippetGenerator,
        ILogger<SearchEngine> logger)
    {
        _database = database ?? throw new ArgumentNullException(nameof(database));
        _queryParser = queryParser ?? throw new ArgumentNullException(nameof(queryParser));
        _snippetGenerator = snippetGenerator ?? throw new ArgumentNullException(nameof(snippetGenerator));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Executes a search query and returns results.
    /// </summary>
    public async Task<SearchResultSet> SearchAsync(
        string queryString,
        int limit = 100,
        int offset = 0,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(queryString))
        {
            return new SearchResultSet
            {
                Results = [],
                TotalCount = 0,
                Skip = offset,
                Take = limit,
                QueryTime = TimeSpan.Zero
            };
        }

        var stopwatch = Stopwatch.StartNew();

        _logger.LogInformation("Executing search: {Query}", queryString);

        var query = _queryParser.Parse(queryString);
        query = query with { Take = limit, Skip = offset };

        var emails = await _database.QueryAsync(query, ct).ConfigureAwait(false);

        var results = new List<SearchResult>();
        foreach (var email in emails)
        {
            var snippet = !string.IsNullOrWhiteSpace(query.ContentTerms)
                ? _snippetGenerator.Generate(email.BodyText, query.ContentTerms)
                : email.BodyPreview;

            results.Add(new SearchResult
            {
                Email = email,
                Snippet = snippet,
                MatchedTerms = ExtractMatchedTerms(query)
            });
        }

        stopwatch.Stop();

        _logger.LogInformation(
            "Search completed: {ResultCount} results in {ElapsedMs}ms",
            results.Count, stopwatch.ElapsedMilliseconds);

        return new SearchResultSet
        {
            Results = results,
            TotalCount = results.Count, // TODO: Get actual total count with separate count query
            Skip = offset,
            Take = limit,
            QueryTime = stopwatch.Elapsed
        };
    }

    private static IReadOnlyList<string> ExtractMatchedTerms(SearchQuery query)
    {
        var terms = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.ContentTerms))
        {
            terms.AddRange(query.ContentTerms.Split(' ', StringSplitOptions.RemoveEmptyEntries));
        }

        return terms;
    }
}


================================================================================
FILE: MyEmailSearch/Search/SnippetGenerator.cs
SIZE: 2.58 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

using System.Text;

namespace MyEmailSearch.Search;

/// <summary>
/// Generates contextual snippets from email body text highlighting matched terms.
/// </summary>
public sealed class SnippetGenerator
{
    private const int SnippetLength = 200;
    private const int ContextPadding = 50;

    /// <summary>
    /// Generates a snippet from the body text centered around the search terms.
    /// </summary>
    public string? Generate(string? bodyText, string? searchTerms)
    {
        if (string.IsNullOrWhiteSpace(bodyText))
        {
            return null;
        }

        if (string.IsNullOrWhiteSpace(searchTerms))
        {
            return Truncate(bodyText, SnippetLength);
        }

        var terms = searchTerms.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var firstMatchIndex = -1;

        // Find the first occurrence of any search term
        foreach (var term in terms)
        {
            var index = bodyText.IndexOf(term, StringComparison.OrdinalIgnoreCase);
            if (index >= 0 && (firstMatchIndex < 0 || index < firstMatchIndex))
            {
                firstMatchIndex = index;
            }
        }

        if (firstMatchIndex < 0)
        {
            return Truncate(bodyText, SnippetLength);
        }

        // Calculate snippet window
        var start = Math.Max(0, firstMatchIndex - ContextPadding);
        var end = Math.Min(bodyText.Length, start + SnippetLength);

        // Adjust start to word boundary
        if (start > 0)
        {
            var wordStart = bodyText.LastIndexOf(' ', start);
            if (wordStart > 0)
            {
                start = wordStart + 1;
            }
        }

        // Adjust end to word boundary
        if (end < bodyText.Length)
        {
            var wordEnd = bodyText.IndexOf(' ', end);
            if (wordEnd > 0)
            {
                end = wordEnd;
            }
        }

        var snippet = new StringBuilder();
        if (start > 0)
        {
            snippet.Append("...");
        }

        snippet.Append(bodyText.AsSpan(start, end - start));

        if (end < bodyText.Length)
        {
            snippet.Append("...");
        }

        return snippet.ToString();
    }

    private static string Truncate(string text, int maxLength)
    {
        if (text.Length <= maxLength)
        {
            return text;
        }

        var truncated = text[..maxLength];
        var lastSpace = truncated.LastIndexOf(' ');
        if (lastSpace > maxLength / 2)
        {
            truncated = truncated[..lastSpace];
        }

        return truncated + "...";
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/Fts5HelperTests.cs
SIZE: 1.68 KB
MODIFIED: 2025-12-31 17:56:07
================================================================================

using MyEmailSearch.Data;

namespace MyEmailSearch.Tests.Data;

public class Fts5HelperTests
{
    [Test]
    public async Task PrepareFts5MatchQuery_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery(null);

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithEmptyString_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("");

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWhitespace_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("   ");

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWildcard_PreservesWildcard()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("test*");

        await Assert.That(result).IsEqualTo("\"test\"*");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithoutWildcard_WrapsInQuotes()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("test query");

        await Assert.That(result).IsEqualTo("\"test query\"");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithFts5Operators_EscapesThem()
    {
        // Users shouldn't be able to inject FTS5 operators like OR, AND, NOT
        var result = SearchDatabase.PrepareFts5MatchQuery("test OR hack");

        await Assert.That(result).IsEqualTo("\"test OR hack\"");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithParentheses_EscapesThem()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("(test)");

        await Assert.That(result).IsEqualTo("\"(test)\"");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseEscapingTests.cs
SIZE: 0.94 KB
MODIFIED: 2025-12-31 18:02:42
================================================================================

namespace MyEmailSearch.Tests.Data;

using MyEmailSearch.Data;

public class SearchDatabaseEscapingTests
{
    [Test]
    public async Task EscapeFts5Query_WithSpecialCharacters_EscapesCorrectly()
    {
        var result = SearchDatabase.EscapeFts5Query("test\"query");

        await Assert.That(result).IsEqualTo("\"test\"\"query\"");
    }

    [Test]
    public async Task EscapeFts5Query_WithNormalText_WrapsInQuotes()
    {
        var result = SearchDatabase.EscapeFts5Query("hello world");

        await Assert.That(result).IsEqualTo("\"hello world\"");
    }

    [Test]
    public async Task EscapeFts5Query_WithEmptyString_ReturnsEmpty()
    {
        var result = SearchDatabase.EscapeFts5Query("");

        await Assert.That(result).IsEqualTo("");
    }

    [Test]
    public async Task EscapeFts5Query_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.EscapeFts5Query(null);

        await Assert.That(result).IsNull();
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseTests.cs
SIZE: 3.68 KB
MODIFIED: 2025-12-31 17:56:33
================================================================================

using Microsoft.Extensions.Logging.Abstractions;
using MyEmailSearch.Data;

namespace MyEmailSearch.Tests.Data;

public class SearchDatabaseTests : IAsyncDisposable
{
    private readonly string _dbPath;
    private readonly SearchDatabase _database;

    public SearchDatabaseTests()
    {
        _dbPath = Path.Combine(Path.GetTempPath(), $"test_{Guid.NewGuid():N}.db");
        _database = new SearchDatabase(_dbPath, NullLogger<SearchDatabase>.Instance);
    }

    [Test]
    public async Task Initialize_CreatesDatabase()
    {
        await _database.InitializeAsync();

        await Assert.That(File.Exists(_dbPath)).IsTrue();
    }

    [Test]
    public async Task UpsertEmail_InsertsNewEmail()
    {
        await _database.InitializeAsync();

        var email = CreateTestEmail("test-1@example.com");
        await _database.UpsertEmailAsync(email);

        var count = await _database.GetEmailCountAsync();
        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task UpsertEmail_UpdatesExistingEmail()
    {
        await _database.InitializeAsync();

        var email1 = CreateTestEmail("test-1@example.com", "Original");
        await _database.UpsertEmailAsync(email1);

        var email2 = CreateTestEmail("test-1@example.com", "Updated");
        await _database.UpsertEmailAsync(email2);

        var count = await _database.GetEmailCountAsync();
        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task EmailExists_ReturnsTrueForExistingEmail()
    {
        await _database.InitializeAsync();

        var email = CreateTestEmail("test-exists@example.com");
        await _database.UpsertEmailAsync(email);

        var exists = await _database.EmailExistsAsync("test-exists@example.com");
        await Assert.That(exists).IsTrue();
    }

    [Test]
    public async Task EmailExists_ReturnsFalseForNonExistingEmail()
    {
        await _database.InitializeAsync();

        var exists = await _database.EmailExistsAsync("nonexistent@example.com");
        await Assert.That(exists).IsFalse();
    }

    [Test]
    public async Task Query_ByFromAddress_ReturnsMatchingEmails()
    {
        await _database.InitializeAsync();

        await _database.UpsertEmailAsync(CreateTestEmail("test-1", fromAddress: "alice@example.com"));
        await _database.UpsertEmailAsync(CreateTestEmail("test-2", fromAddress: "bob@example.com"));
        await _database.UpsertEmailAsync(CreateTestEmail("test-3", fromAddress: "alice@example.com"));

        var query = new SearchQuery { FromAddress = "alice@example.com" };
        var results = await _database.QueryAsync(query);

        await Assert.That(results.Count).IsEqualTo(2);
    }

    [Test]
    public async Task IsHealthy_ReturnsTrueForHealthyDatabase()
    {
        await _database.InitializeAsync();

        var healthy = await _database.IsHealthyAsync();

        await Assert.That(healthy).IsTrue();
    }

    private static EmailDocument CreateTestEmail(
        string messageId,
        string? subject = "Test Subject",
        string? fromAddress = "sender@example.com") => new()
        {
            MessageId = messageId,
            FilePath = $"/test/{messageId}.eml",
            FromAddress = fromAddress,
            Subject = subject,
            DateSentUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        };

    public async ValueTask DisposeAsync()
    {
        await _database.DisposeAsync();

        try
        {
            if (File.Exists(_dbPath)) File.Delete(_dbPath);
            if (File.Exists(_dbPath + "-wal")) File.Delete(_dbPath + "-wal");
            if (File.Exists(_dbPath + "-shm")) File.Delete(_dbPath + "-shm");
        }
        catch { /* Ignore cleanup errors */ }
    }
}


================================================================================
FILE: MyEmailSearch.Tests/MyEmailSearch.Tests.csproj
SIZE: 1.25 KB
MODIFIED: 2025-12-31 09:04:02
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyEmailSearch.Tests - Unit and Integration Tests
    
    Uses TUnit as the test framework (MIT licensed, modern, source-generated)
    Uses NSubstitute for mocking (MIT licensed)
    
    Note: IsPackable=false is set in Directory.Build.props for all *.Tests projects
  -->
  
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TUnit requires Exe output type for its source generators -->
  </PropertyGroup>

  <ItemGroup>
    <!-- Test Framework -->
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    
    <!-- For testing configuration -->
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <!-- Reference the main project -->
    <ProjectReference Include="..\MyEmailSearch\MyEmailSearch.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- Include test fixtures (sample emails, etc.) -->
    <None Update="TestFixtures\**\*">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: MyEmailSearch.Tests/Search/QueryParserTests.cs
SIZE: 2.88 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

public class QueryParserTests
{
    private readonly QueryParser _parser = new();

    [Test]
    public async Task Parse_SimpleFromQuery_ExtractsFromAddress()
    {
        var query = _parser.Parse("from:alice@example.com");

        await Assert.That(query.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(query.ContentTerms).IsNull();
    }

    [Test]
    public async Task Parse_QuotedSubject_ExtractsSubject()
    {
        var query = _parser.Parse("subject:\"project update\"");

        await Assert.That(query.Subject).IsEqualTo("project update");
    }

    [Test]
    public async Task Parse_DateRange_ParsesBothDates()
    {
        var query = _parser.Parse("date:2024-01-01..2024-12-31");

        await Assert.That(query.DateFrom).IsNotNull();
        await Assert.That(query.DateFrom!.Value.Year).IsEqualTo(2024);
        await Assert.That(query.DateFrom!.Value.Month).IsEqualTo(1);
        await Assert.That(query.DateTo).IsNotNull();
        await Assert.That(query.DateTo!.Value.Year).IsEqualTo(2024);
        await Assert.That(query.DateTo!.Value.Month).IsEqualTo(12);
    }

    [Test]
    public async Task Parse_MixedQuery_ExtractsAllParts()
    {
        var query = _parser.Parse("from:alice@example.com subject:report kafka streaming");

        await Assert.That(query.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(query.Subject).IsEqualTo("report");
        await Assert.That(query.ContentTerms).IsEqualTo("kafka streaming");
    }

    [Test]
    public async Task Parse_WildcardFrom_PreservesWildcard()
    {
        var query = _parser.Parse("from:*@example.com");

        await Assert.That(query.FromAddress).IsEqualTo("*@example.com");
    }

    [Test]
    public async Task Parse_EmptyString_ReturnsEmptyQuery()
    {
        var query = _parser.Parse("");

        await Assert.That(query.FromAddress).IsNull();
        await Assert.That(query.ContentTerms).IsNull();
    }

    [Test]
    public async Task Parse_ContentOnly_ExtractsContentTerms()
    {
        var query = _parser.Parse("kafka streaming message broker");

        await Assert.That(query.ContentTerms).IsEqualTo("kafka streaming message broker");
        await Assert.That(query.FromAddress).IsNull();
    }

    [Test]
    public async Task Parse_ToAddress_ExtractsToAddress()
    {
        var query = _parser.Parse("to:bob@example.com");

        await Assert.That(query.ToAddress).IsEqualTo("bob@example.com");
    }

    [Test]
    public async Task Parse_AccountFilter_ExtractsAccount()
    {
        var query = _parser.Parse("account:work_backup");

        await Assert.That(query.Account).IsEqualTo("work_backup");
    }

    [Test]
    public async Task Parse_FolderFilter_ExtractsFolder()
    {
        var query = _parser.Parse("folder:INBOX");

        await Assert.That(query.Folder).IsEqualTo("INBOX");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/SnippetGeneratorTests.cs
SIZE: 1.45 KB
MODIFIED: 2025-12-31 10:38:38
================================================================================

using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

public class SnippetGeneratorTests
{
    private readonly SnippetGenerator _generator = new();

    [Test]
    public async Task Generate_WithMatchingTerm_ReturnsContextAroundMatch()
    {
        var bodyText = "This is a long email body that contains the word kafka somewhere in the middle of the text.";
        var searchTerms = "kafka";

        var snippet = _generator.Generate(bodyText, searchTerms);

        await Assert.That(snippet).IsNotNull();
        await Assert.That(snippet!.Contains("kafka", StringComparison.OrdinalIgnoreCase)).IsTrue();
    }

    [Test]
    public async Task Generate_WithNoMatch_ReturnsBeginningOfText()
    {
        var bodyText = "This is a long email body without any matching terms.";
        var searchTerms = "nonexistent";

        var snippet = _generator.Generate(bodyText, searchTerms);

        await Assert.That(snippet).IsNotNull();
        await Assert.That(snippet!.StartsWith("This")).IsTrue();
    }

    [Test]
    public async Task Generate_WithNullBody_ReturnsNull()
    {
        var snippet = _generator.Generate(null, "test");

        await Assert.That(snippet).IsNull();
    }

    [Test]
    public async Task Generate_WithEmptySearchTerms_ReturnsTruncatedBody()
    {
        var bodyText = "This is a test email body.";

        var snippet = _generator.Generate(bodyText, null);

        await Assert.That(snippet).IsEqualTo(bodyText);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/SmokeTests.cs
SIZE: 0.70 KB
MODIFIED: 2025-12-31 17:56:07
================================================================================

using MyEmailSearch.Search;

namespace MyEmailSearch.Tests;

/// <summary>
/// Basic smoke tests to verify the project builds and runs.
/// </summary>
public class SmokeTests
{
    [Test]
    public async Task Project_Builds_Successfully()
    {
        // This test passes if the project compiles
        var result = 1 + 1;
        await Assert.That(result).IsEqualTo(2);
    }

    [Test]
    public async Task Can_Create_QueryParser()
    {
        var parser = new QueryParser();
        await Assert.That(parser).IsNotNull();
    }

    [Test]
    public async Task Can_Create_SnippetGenerator()
    {
        var generator = new SnippetGenerator();
        await Assert.That(generator).IsNotNull();
    }
}


================================================================================
FILE: MyImapDownloader/appsettings.json
SIZE: 0.43 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

{
  "Telemetry": {
    "ServiceName": "MyImapDownloader",
    "ServiceVersion": "1.0.0",
    "OutputDirectory": "telemetry",
    "MaxFileSizeMB": 25,
    "EnableTracing": true,
    "EnableMetrics": true,
    "EnableLogging": true,
    "FlushIntervalSeconds": 5,
    "MetricsExportIntervalSeconds": 15
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}


================================================================================
FILE: MyImapDownloader/DownloadOptions.cs
SIZE: 1.25 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿using CommandLine;

namespace MyImapDownloader;

public class DownloadOptions
{
    [Option('s', "server", Required = true, HelpText = "IMAP server address")]
    public required string Server { get; set; }

    [Option('u', "username", Required = true, HelpText = "Email username")]
    public required string Username { get; set; }

    [Option('p', "password", Required = true, HelpText = "Email password")]
    public required string Password { get; set; }

    [Option('r', "port", Default = 993, HelpText = "IMAP port (default: 993)")]
    public int Port { get; set; } = 993;

    [Option('o', "output", Default = "EmailArchive", HelpText = "Output directory for archived emails")]
    public required string OutputDirectory { get; set; }

    [Option("start-date", HelpText = "Download emails from this date (yyyy-MM-dd)")]
    public DateTime? StartDate { get; set; }

    [Option("end-date", HelpText = "Download emails until this date (yyyy-MM-dd)")]
    public DateTime? EndDate { get; set; }

    [Option('a', "all-folders", Default = false, HelpText = "Download from all folders, not just INBOX")]
    public bool AllFolders { get; set; }

    [Option('v', "verbose", Default = false, HelpText = "Enable verbose logging")]
    public bool Verbose { get; set; }
}


================================================================================
FILE: MyImapDownloader/EmailDownloadException.cs
SIZE: 0.24 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿namespace MyImapDownloader;

// Custom Exceptions
public class EmailDownloadException(string message, int messageIndex, Exception innerException)
    : Exception(message, innerException)
{
    public int MessageIndex { get; } = messageIndex;
}


================================================================================
FILE: MyImapDownloader/EmailDownloadService.cs
SIZE: 8.04 KB
MODIFIED: 2025-12-23 05:07:01
================================================================================

﻿using System.Diagnostics;
using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MailKit.Security;
using Microsoft.Extensions.Logging;
using MyImapDownloader.Telemetry;
using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;

namespace MyImapDownloader;

public class EmailDownloadService
{
    private readonly ILogger<EmailDownloadService> _logger;
    private readonly ImapConfiguration _config;
    private readonly EmailStorageService _storage;
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    public EmailDownloadService(
        ILogger<EmailDownloadService> logger,
        ImapConfiguration config,
        EmailStorageService storage)
    {
        _logger = logger;
        _config = config;
        _storage = storage;

        _retryPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .WaitAndRetryForeverAsync(
                retryAttempt => TimeSpan.FromSeconds(Math.Min(Math.Pow(2, retryAttempt), 300)),
                (exception, retryCount, timeSpan) =>
                {
                    _logger.LogWarning("Retry {Count} in {Delay}: {Message}", retryCount, timeSpan, exception.Message);
                });

        _circuitBreakerPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .CircuitBreakerAsync(5, TimeSpan.FromMinutes(2));
    }

    public async Task DownloadEmailsAsync(DownloadOptions options, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("DownloadEmails");

        // Ensure Storage/DB is ready
        await _storage.InitializeAsync(ct);

        var policy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);

        await policy.ExecuteAsync(async () =>
        {
            using var client = new ImapClient { Timeout = 180_000 };
            try
            {
                await ConnectAndAuthenticateAsync(client, ct);

                var folders = options.AllFolders
                    ? await GetAllFoldersAsync(client, ct)
                    : [client.Inbox];

                foreach (var folder in folders)
                {
                    await ProcessFolderAsync(folder, options, ct);
                }
            }
            finally
            {
                if (client.IsConnected) await client.DisconnectAsync(true, ct);
            }
        });
    }

    private async Task ProcessFolderAsync(IMailFolder folder, DownloadOptions options, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("ProcessFolder");
        activity?.SetTag("folder", folder.FullName);

        try
        {
            await folder.OpenAsync(FolderAccess.ReadOnly, ct);

            // DELTA SYNC STRATEGY
            // 1. Get the last UID we successfully processed for this folder
            long lastUidVal = await _storage.GetLastUidAsync(folder.FullName, folder.UidValidity, ct);
            UniqueId? startUid = lastUidVal > 0 ? new UniqueId((uint)lastUidVal) : null;

            _logger.LogInformation("Syncing {Folder}. Last UID: {Uid}", folder.FullName, startUid);

            // 2. Search only for newer items
            var query = SearchQuery.All;
            if (startUid.HasValue)
            {
                // FIX: Use SearchQuery.Uids with a UniqueIdRange instead of SearchQuery.Uid
                // Fetch everything strictly greater than last seen
                var range = new UniqueIdRange(new UniqueId(startUid.Value.Id + 1), UniqueId.MaxValue);
                query = SearchQuery.Uids(range);
            }
            // Overrides for manual date ranges
            if (options.StartDate.HasValue) query = query.And(SearchQuery.DeliveredAfter(options.StartDate.Value));
            if (options.EndDate.HasValue) query = query.And(SearchQuery.DeliveredBefore(options.EndDate.Value));

            var uids = await folder.SearchAsync(query, ct);
            _logger.LogInformation("Found {Count} new messages in {Folder}", uids.Count, folder.FullName);

            // 3. Process in batches
            int batchSize = 50;
            for (int i = 0; i < uids.Count; i += batchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = uids.Skip(i).Take(batchSize).ToList();
                long maxUidInBatch = await DownloadBatchAsync(folder, batch, ct);

                // 4. Update checkpoint after successful batch
                if (maxUidInBatch > 0)
                {
                    // FIX: folder.UidValidity is a uint, it does not have an .Id property
                    await _storage.UpdateLastUidAsync(folder.FullName, maxUidInBatch, folder.UidValidity, ct);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing folder {Folder}", folder.FullName);
            throw; // Let Polly handle retry
        }
    }

    private async Task<long> DownloadBatchAsync(IMailFolder folder, IList<UniqueId> uids, CancellationToken ct)
    {
        long maxUid = 0;

        // 1. Fetch Envelopes first (PEEK) - lightweight
        var items = await folder.FetchAsync(uids, MessageSummaryItems.Envelope | MessageSummaryItems.UniqueId | MessageSummaryItems.InternalDate, ct);

        foreach (var item in items)
        {
            using var activity = DiagnosticsConfig.ActivitySource.StartActivity("ProcessEmail");

            // Track max UID for checkpointing
            if (item.UniqueId.Id > maxUid) maxUid = item.UniqueId.Id;

            // 2. Check DB before downloading body
            // Note: Imap Message-ID can be null, handle gracefully
            string msgId = item.Envelope.MessageId ?? $"NO-ID-{item.InternalDate?.Ticks}";

            if (await _storage.ExistsAsync(msgId, ct))
            {
                _logger.LogDebug("Skipping duplicate {Id}", msgId);
                continue;
            }

            // 3. Stream body
            try
            {
                using var stream = await folder.GetStreamAsync(item.UniqueId, ct);
                // FIX: Handle potential null MessageId explicitly to silence warning CS8604
                bool isNew = await _storage.SaveStreamAsync(
                    stream,
                    item.Envelope.MessageId ?? string.Empty,
                    item.InternalDate ?? DateTimeOffset.UtcNow,
                    folder.FullName,
                    ct);

                if (isNew) _logger.LogInformation("Downloaded: {Subject}", item.Envelope.Subject);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to download UID {Uid}", item.UniqueId);
                // We do NOT stop the batch for one failed email, but we might not want to update the cursor 
                // past this point if we want to retry it later. 
                // For simplicity in this script, we log and continue.
            }
        }

        return maxUid;
    }

    private async Task ConnectAndAuthenticateAsync(ImapClient client, CancellationToken ct)
    {
        _logger.LogInformation("Connecting to {Server}:{Port}", _config.Server, _config.Port);
        await client.ConnectAsync(_config.Server, _config.Port, SecureSocketOptions.SslOnConnect, ct);
        await client.AuthenticateAsync(_config.Username, _config.Password, ct);
    }

    private async Task<List<IMailFolder>> GetAllFoldersAsync(ImapClient client, CancellationToken ct)
    {
        var folders = new List<IMailFolder>();
        var personal = client.GetFolder(client.PersonalNamespaces[0]);
        await CollectFoldersRecursiveAsync(personal, folders, ct);
        if (!folders.Contains(client.Inbox)) folders.Insert(0, client.Inbox);
        return folders;
    }

    private async Task CollectFoldersRecursiveAsync(IMailFolder parent, List<IMailFolder> folders, CancellationToken ct)
    {
        foreach (var folder in await parent.GetSubfoldersAsync(false, ct))
        {
            folders.Add(folder);
            await CollectFoldersRecursiveAsync(folder, folders, ct);
        }
    }
}


================================================================================
FILE: MyImapDownloader/EmailMetadata.cs
SIZE: 0.39 KB
MODIFIED: 2025-12-23 04:59:40
================================================================================

namespace MyImapDownloader;

public class EmailMetadata
{
    public required string MessageId { get; set; }
    public string? Subject { get; set; }
    public string? From { get; set; }
    public string? To { get; set; }
    public DateTime Date { get; set; }
    public required string Folder { get; set; }
    public DateTime ArchivedAt { get; set; }
    public bool HasAttachments { get; set; }
}


================================================================================
FILE: MyImapDownloader/EmailStorageService.cs
SIZE: 13.27 KB
MODIFIED: 2025-12-23 04:55:49
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader;

public class EmailStorageService : IAsyncDisposable
{
    private readonly ILogger<EmailStorageService> _logger;
    private readonly string _baseDirectory;
    private readonly string _dbPath;
    private SqliteConnection? _connection;

    // Metrics
    private static readonly Counter<long> FilesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.files.written", unit: "files", description: "Number of email files written to disk");
    private static readonly Counter<long> BytesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.bytes.written", unit: "bytes", description: "Total bytes written to disk");
    private static readonly Histogram<double> WriteLatency = DiagnosticsConfig.Meter.CreateHistogram<double>(
        "storage.write.latency", unit: "ms", description: "Time to write email to disk");

    public EmailStorageService(ILogger<EmailStorageService> logger, string baseDirectory)
    {
        _logger = logger;
        _baseDirectory = baseDirectory;
        // Each output directory (account) gets its own isolated database
        _dbPath = Path.Combine(baseDirectory, "index.v1.db");
    }

    public async Task InitializeAsync(CancellationToken ct)
    {
        Directory.CreateDirectory(_baseDirectory);

        // Fault Tolerance: Try to open/init. If corrupt, back up and start over.
        try
        {
            await OpenAndMigrateAsync(ct);
        }
        catch (SqliteException ex)
        {
            _logger.LogError(ex, "Database corruption detected. Initiating recovery...");
            await RecoverDatabaseAsync(ct);
        }
    }

    private async Task OpenAndMigrateAsync(CancellationToken ct)
    {
        var connStr = new SqliteConnectionStringBuilder { DataSource = _dbPath }.ToString();
        _connection = new SqliteConnection(connStr);
        await _connection.OpenAsync(ct);

        // WAL mode for better concurrency
        using (var cmd = _connection.CreateCommand())
        {
            cmd.CommandText = "PRAGMA journal_mode = WAL; PRAGMA synchronous = NORMAL;";
            await cmd.ExecuteNonQueryAsync(ct);
        }

        using (var trans = await _connection.BeginTransactionAsync(ct))
        {
            var cmd = _connection.CreateCommand();
            cmd.Transaction = (SqliteTransaction)trans;
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS Messages (
                    MessageId TEXT PRIMARY KEY,
                    Folder TEXT NOT NULL,
                    ImportedAt TEXT NOT NULL
                );
                CREATE TABLE IF NOT EXISTS SyncState (
                    Folder TEXT PRIMARY KEY,
                    LastUid INTEGER NOT NULL,
                    UidValidity INTEGER NOT NULL
                );
                CREATE INDEX IF NOT EXISTS IX_Messages_Folder ON Messages(Folder);
            ";
            await cmd.ExecuteNonQueryAsync(ct);
            await trans.CommitAsync(ct);
        }
    }

    private async Task RecoverDatabaseAsync(CancellationToken ct)
    {
        if (_connection != null)
        {
            await _connection.DisposeAsync();
            _connection = null;
        }

        // 1. Move corrupt DB aside
        if (File.Exists(_dbPath))
        {
            var backupPath = _dbPath + $".corrupt.{DateTime.UtcNow.Ticks}";
            File.Move(_dbPath, backupPath);
            _logger.LogWarning("Moved corrupt database to {Path}", backupPath);
        }

        // 2. Create fresh DB
        await OpenAndMigrateAsync(ct);

        // 3. Rebuild from disk (Source of Truth)
        _logger.LogInformation("Rebuilding index from disk...");
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("RebuildIndex");
        int count = 0;

        // Scan all .meta.json files
        foreach (var metaFile in Directory.EnumerateFiles(_baseDirectory, "*.meta.json", SearchOption.AllDirectories))
        {
            try
            {
                var json = await File.ReadAllTextAsync(metaFile, ct);
                var meta = JsonSerializer.Deserialize<EmailMetadata>(json);
                if (!string.IsNullOrEmpty(meta?.MessageId) && !string.IsNullOrEmpty(meta.Folder))
                {
                    // Insert without validation to recover fast
                    await InsertMessageRecordAsync(meta.MessageId, meta.Folder, ct);
                    count++;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Skipping malformed meta file {File}: {Error}", metaFile, ex.Message);
            }
        }

        _logger.LogInformation("Recovery complete. Re-indexed {Count} emails.", count);
    }

    public async Task<long> GetLastUidAsync(string folderName, long currentValidity, CancellationToken ct)
    {
        if (_connection == null) await InitializeAsync(ct);

        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT LastUid, UidValidity FROM SyncState WHERE Folder = @folder";
        cmd.Parameters.AddWithValue("@folder", folderName);

        using var reader = await cmd.ExecuteReaderAsync(ct);
        if (await reader.ReadAsync(ct))
        {
            long storedValidity = reader.GetInt64(1);
            if (storedValidity == currentValidity)
            {
                return reader.GetInt64(0);
            }
            else
            {
                _logger.LogWarning("UIDVALIDITY changed for {Folder}. Resetting cursor.", folderName);
                return 0;
            }
        }
        return 0;
    }

    public async Task UpdateLastUidAsync(string folderName, long lastUid, long validity, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = @"
            INSERT INTO SyncState (Folder, LastUid, UidValidity) 
            VALUES (@folder, @uid, @validity)
            ON CONFLICT(Folder) DO UPDATE SET 
                LastUid = @uid, 
                UidValidity = @validity
            WHERE LastUid < @uid OR UidValidity != @validity;";

        cmd.Parameters.AddWithValue("@folder", folderName);
        cmd.Parameters.AddWithValue("@uid", lastUid);
        cmd.Parameters.AddWithValue("@validity", validity);
        await cmd.ExecuteNonQueryAsync(ct);
    }

    public async Task<bool> ExistsAsync(string messageId, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(messageId)) return false;

        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT 1 FROM Messages WHERE MessageId = @id LIMIT 1";
        cmd.Parameters.AddWithValue("@id", NormalizeMessageId(messageId));
        return (await cmd.ExecuteScalarAsync(ct)) != null;
    }

    /// <summary>
    /// Streams an email to disk. Returns true if saved, false if duplicate.
    /// </summary>
    public async Task<bool> SaveStreamAsync(
        Stream networkStream,
        string messageId,
        DateTimeOffset internalDate,
        string folderName,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("SaveStream");
        var sw = Stopwatch.StartNew();

        string safeId = string.IsNullOrWhiteSpace(messageId)
            ? ComputeHash(internalDate.ToString())
            : NormalizeMessageId(messageId);

        // 1. Double check DB (fast)
        if (await ExistsAsync(safeId, ct)) return false;

        string folderPath = GetFolderPath(folderName);
        EnsureMaildirStructure(folderPath);

        // 2. Stream to TMP file (atomic write pattern)
        string tempName = $"{internalDate.ToUnixTimeSeconds()}.{Guid.NewGuid()}.tmp";
        string tempPath = Path.Combine(folderPath, "tmp", tempName);

        long bytesWritten = 0;
        EmailMetadata? metadata = null;

        try
        {
            // Stream network -> disk directly (Low RAM usage)
            using (var fileStream = File.Create(tempPath))
            {
                await networkStream.CopyToAsync(fileStream, ct);
                bytesWritten = fileStream.Length;
            }

            // 3. Parse headers only from the file on disk to get metadata
            // We use MimeKit to parse just the headers, stopping at the body
            using (var fileStream = File.OpenRead(tempPath))
            {
                var parser = new MimeParser(fileStream, MimeFormat.Entity);
                var message = await parser.ParseMessageAsync(ct);

                // If ID was missing in Envelope, try to get it from parsed headers
                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(message.MessageId))
                {
                    safeId = NormalizeMessageId(message.MessageId);
                    // Re-check existence with the real ID
                    if (await ExistsAsync(safeId, ct))
                    {
                        File.Delete(tempPath);
                        return false;
                    }
                }

                metadata = new EmailMetadata
                {
                    MessageId = safeId,
                    Subject = message.Subject,
                    From = message.From?.ToString(),
                    To = message.To?.ToString(),
                    Date = message.Date.UtcDateTime,
                    Folder = folderName,
                    ArchivedAt = DateTime.UtcNow,
                    HasAttachments = message.Attachments.Any() // This might require parsing body, careful
                };
            }

            // 4. Move to CUR
            string finalName = GenerateFilename(internalDate, safeId);
            string finalPath = Path.Combine(folderPath, "cur", finalName);

            // Handle race condition if file exists (hash collision or race)
            if (File.Exists(finalPath))
            {
                File.Delete(tempPath);
                // Even if file exists on disk, ensure DB knows about it
                await InsertMessageRecordAsync(safeId, folderName, ct);
                return false;
            }

            File.Move(tempPath, finalPath);

            // 5. Write Sidecar
            if (metadata != null)
            {
                string metaPath = finalPath + ".meta.json";
                await using var metaStream = File.Create(metaPath);
                await JsonSerializer.SerializeAsync(metaStream, metadata, new JsonSerializerOptions { WriteIndented = true }, ct);
            }

            // 6. Update DB
            await InsertMessageRecordAsync(safeId, folderName, ct);

            sw.Stop();
            FilesWritten.Add(1);
            BytesWritten.Add(bytesWritten);
            WriteLatency.Record(sw.Elapsed.TotalMilliseconds);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save email {Id}", safeId);
            try { if (File.Exists(tempPath)) File.Delete(tempPath); } catch { }
            throw;
        }
    }

    private async Task InsertMessageRecordAsync(string messageId, string folder, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "INSERT OR IGNORE INTO Messages (MessageId, Folder, ImportedAt) VALUES (@id, @folder, @date)";
        cmd.Parameters.AddWithValue("@id", messageId);
        cmd.Parameters.AddWithValue("@folder", folder);
        cmd.Parameters.AddWithValue("@date", DateTime.UtcNow.ToString("O"));
        await cmd.ExecuteNonQueryAsync(ct);
    }

    private string GetFolderPath(string folderName)
    {
        string safeName = SanitizeForFilename(folderName, 100);
        return Path.Combine(_baseDirectory, safeName);
    }

    private static void EnsureMaildirStructure(string folderPath)
    {
        Directory.CreateDirectory(Path.Combine(folderPath, "cur"));
        Directory.CreateDirectory(Path.Combine(folderPath, "new"));
        Directory.CreateDirectory(Path.Combine(folderPath, "tmp"));
    }

    private static string GenerateFilename(DateTimeOffset date, string safeId)
    {
        string hostname = SanitizeForFilename(Environment.MachineName, 20);
        return $"{date.ToUnixTimeSeconds()}.{safeId}.{hostname}:2,S.eml";
    }

    private static string NormalizeMessageId(string messageId)
    {
        return messageId?.Trim().Trim('<', '>').ToLowerInvariant() ?? "unknown";
    }

    private static string ComputeHash(string input)
    {
        byte[] bytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));
        return Convert.ToHexString(bytes)[..16].ToLowerInvariant();
    }

    private static string SanitizeForFilename(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input)) return "unknown";
        var sb = new StringBuilder(Math.Min(input.Length, maxLength));
        foreach (char c in input)
        {
            if (char.IsLetterOrDigit(c) || c == '-' || c == '_' || c == '.') sb.Append(c);
            else if (sb.Length > 0 && sb[^1] != '_') sb.Append('_');
            if (sb.Length >= maxLength) break;
        }
        return sb.ToString().Trim('_');
    }

    public async ValueTask DisposeAsync()
    {
        if (_connection != null)
        {
            await _connection.DisposeAsync();
        }
    }
}


================================================================================
FILE: MyImapDownloader/ImapConfiguration.cs
SIZE: 0.31 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿namespace MyImapDownloader;

// Configuration Model
public class ImapConfiguration
{
    public required string Server { get; set; }
    public int Port { get; set; }
    public required string Username { get; set; }
    public required string Password { get; set; }
    public bool UseSsl { get; set; } = true;
}


================================================================================
FILE: MyImapDownloader/MyImapDownloader.csproj
SIZE: 1.14 KB
MODIFIED: 2025-12-23 04:50:11
================================================================================

﻿<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CommandLineParser" />
    <PackageReference Include="MailKit" />
    <PackageReference Include="Microsoft.Data.Sqlite" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    <PackageReference Include="Polly" />
  </ItemGroup>
  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>

================================================================================
FILE: MyImapDownloader/Program.cs
SIZE: 4.33 KB
MODIFIED: 2025-12-23 05:01:42
================================================================================

﻿using System.Diagnostics;
using CommandLine;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyImapDownloader;
using MyImapDownloader.Telemetry;

var parseResult = Parser.Default.ParseArguments<DownloadOptions>(args);

await parseResult.WithParsedAsync(async options =>
{
    var host = Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, config) =>
        {
            config.SetBasePath(AppContext.BaseDirectory);
            config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((context, logging) =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.SetMinimumLevel(options.Verbose ? LogLevel.Debug : LogLevel.Information);
            logging.AddTelemetryLogging(context.Configuration);
        })
        .ConfigureServices((context, services) =>
        {
            // Add telemetry
            services.AddTelemetry(context.Configuration);

            services.AddSingleton(options);
            services.AddSingleton(new ImapConfiguration
            {
                Server = options.Server,
                Username = options.Username,
                Password = options.Password,
                Port = options.Port
            });
            services.AddSingleton(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<EmailStorageService>>();
                return new EmailStorageService(logger, options.OutputDirectory);
            });
            services.AddTransient<EmailDownloadService>();
        })
        .Build();

    var downloadService = host.Services.GetRequiredService<EmailDownloadService>();
    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    var telemetryConfig = host.Services.GetRequiredService<TelemetryConfiguration>();

    // Create root activity for the entire session
    using var rootActivity = DiagnosticsConfig.ActivitySource.StartActivity(
        "EmailArchiveSession", ActivityKind.Server);

    rootActivity?.SetTag("service.name", telemetryConfig.ServiceName);
    rootActivity?.SetTag("service.version", telemetryConfig.ServiceVersion);
    rootActivity?.SetTag("host.name", Environment.MachineName);
    rootActivity?.SetTag("process.pid", Environment.ProcessId);
    rootActivity?.SetTag("telemetry.directory", telemetryConfig.OutputDirectory);

    var sessionStopwatch = Stopwatch.StartNew();

    try
    {
        logger.LogInformation("Starting email archive download...");
        logger.LogInformation("Output: {Output}", Path.GetFullPath(options.OutputDirectory));
        logger.LogInformation("Telemetry output: {TelemetryOutput}",
            Path.GetFullPath(telemetryConfig.OutputDirectory));

        rootActivity?.AddEvent(new ActivityEvent("DownloadStarted"));

        await downloadService.DownloadEmailsAsync(options, CancellationToken.None);

        sessionStopwatch.Stop();

        rootActivity?.SetTag("session_duration_ms", sessionStopwatch.ElapsedMilliseconds);
        rootActivity?.SetStatus(ActivityStatusCode.Ok);
        rootActivity?.AddEvent(new ActivityEvent("DownloadCompleted"));

        logger.LogInformation("Archive complete! Session duration: {Duration}ms",
            sessionStopwatch.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        rootActivity?.SetStatus(ActivityStatusCode.Error, ex.Message);
        rootActivity?.RecordException(ex);
        rootActivity?.AddEvent(new ActivityEvent("DownloadFailed", tags: new ActivityTagsCollection
        {
            ["exception.type"] = ex.GetType().FullName,
            ["exception.message"] = ex.Message
        }));

        logger.LogCritical(ex, "Fatal error during download");
        Environment.ExitCode = 1;
    }
    finally
    {
        // Ensure all telemetry is flushed before exit
        logger.LogInformation("Flushing telemetry data...");

        // Give time for async exporters to flush
        await Task.Delay(TimeSpan.FromSeconds(2));

        // Dispose file writers to flush remaining data
        var traceWriter = host.Services.GetService<JsonTelemetryFileWriter>();
        traceWriter?.Dispose();
    }
});

parseResult.WithNotParsed(errors =>
{
    Environment.ExitCode = 1;
});


================================================================================
FILE: MyImapDownloader.slnx
SIZE: 0.68 KB
MODIFIED: 2025-12-31 09:03:28
================================================================================

﻿<Solution>
  <Folder Name="/Solution Items/">
    <File Path="Directory.Build.props" />
    <File Path="Directory.Build.targets" />
    <File Path="Directory.Packages.props" />
    <File Path="global.json" />
    <File Path="README.md" />
    <File Path=".gitignore" />
    <File Path="LICENSE" />
  </Folder>
  
  <Folder Name="/MyImapDownloader/">
    <Project Path="MyImapDownloader/MyImapDownloader.csproj" />
    <Project Path="MyImapDownloader.Tests/MyImapDownloader.Tests.csproj" />
  </Folder>
  
  <Folder Name="/MyEmailSearch/">
    <Project Path="MyEmailSearch/MyEmailSearch.csproj" />
    <Project Path="MyEmailSearch.Tests/MyEmailSearch.Tests.csproj" />
  </Folder>
</Solution>

================================================================================
FILE: MyImapDownloader/Telemetry/ActivityExtension.cs
SIZE: 1.29 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for Activity to provide RecordException functionality
/// that works across OpenTelemetry versions.
/// </summary>
public static class ActivityExtensions
{
    /// <summary>
    /// Records an exception as an event on the activity with standard attributes.
    /// </summary>
    public static void RecordException(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        var tags = new ActivityTagsCollection
        {
            ["exception.type"] = exception.GetType().FullName,
            ["exception.message"] = exception.Message,
        };

        if (!string.IsNullOrEmpty(exception.StackTrace))
        {
            tags["exception.stacktrace"] = exception.StackTrace;
        }

        activity.AddEvent(new ActivityEvent("exception", tags: tags));
    }

    /// <summary>
    /// Sets the activity status to error with the exception message.
    /// </summary>
    public static void SetErrorStatus(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
        activity.RecordException(exception);
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/DiagnosticsConfig.cs
SIZE: 4.21 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Central configuration for all diagnostics sources used in the application.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyImapDownloader";
    public const string ServiceVersion = "1.0.0";

    // ActivitySource for distributed tracing
    public static readonly ActivitySource ActivitySource = new(ServiceName, ServiceVersion);

    // Meter for metrics
    public static readonly Meter Meter = new(ServiceName, ServiceVersion);

    // Counters
    public static readonly Counter<long> EmailsDownloaded = Meter.CreateCounter<long>(
        "emails.downloaded",
        unit: "emails",
        description: "Total number of emails successfully downloaded");

    public static readonly Counter<long> EmailsSkipped = Meter.CreateCounter<long>(
        "emails.skipped",
        unit: "emails",
        description: "Number of emails skipped (duplicates)");

    public static readonly Counter<long> EmailErrors = Meter.CreateCounter<long>(
        "emails.errors",
        unit: "errors",
        description: "Number of email download errors");

    public static readonly Counter<long> BytesDownloaded = Meter.CreateCounter<long>(
        "bytes.downloaded",
        unit: "bytes",
        description: "Total bytes downloaded");

    public static readonly Counter<long> FoldersProcessed = Meter.CreateCounter<long>(
        "folders.processed",
        unit: "folders",
        description: "Number of folders processed");

    public static readonly Counter<long> ConnectionAttempts = Meter.CreateCounter<long>(
        "connection.attempts",
        unit: "attempts",
        description: "Number of IMAP connection attempts");

    public static readonly Counter<long> RetryAttempts = Meter.CreateCounter<long>(
        "retry.attempts",
        unit: "retries",
        description: "Number of retry attempts due to failures");

    // Histograms
    public static readonly Histogram<double> EmailDownloadDuration = Meter.CreateHistogram<double>(
        "email.download.duration",
        unit: "ms",
        description: "Time taken to download individual emails");

    public static readonly Histogram<double> FolderProcessingDuration = Meter.CreateHistogram<double>(
        "folder.processing.duration",
        unit: "ms",
        description: "Time taken to process entire folders");

    public static readonly Histogram<double> BatchProcessingDuration = Meter.CreateHistogram<double>(
        "batch.processing.duration",
        unit: "ms",
        description: "Time taken to process email batches");

    public static readonly Histogram<long> EmailSize = Meter.CreateHistogram<long>(
        "email.size",
        unit: "bytes",
        description: "Size of downloaded emails");

    // Gauges (using ObservableGauge for current state)
    private static int _activeConnections;
    private static int _queuedEmails;
    private static long _totalEmailsInSession;

    public static readonly ObservableGauge<int> ActiveConnections = Meter.CreateObservableGauge(
        "connections.active",
        () => _activeConnections,
        unit: "connections",
        description: "Number of active IMAP connections");

    public static readonly ObservableGauge<int> QueuedEmails = Meter.CreateObservableGauge(
        "emails.queued",
        () => _queuedEmails,
        unit: "emails",
        description: "Number of emails queued for processing");

    public static readonly ObservableGauge<long> TotalEmailsInSession = Meter.CreateObservableGauge(
        "emails.total.session",
        () => _totalEmailsInSession,
        unit: "emails",
        description: "Total emails processed in current session");

    // Methods to update gauge values
    public static void SetActiveConnections(int count) => _activeConnections = count;
    public static void IncrementActiveConnections() => Interlocked.Increment(ref _activeConnections);
    public static void DecrementActiveConnections() => Interlocked.Decrement(ref _activeConnections);
    public static void SetQueuedEmails(int count) => _queuedEmails = count;
    public static void IncrementTotalEmails() => Interlocked.Increment(ref _totalEmailsInSession);
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileLogExporter.cs
SIZE: 3.05 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter : BaseExporter<LogRecord>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileLogExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs
SIZE: 6.55 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter : BaseExporter<Metric>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileMetricsExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        MeterVersion = metric.MeterVersion,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    _writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?> ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags;
    }

    private static MetricValue ExtractValue(Metric metric, MetricPoint point)
    {
        var value = new MetricValue();

        try
        {
            switch (metric.MetricType)
            {
                case MetricType.LongSum:
                    value.LongValue = point.GetSumLong();
                    break;
                case MetricType.DoubleSum:
                    value.DoubleValue = point.GetSumDouble();
                    break;
                case MetricType.LongGauge:
                    value.LongValue = point.GetGaugeLastValueLong();
                    break;
                case MetricType.DoubleGauge:
                    value.DoubleValue = point.GetGaugeLastValueDouble();
                    break;
                case MetricType.Histogram:
                    value.DoubleValue = point.GetHistogramSum();
                    value.Count = (long)point.GetHistogramCount();
                    value.Buckets = ExtractHistogramBuckets(point);
                    break;
                case MetricType.ExponentialHistogram:
                    // ExponentialHistogramData in OpenTelemetry 1.14.0 uses different API
                    // Access count and sum through the MetricPoint directly
                    var expHistData = point.GetExponentialHistogramData();
                    value.Count = GetExponentialHistogramCount(expHistData);
                    value.DoubleValue = GetExponentialHistogramSum(expHistData);
                    break;
            }
        }
        catch
        {
            // If extraction fails, return partial data
        }

        return value;
    }

    private static long GetExponentialHistogramCount(ExponentialHistogramData data)
    {
        try
        {
            // Try accessing via reflection for API compatibility
            var countProperty = typeof(ExponentialHistogramData).GetProperty("Count");
            if (countProperty != null)
            {
                var val = countProperty.GetValue(data);
                if (val is long l) return l;
                if (val is ulong ul) return (long)ul;
                if (val is int i) return i;
            }

            // Try ZeroCount + positive/negative bucket counts as fallback
            var zeroCountProp = typeof(ExponentialHistogramData).GetProperty("ZeroCount");
            if (zeroCountProp != null)
            {
                var zeroCount = Convert.ToInt64(zeroCountProp.GetValue(data) ?? 0);
                return zeroCount; // This is a partial count but better than nothing
            }
        }
        catch
        {
            // Ignore reflection errors
        }

        return 0;
    }

    private static double GetExponentialHistogramSum(ExponentialHistogramData data)
    {
        try
        {
            // Try to access Sum via reflection for API compatibility
            var sumProperty = typeof(ExponentialHistogramData).GetProperty("Sum");
            if (sumProperty != null)
            {
                var val = sumProperty.GetValue(data);
                if (val is double d) return d;
            }
        }
        catch
        {
            // Ignore reflection errors
        }

        return 0.0;
    }

    private static List<HistogramBucket>? ExtractHistogramBuckets(MetricPoint point)
    {
        try
        {
            var buckets = new List<HistogramBucket>();
            foreach (var bucket in point.GetHistogramBuckets())
            {
                buckets.Add(new HistogramBucket
                {
                    ExplicitBound = bucket.ExplicitBound,
                    BucketCount = bucket.BucketCount
                });
            }
            return buckets.Count > 0 ? buckets : null;
        }
        catch
        {
            return null;
        }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public string? MeterVersion { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public MetricValue? Value { get; init; }
}

public record MetricValue
{
    public long? LongValue { get; set; }
    public double? DoubleValue { get; set; }
    public long? Count { get; set; }
    public List<HistogramBucket>? Buckets { get; set; }
}

public record HistogramBucket
{
    public double ExplicitBound { get; init; }
    public long BucketCount { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileTraceExporter.cs
SIZE: 3.93 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;
using OpenTelemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter : BaseExporter<Activity>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileTraceExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList(),
                    Links = activity.Links.Select(l => new SpanLink
                    {
                        TraceId = l.Context.TraceId.ToString(),
                        SpanId = l.Context.SpanId.ToString()
                    }).ToList(),
                    Resource = new ResourceInfo
                    {
                        ServiceName = activity.GetTagItem("service.name")?.ToString(),
                        ServiceVersion = activity.GetTagItem("service.version")?.ToString()
                    }
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
    public List<SpanLink>? Links { get; init; }
    public ResourceInfo? Resource { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}

public record SpanLink
{
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
}

public record ResourceInfo
{
    public string? ServiceName { get; init; }
    public string? ServiceVersion { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs
SIZE: 4.98 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using System.Collections.Concurrent;
using System.Text.Json;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Thread-safe JSON file writer that manages daily files with size limits.
/// Each telemetry record is written as a separate JSON line (JSONL format).
/// Gracefully handles write failures without crashing the application.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _baseDirectory;
    private readonly string _prefix;
    private readonly long _maxFileSizeBytes;
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly ConcurrentQueue<object> _buffer = new();
    private readonly Timer _flushTimer;
    private readonly JsonSerializerOptions _jsonOptions;

    private string _currentDate = "";
    private string _currentFilePath = "";
    private int _fileSequence;
    private long _currentFileSize;
    private bool _disposed;
    private bool _writeEnabled = true;

    public JsonTelemetryFileWriter(
        string baseDirectory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _baseDirectory = baseDirectory;
        _prefix = prefix;
        _maxFileSizeBytes = maxFileSizeBytes;

        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = false, // JSONL format - single line per record
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };

        // Try to create base directory - if it fails, disable writes
        try
        {
            Directory.CreateDirectory(_baseDirectory);
        }
        catch
        {
            _writeEnabled = false;
        }

        _flushTimer = new Timer(_ => FlushAsync().ConfigureAwait(false), null, flushInterval, flushInterval);
    }

    public void Enqueue(object record)
    {
        if (_disposed || !_writeEnabled) return;
        _buffer.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        if (_disposed || !_writeEnabled || _buffer.IsEmpty) return;

        if (!await _writeLock.WaitAsync(TimeSpan.FromSeconds(5)))
            return; // Skip this flush cycle if we can't get the lock

        try
        {
            var records = new List<object>();
            while (_buffer.TryDequeue(out var record))
            {
                records.Add(record);
            }

            foreach (var record in records)
            {
                await WriteRecordAsync(record);
            }
        }
        catch
        {
            // If we consistently fail to write, disable future writes
            // to avoid accumulating memory
            if (_buffer.Count > 10000)
            {
                _writeEnabled = false;
                while (_buffer.TryDequeue(out _)) { } // Clear buffer
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordAsync(object record)
    {
        if (!_writeEnabled) return;

        try
        {
            string today = DateTime.UtcNow.ToString("yyyy-MM-dd");

            // Check if we need a new file (new day or size exceeded)
            if (today != _currentDate || _currentFileSize >= _maxFileSizeBytes)
            {
                if (today != _currentDate)
                {
                    _currentDate = today;
                    _fileSequence = 0;
                }
                RotateFile();
            }

            // Each record is a complete JSON object on a single line (JSONL format)
            string json = JsonSerializer.Serialize(record, record.GetType(), _jsonOptions);
            string line = json + Environment.NewLine;
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(line);

            // Check if adding this record would exceed size limit
            if (_currentFileSize + bytes.Length > _maxFileSizeBytes && _currentFileSize > 0)
            {
                RotateFile();
            }

            await File.AppendAllTextAsync(_currentFilePath, line);
            _currentFileSize += bytes.Length;
        }
        catch
        {
            // Individual write failures are silently ignored
            // The application continues normally
        }
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = Path.Combine(
            _baseDirectory,
            $"{_prefix}_{_currentDate}_{_fileSequence:D4}.jsonl");

        try
        {
            _currentFileSize = File.Exists(_currentFilePath) ? new FileInfo(_currentFilePath).Length : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _flushTimer.Dispose();

        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }

        _writeLock.Dispose();
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryConfiguration.cs
SIZE: 0.77 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs
SIZE: 3.16 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification
/// with graceful fallback behavior.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName = "MyImapDownloader")
    {
        // Try locations in order of preference
        var candidates = GetCandidateDirectories(appName);

        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }

        return null; // No writable location found - telemetry will be disabled
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        // 1. XDG_DATA_HOME (Linux/macOS) or LocalApplicationData (Windows)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, appName, "telemetry");
        }

        // 2. Platform-specific user data directory
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            yield return Path.Combine(localAppData, appName, "telemetry");
        }

        // 3. XDG_STATE_HOME for state/log data (more appropriate for telemetry)
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, appName, "telemetry");
        }

        // 4. Fallback to ~/.local/state on Unix-like systems
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            yield return Path.Combine(homeDir, ".local", "state", appName, "telemetry");
            yield return Path.Combine(homeDir, ".local", "share", appName, "telemetry");
        }

        // 5. Directory relative to executable
        var exeDir = AppContext.BaseDirectory;
        if (!string.IsNullOrEmpty(exeDir))
        {
            yield return Path.Combine(exeDir, "telemetry");
        }

        // 6. Current working directory as last resort
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            // Attempt to create the directory
            Directory.CreateDirectory(path);

            // Verify we can write to it
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryExtensions.cs
SIZE: 8.33 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for configuring OpenTelemetry with JSON file exporters.
/// </summary>
public static class TelemetryExtensions
{
    public static IServiceCollection AddTelemetry(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);
        services.AddSingleton(config);

        // Resolve telemetry directory with XDG compliance and fallback
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);

        if (telemetryBaseDir == null)
        {
            // No writable location found - register placeholder services
            // Telemetry will be effectively disabled but app continues normally
            services.AddSingleton<ITelemetryWriterProvider>(new NullTelemetryWriterProvider());
            config.EnableTracing = false;
            config.EnableMetrics = false;
            config.EnableLogging = false;

            return services;
        }

        // Update config with resolved directory
        config.OutputDirectory = telemetryBaseDir;

        var tracesDir = Path.Combine(telemetryBaseDir, "traces");
        var metricsDir = Path.Combine(telemetryBaseDir, "metrics");
        var logsDir = Path.Combine(telemetryBaseDir, "logs");

        TryCreateDirectory(tracesDir);
        TryCreateDirectory(metricsDir);
        TryCreateDirectory(logsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        // Create file writers
        JsonTelemetryFileWriter? traceWriter = null;
        JsonTelemetryFileWriter? metricsWriter = null;
        JsonTelemetryFileWriter? logsWriter = null;

        try
        {
            traceWriter = new JsonTelemetryFileWriter(
                tracesDir, "traces", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Trace writing disabled */ }

        try
        {
            metricsWriter = new JsonTelemetryFileWriter(
                metricsDir, "metrics", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Metrics writing disabled */ }

        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Log writing disabled */ }

        // Register the writer provider instead of nullable writers directly
        var writerProvider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);
        services.AddSingleton<ITelemetryWriterProvider>(writerProvider);

        // Also register the trace writer directly for Program.cs disposal
        if (traceWriter != null)
        {
            services.AddSingleton(traceWriter);
        }

        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(
                serviceName: config.ServiceName,
                serviceVersion: config.ServiceVersion)
            .AddAttributes(new Dictionary<string, object>
            {
                ["host.name"] = Environment.MachineName,
                ["os.type"] = Environment.OSVersion.Platform.ToString(),
                ["os.version"] = Environment.OSVersion.VersionString,
                ["process.runtime.name"] = ".NET",
                ["process.runtime.version"] = Environment.Version.ToString(),
                ["telemetry.directory"] = telemetryBaseDir
            });

        // Configure OpenTelemetry
        var otelBuilder = services.AddOpenTelemetry()
            .ConfigureResource(r => r.AddService(config.ServiceName, serviceVersion: config.ServiceVersion));

        if (config.EnableTracing && traceWriter != null)
        {
            otelBuilder.WithTracing(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddSource(DiagnosticsConfig.ServiceName)
                    .SetSampler(new AlwaysOnSampler())
                    .AddProcessor(new BatchActivityExportProcessor(
                        new JsonFileTraceExporter(traceWriter),
                        maxQueueSize: 2048,
                        scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                        exporterTimeoutMilliseconds: 30000,
                        maxExportBatchSize: 512));
            });
        }

        if (config.EnableMetrics && metricsWriter != null)
        {
            otelBuilder.WithMetrics(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddMeter(DiagnosticsConfig.ServiceName)
                    .AddRuntimeInstrumentation()
                    .AddReader(new PeriodicExportingMetricReader(
                        new JsonFileMetricsExporter(metricsWriter),
                        exportIntervalMilliseconds: config.MetricsExportIntervalSeconds * 1000));
            });
        }

        return services;
    }

    public static ILoggingBuilder AddTelemetryLogging(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);

        if (!config.EnableLogging)
            return builder;

        // Resolve telemetry directory
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        if (telemetryBaseDir == null)
            return builder; // No writable location - skip telemetry logging

        var logsDir = Path.Combine(telemetryBaseDir, "logs");
        if (!TryCreateDirectory(logsDir))
            return builder;

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        JsonTelemetryFileWriter? logsWriter = null;
        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch
        {
            return builder; // Failed to create writer - skip telemetry logging
        }

        builder.AddOpenTelemetry(options =>
        {
            options.IncludeFormattedMessage = true;
            options.IncludeScopes = true;
            options.ParseStateValues = true;
            options.AddProcessor(new BatchLogRecordExportProcessor(
                new JsonFileLogExporter(logsWriter),
                maxQueueSize: 2048,
                scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                exporterTimeoutMilliseconds: 30000,
                maxExportBatchSize: 512));
        });

        return builder;
    }

    private static bool TryCreateDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

/// <summary>
/// Interface for accessing telemetry file writers.
/// </summary>
public interface ITelemetryWriterProvider
{
    JsonTelemetryFileWriter? TraceWriter { get; }
    JsonTelemetryFileWriter? MetricsWriter { get; }
    JsonTelemetryFileWriter? LogsWriter { get; }
}

/// <summary>
/// Provides access to telemetry file writers.
/// </summary>
public sealed class TelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter { get; }
    public JsonTelemetryFileWriter? MetricsWriter { get; }
    public JsonTelemetryFileWriter? LogsWriter { get; }

    public TelemetryWriterProvider(
        JsonTelemetryFileWriter? traceWriter,
        JsonTelemetryFileWriter? metricsWriter,
        JsonTelemetryFileWriter? logsWriter)
    {
        TraceWriter = traceWriter;
        MetricsWriter = metricsWriter;
        LogsWriter = logsWriter;
    }
}

/// <summary>
/// Null implementation when telemetry is disabled.
/// </summary>
public sealed class NullTelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => null;
    public JsonTelemetryFileWriter? MetricsWriter => null;
    public JsonTelemetryFileWriter? LogsWriter => null;
}


================================================================================
FILE: MyImapDownloader.Tests/DownloadOptionsTests.cs
SIZE: 3.99 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using AwesomeAssertions;

namespace MyImapDownloader.Tests;

public class DownloadOptionsTests
{
    [Test]
    public async Task DefaultValues_AreSet()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output"
        };

        await Assert.That(options.Port).IsEqualTo(993);
        await Assert.That(options.StartDate).IsNull();
        await Assert.That(options.EndDate).IsNull();
        await Assert.That(options.AllFolders).IsFalse();
        await Assert.That(options.Verbose).IsFalse();
    }

    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var options = new DownloadOptions
        {
            Server = "mail.test.com",
            Username = "testuser",
            Password = "testpass",
            OutputDirectory = "emails"
        };

        await Assert.That(options.Server).IsEqualTo("mail.test.com");
        await Assert.That(options.Username).IsEqualTo("testuser");
        await Assert.That(options.Password).IsEqualTo("testpass");
        await Assert.That(options.OutputDirectory).IsEqualTo("emails");
    }

    [Test]
    public async Task Port_CanBeCustomized()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            Port = 143
        };

        await Assert.That(options.Port).IsEqualTo(143);
    }

    [Test]
    public async Task DateFilters_CanBeSet()
    {
        var startDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        var endDate = new DateTime(2024, 12, 31, 23, 59, 59, DateTimeKind.Utc);

        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            StartDate = startDate,
            EndDate = endDate
        };

        await Assert.That(options.StartDate).IsEqualTo(startDate);
        await Assert.That(options.EndDate).IsEqualTo(endDate);
    }

    [Test]
    public async Task DateRange_CanBeCalculated()
    {
        var startDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        var endDate = new DateTime(2024, 12, 31, 23, 59, 59, DateTimeKind.Utc);

        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            StartDate = startDate,
            EndDate = endDate
        };

        var daySpan = (options.EndDate!.Value - options.StartDate!.Value).Days;
        await Assert.That(daySpan).IsEqualTo(365);
    }

    [Test]
    public async Task AllFolders_CanBeEnabled()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            AllFolders = true
        };

        await Assert.That(options.AllFolders).IsTrue();
    }

    [Test]
    public async Task Verbose_CanBeEnabled()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            Verbose = true
        };

        await Assert.That(options.Verbose).IsTrue();
    }

    [Test]
    public async Task NullableDateProperties_CanRemainNull()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output"
        };

        await Assert.That(options.StartDate).IsNull();
        await Assert.That(options.EndDate).IsNull();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/EmailDownloadExceptionTests.cs
SIZE: 3.46 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using AwesomeAssertions;

namespace MyImapDownloader.Tests;

public class EmailDownloadExceptionTests
{
    [Test]
    public async Task Constructor_SetsAllProperties()
    {
        var inner = new IOException("Network error");
        var exception = new EmailDownloadException("Download failed", 42, inner);

        await Assert.That(exception.Message).IsEqualTo("Download failed");
        await Assert.That(exception.MessageIndex).IsEqualTo(42);
        await Assert.That(exception.InnerException).IsEqualTo(inner);
    }

    [Test]
    public async Task MessageIndex_IsAccessible()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Error at index", 5, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(5);
    }

    [Test]
    public async Task InheritsFromException()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Test", 0, inner);

        exception.Should().BeAssignableTo<Exception>();
    }

    [Test]
    public async Task CanBeCaughtAsException()
    {
        Exception? caught = null;
        var inner = new Exception("Inner");

        try
        {
            throw new EmailDownloadException("Test error", 1, inner);
        }
        catch (Exception ex)
        {
            caught = ex;
        }

        await Assert.That(caught).IsNotNull();
        caught.Should().BeOfType<EmailDownloadException>();
    }

    [Test]
    public async Task CanBeCaughtSpecifically()
    {
        EmailDownloadException? caught = null;
        var inner = new Exception("Inner");

        try
        {
            throw new EmailDownloadException("Specific error", 10, inner);
        }
        catch (EmailDownloadException ex)
        {
            caught = ex;
        }

        await Assert.That(caught).IsNotNull();
        await Assert.That(caught!.Message).IsEqualTo("Specific error");
        await Assert.That(caught.MessageIndex).IsEqualTo(10);
    }

    [Test]
    public async Task InnerException_ChainIsPreserved()
    {
        var level1 = new InvalidOperationException("Level 1");
        var level2 = new EmailDownloadException("Level 2", 1, level1);
        var level3 = new EmailDownloadException("Level 3", 2, level2);

        await Assert.That(level3.InnerException).IsEqualTo(level2);
        await Assert.That(level3.InnerException!.InnerException).IsEqualTo(level1);
    }

    [Test]
    public async Task StackTrace_IsAvailable_WhenThrown()
    {
        EmailDownloadException? caught = null;

        try
        {
            ThrowHelper();
        }
        catch (EmailDownloadException ex)
        {
            caught = ex;
        }

        caught!.StackTrace.Should().NotBeNullOrEmpty();
        caught.StackTrace.Should().Contain("ThrowHelper");
    }

    [Test]
    public async Task MessageIndex_ZeroIsValid()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("First message failed", 0, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(0);
    }

    [Test]
    public async Task MessageIndex_LargeValueIsValid()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Message failed", 999999, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(999999);
    }

    private static void ThrowHelper()
    {
        var inner = new Exception("Inner");
        throw new EmailDownloadException("From helper", 0, inner);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/ImapConfigurationTests.cs
SIZE: 3.99 KB
MODIFIED: 2025-12-31 08:53:41
================================================================================

using AwesomeAssertions;
using Microsoft.Extensions.Configuration;

namespace MyImapDownloader.Tests;

public class ImapConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreSet()
    {
        var config = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };

        await Assert.That(config.Port).IsEqualTo(0); // No default in current implementation
        await Assert.That(config.UseSsl).IsTrue();
        await Assert.That(config.Server).IsEmpty();
        await Assert.That(config.Username).IsEmpty();
        await Assert.That(config.Password).IsEmpty();
    }

    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret123"
        };

        await Assert.That(config.Server).IsEqualTo("imap.example.com");
        await Assert.That(config.Username).IsEqualTo("user@example.com");
        await Assert.That(config.Password).IsEqualTo("secret123");
    }

    [Test]
    public async Task CanBindFromConfiguration()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Imap:Server"] = "imap.example.com",
            ["Imap:Port"] = "587",
            ["Imap:Username"] = "user@example.com",
            ["Imap:Password"] = "secret123",
            ["Imap:UseSsl"] = "false"
        };

        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        var imapConfig = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };
        configuration.GetSection("Imap").Bind(imapConfig);

        await Assert.That(imapConfig.Server).IsEqualTo("imap.example.com");
        await Assert.That(imapConfig.Port).IsEqualTo(587);
        await Assert.That(imapConfig.Username).IsEqualTo("user@example.com");
        await Assert.That(imapConfig.Password).IsEqualTo("secret123");
        await Assert.That(imapConfig.UseSsl).IsFalse();
    }

    [Test]
    public async Task PartialConfiguration_UsesDefaults()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Imap:Server"] = "mail.test.com",
            ["Imap:Username"] = "testuser",
            ["Imap:Password"] = "testpass"
        };

        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        var imapConfig = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };
        configuration.GetSection("Imap").Bind(imapConfig);

        // Configured values
        await Assert.That(imapConfig.Server).IsEqualTo("mail.test.com");
        await Assert.That(imapConfig.Username).IsEqualTo("testuser");
        await Assert.That(imapConfig.Password).IsEqualTo("testpass");

        // Default value preserved
        await Assert.That(imapConfig.UseSsl).IsTrue();
    }

    [Test]
    [Arguments(993, true)]   // Standard IMAPS
    [Arguments(143, false)]  // Standard IMAP
    [Arguments(587, true)]   // Custom with SSL
    [Arguments(2993, true)]  // Non-standard with SSL
    public async Task PortAndSslCombinations_AreValid(int port, bool useSsl)
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password",
            Port = port,
            UseSsl = useSsl
        };

        await Assert.That(config.Port).IsEqualTo(port);
        await Assert.That(config.UseSsl).IsEqualTo(useSsl);
    }

    [Test]
    public async Task UseSsl_DefaultsToTrue()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password"
        };

        await Assert.That(config.UseSsl).IsTrue();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/MyImapDownloader.Tests.csproj
SIZE: 0.72 KB
MODIFIED: 2025-12-31 08:54:12
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TUnit requires the test project to be an Exe -->
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="AwesomeAssertions"/>
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader\MyImapDownloader.csproj" />
  </ItemGroup>

</Project>


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/ActivityExtensionsTests.cs
SIZE: 5.56 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using System.Diagnostics;
using AwesomeAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class ActivityExtensionsTests : IDisposable
{
    private readonly ActivitySource _activitySource;
    private readonly ActivityListener _listener;
    private readonly List<Activity> _recordedActivities = [];

    public ActivityExtensionsTests()
    {
        _activitySource = new ActivitySource("TestSource");
        _listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded,
            ActivityStopped = activity => _recordedActivities.Add(activity)
        };
        ActivitySource.AddActivityListener(_listener);
    }

    public void Dispose()
    {
        _listener.Dispose();
        _activitySource.Dispose();
    }

    [Test]
    public async Task RecordException_AddsExceptionEvent_ToActivity()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new InvalidOperationException("Test error message");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(1);

        var exceptionEvent = events[0];
        await Assert.That(exceptionEvent.Name).IsEqualTo("exception");
    }

    [Test]
    public async Task RecordException_IncludesExceptionType()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new ArgumentNullException("paramName");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.type");
        tags["exception.type"].Should().Be(typeof(ArgumentNullException).FullName);
    }

    [Test]
    public async Task RecordException_IncludesExceptionMessage()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Specific error details");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.message");
        tags["exception.message"]!.ToString().Should().Contain("Specific error details");
    }

    [Test]
    public async Task RecordException_IncludesStackTrace_WhenAvailable()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        Exception? capturedException = null;
        try
        {
            throw new Exception("Error with stack trace");
        }
        catch (Exception ex)
        {
            capturedException = ex;
        }

        activity.RecordException(capturedException!);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.stacktrace");
        tags["exception.stacktrace"]!.ToString().Should().Contain("RecordException_IncludesStackTrace");
    }

    [Test]
    public async Task RecordException_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.RecordException(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_WithNullException_DoesNotThrow()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        // Should not throw
        activity.RecordException(null!);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(0);
    }

    [Test]
    public async Task SetErrorStatus_SetsStatusToError()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Operation failed");

        activity.SetErrorStatus(exception);

        await Assert.That(activity!.Status).IsEqualTo(ActivityStatusCode.Error);
    }

    [Test]
    public async Task SetErrorStatus_IncludesExceptionMessage_InStatusDescription()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Detailed failure reason");

        activity.SetErrorStatus(exception);

        activity!.StatusDescription.Should().Contain("Detailed failure reason");
    }

    [Test]
    public async Task SetErrorStatus_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.SetErrorStatus(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_HandlesNestedExceptions()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var inner = new ArgumentException("Inner error");
        var outer = new InvalidOperationException("Outer error", inner);

        activity.RecordException(outer);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        // Should record the outer exception's details
        tags["exception.type"].Should().Be(typeof(InvalidOperationException).FullName);
        tags["exception.message"]!.ToString().Should().Contain("Outer error");
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/DiagnosticsConfigTests.cs
SIZE: 2.54 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using AwesomeAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class DiagnosticsConfigTests
{
    [Test]
    public async Task ServiceName_IsExpectedValue()
    {
        var serviceName = DiagnosticsConfig.ServiceName;
        await Assert.That(serviceName).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_HasCorrectName()
    {
        var source = DiagnosticsConfig.ActivitySource;

        source.Should().NotBeNull();
        await Assert.That(source.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task Meter_HasCorrectName()
    {
        var meter = DiagnosticsConfig.Meter;

        meter.Should().NotBeNull();
        await Assert.That(meter.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_CanCreateActivity()
    {
        // Need a listener to actually create activities
        using var listener = new ActivityListener
        {
            ShouldListenTo = source => source.Name == DiagnosticsConfig.ServiceName,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("TestOperation");

        activity.Should().NotBeNull();
        await Assert.That(activity!.OperationName).IsEqualTo("TestOperation");
    }

    [Test]
    public async Task Meter_CanCreateCounter()
    {
        var counter = DiagnosticsConfig.Meter.CreateCounter<long>("test_counter");

        counter.Should().NotBeNull();
        counter.Name.Should().Be("test_counter");
    }

    [Test]
    public async Task Meter_CanCreateHistogram()
    {
        var histogram = DiagnosticsConfig.Meter.CreateHistogram<double>("test_histogram");

        histogram.Should().NotBeNull();
        histogram.Name.Should().Be("test_histogram");
    }

    [Test]
    public async Task ActivitySource_IsSingleton()
    {
        var source1 = DiagnosticsConfig.ActivitySource;
        var source2 = DiagnosticsConfig.ActivitySource;

        var areSame = ReferenceEquals(source1, source2);
        await Assert.That(areSame).IsTrue();
    }

    [Test]
    public async Task Meter_IsSingleton()
    {
        var meter1 = DiagnosticsConfig.Meter;
        var meter2 = DiagnosticsConfig.Meter;

        var areSame = ReferenceEquals(meter1, meter2);
        await Assert.That(areSame).IsTrue();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/JsonExporterTests.cs
SIZE: 4.74 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using System.Diagnostics;
using AwesomeAssertions;
using MyImapDownloader.Telemetry;
using OpenTelemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonFileTraceExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonFileTraceExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"trace_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix = "traces")
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileTraceExporter(null);

        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }

    [Test]
    public async Task Export_WithWriter_EnqueuesRecords()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        using var activitySource = new ActivitySource("Test");
        using var listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = activitySource.StartActivity("ExportTest");
        activity?.SetTag("test.key", "test.value");
        activity?.Stop();

        var batch = new Batch<Activity>([activity!], 1);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);

        // Flush and verify
        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("ExportTest");
    }

    [Test]
    public async Task Export_ReturnsSuccess_EvenOnError()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        // Empty batch should still return success
        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileLogExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileLogExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"log_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileLogExporter(null);

        // Test with empty batch
        var batch = new Batch<OpenTelemetry.Logs.LogRecord>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileMetricsExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileMetricsExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"metrics_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileMetricsExporter(null);

        var batch = new Batch<OpenTelemetry.Metrics.Metric>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/JsonTelemetryFileWriterTests.cs
SIZE: 5.63 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using System.Text.Json;
using AwesomeAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonTelemetryFileWriterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonTelemetryFileWriterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"telemetry_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string? subDir = null, string prefix = "test", long maxSize = 1024 * 1024)
    {
        var dir = subDir != null ? Path.Combine(_testDirectory, subDir) : _testDirectory;
        var writer = new JsonTelemetryFileWriter(dir, prefix, maxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_CreatesDirectory_WhenItDoesNotExist()
    {
        var newDir = Path.Combine(_testDirectory, "new_subdir");

        var writer = new JsonTelemetryFileWriter(newDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        await Assert.That(Directory.Exists(newDir)).IsTrue();
    }

    [Test]
    public async Task Enqueue_DoesNotThrow_WhenCalled()
    {
        var writer = CreateWriter();

        var record = new { Message = "Test", Timestamp = DateTime.UtcNow };

        // Should not throw
        writer.Enqueue(record);

        // If we get here, the test passed
        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task FlushAsync_WritesEnqueuedRecords_ToFile()
    {
        var writer = CreateWriter();

        var record = new TestRecord { Id = 1, Message = "Hello" };
        writer.Enqueue(record);

        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("Hello");
        content.Should().Contain("\"id\":1");
    }

    [Test]
    public async Task FlushAsync_WritesMultipleRecords_InJsonlFormat()
    {
        var writer = CreateWriter();

        writer.Enqueue(new TestRecord { Id = 1, Message = "First" });
        writer.Enqueue(new TestRecord { Id = 2, Message = "Second" });
        writer.Enqueue(new TestRecord { Id = 3, Message = "Third" });

        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        var lines = await File.ReadAllLinesAsync(files[0]);

        // Each record should be on its own line (JSONL format)
        await Assert.That(lines.Length).IsEqualTo(3);

        // Each line should be valid JSON
        foreach (var line in lines)
        {
            var parsed = JsonSerializer.Deserialize<TestRecord>(line);
            parsed.Should().NotBeNull();
        }
    }

    [Test]
    public async Task Dispose_CanBeCalledMultipleTimes()
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, "dispose", 1024 * 1024, TimeSpan.FromSeconds(30));

        // Should not throw when called multiple times
        writer.Dispose();
        writer.Dispose();
        writer.Dispose();

        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task Dispose_FlushesRemainingRecords()
    {
        var subDir = Path.Combine(_testDirectory, "dispose_flush");
        Directory.CreateDirectory(subDir);

        var writer = new JsonTelemetryFileWriter(subDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));

        writer.Enqueue(new { Test = true });

        // Force a flush before dispose to ensure it works
        await writer.FlushAsync();

        writer.Dispose();

        var files = Directory.GetFiles(subDir, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }

    [Test]
    public async Task FlushAsync_WithEmptyBuffer_DoesNotCreateFile()
    {
        var emptyDir = Path.Combine(_testDirectory, "empty");
        Directory.CreateDirectory(emptyDir);

        var writer = CreateWriter("empty");

        await writer.FlushAsync();

        var files = Directory.GetFiles(emptyDir, "*.jsonl");
        await Assert.That(files.Length).IsEqualTo(0);
    }

    [Test]
    public async Task FileRotation_OccursWhenSizeExceeded()
    {
        // Small max file size to trigger rotation quickly
        const long smallMaxSize = 500; // 500 bytes
        var rotateDir = Path.Combine(_testDirectory, "rotate");
        Directory.CreateDirectory(rotateDir);

        var writer = new JsonTelemetryFileWriter(rotateDir, "rotate", smallMaxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        // Write enough data to trigger rotation (each record ~50-100 bytes)
        for (int i = 0; i < 20; i++)
        {
            writer.Enqueue(new TestRecord { Id = i, Message = $"Record number {i} with some padding text" });
        }

        await writer.FlushAsync();

        var files = Directory.GetFiles(rotateDir, "rotate_*.jsonl");

        // Should have created multiple files due to rotation
        await Assert.That(files.Length).IsGreaterThan(1);
    }

    private record TestRecord
    {
        public int Id { get; init; }
        public string? Message { get; init; }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryConfigurationTests.cs
SIZE: 2.67 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using AwesomeAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreReasonable()
    {
        var config = new TelemetryConfiguration();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.ServiceVersion).IsEqualTo("1.0.0");
        await Assert.That(config.EnableTracing).IsTrue();
        await Assert.That(config.EnableMetrics).IsTrue();
        await Assert.That(config.EnableLogging).IsTrue();
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(25);
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(5);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(15);
    }

    [Test]
    public async Task MaxFileSizeBytes_CalculatesCorrectly()
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = 10 };

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(10L * 1024L * 1024L);
    }

    [Test]
    [Arguments(1)]
    [Arguments(25)]
    [Arguments(100)]
    [Arguments(1024)]
    public async Task MaxFileSizeBytes_ScalesWithMB(int megabytes)
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = megabytes };
        var expected = (long)megabytes * 1024L * 1024L;

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(expected);
    }

    [Test]
    public async Task SectionName_IsExpectedValue()
    {
        var sectionName = TelemetryConfiguration.SectionName;
        await Assert.That(sectionName).IsEqualTo("Telemetry");
    }

    [Test]
    public async Task AllPropertiesAreMutable()
    {
        var config = new TelemetryConfiguration
        {
            ServiceName = "CustomService",
            ServiceVersion = "2.0.0",
            OutputDirectory = "/custom/path",
            MaxFileSizeMB = 50,
            EnableTracing = false,
            EnableMetrics = false,
            EnableLogging = false,
            FlushIntervalSeconds = 10,
            MetricsExportIntervalSeconds = 30
        };

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.OutputDirectory).IsEqualTo("/custom/path");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableTracing).IsFalse();
        await Assert.That(config.EnableMetrics).IsFalse();
        await Assert.That(config.EnableLogging).IsFalse();
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(10);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(30);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryDirectoryResolverTests.cs
SIZE: 3.41 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using AwesomeAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryDirectoryResolverTests
{
    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsNonNullPath()
    {
        // On any normal system, at least one location should be writable
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        // This could be null in a sandboxed environment, but typically won't be
        // We're testing that the method runs without throwing
        result.Should().NotBeNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsWritablePath_WhenSuccessful()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        if (result != null)
        {
            // If a path is returned, it should be writable
            var testFile = Path.Combine(result, $".test_{Guid.NewGuid():N}");
            try
            {
                await File.WriteAllTextAsync(testFile, "test");
                await Assert.That(File.Exists(testFile)).IsTrue();
                File.Delete(testFile);
            }
            finally
            {
                if (File.Exists(testFile))
                    File.Delete(testFile);
            }
        }
        else
        {
            // Null is acceptable if no writable location exists
            await Assert.That(result).IsNull();
        }
    }

    [Test]
    public async Task ResolveTelemetryDirectory_IncludesAppName_InPath()
    {
        const string appName = "MyUniqueTestApp";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        if (result != null)
        {
            result.Should().Contain(appName);
        }

        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_UsesDefaultAppName_WhenNotSpecified()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory();

        // Should use "MyImapDownloader" as default
        if (result != null)
        {
            result.Should().Contain("MyImapDownloader");
        }

        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_CreatesDirectory_WhenItDoesNotExist()
    {
        var uniqueAppName = $"TestApp_{Guid.NewGuid():N}";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(uniqueAppName);

        try
        {
            if (result != null)
            {
                await Assert.That(Directory.Exists(result)).IsTrue();
            }
        }
        finally
        {
            // Cleanup
            if (result != null && Directory.Exists(result))
            {
                try { Directory.Delete(result, recursive: true); } catch { }
            }
        }
    }

    [Test]
    [Arguments("SimpleApp")]
    [Arguments("App-With-Dashes")]
    [Arguments("App_With_Underscores")]
    [Arguments("AppWithNumbers123")]
    public async Task ResolveTelemetryDirectory_HandlesVariousAppNames(string appName)
    {
        // Should not throw for valid app names
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        result.Should().NotBeNull();

        // Cleanup if directory was created
        if (result != null && Directory.Exists(result))
        {
            try { Directory.Delete(result, recursive: true); } catch { }
        }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryExtensionsTests.cs
SIZE: 4.33 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using AwesomeAssertions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryExtensionsTests
{
    [Test]
    public async Task AddTelemetry_RegistersTelemetryConfiguration()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetService<TelemetryConfiguration>();
        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_RegistersWriterProvider()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_BindsConfigurationValues()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:ServiceName"] = "CustomService",
            ["Telemetry:ServiceVersion"] = "2.0.0",
            ["Telemetry:MaxFileSizeMB"] = "50",
            ["Telemetry:EnableTracing"] = "true",
            ["Telemetry:EnableMetrics"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableMetrics).IsFalse();
    }

    [Test]
    public async Task AddTelemetry_WithDisabledTelemetry_RegistersNullProvider()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:EnableTracing"] = "false",
            ["Telemetry:EnableMetrics"] = "false",
            ["Telemetry:EnableLogging"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_CanBeCalledMultipleTimes_WithoutError()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        // Should not throw on multiple calls
        services.AddTelemetry(configuration);
        services.AddTelemetry(configuration);

        var provider = services.BuildServiceProvider();
        var config = provider.GetService<TelemetryConfiguration>();

        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_WithEmptyConfiguration_UsesDefaults()
    {
        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder().Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.EnableTracing).IsTrue();
    }

    [Test]
    public async Task AddTelemetry_ReturnsServiceCollection_ForChaining()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        var result = services.AddTelemetry(configuration);

        result.Should().BeSameAs(services);
    }

    private static IConfiguration CreateConfiguration()
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Telemetry:ServiceName"] = "TestService"
            })
            .Build();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryWriterProviderTests.cs
SIZE: 3.47 KB
MODIFIED: 2025-12-31 08:53:39
================================================================================

using AwesomeAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryWriterProviderTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = new();

    public TelemetryWriterProviderTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"provider_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix)
    {
        var writer = new JsonTelemetryFileWriter(
            _testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_AcceptsAllWriters()
    {
        var traceWriter = CreateWriter("traces");
        var metricsWriter = CreateWriter("metrics");
        var logsWriter = CreateWriter("logs");

        var provider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsEqualTo(metricsWriter);
        await Assert.That(provider.LogsWriter).IsEqualTo(logsWriter);
    }

    [Test]
    public async Task Constructor_AcceptsNullWriters()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task Constructor_AcceptsMixedNullAndNonNullWriters()
    {
        var traceWriter = CreateWriter("traces");

        var provider = new TelemetryWriterProvider(traceWriter, null, null);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task ImplementsInterface()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task NullProvider_ReturnsAllNull()
    {
        var provider = new NullTelemetryWriterProvider();

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task NullProvider_ImplementsInterface()
    {
        var provider = new NullTelemetryWriterProvider();

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task ProvidersAreInterchangeable()
    {
        ITelemetryWriterProvider provider1 = new NullTelemetryWriterProvider();
        ITelemetryWriterProvider provider2 = new TelemetryWriterProvider(null, null, null);

        // Both should work identically through the interface
        await Assert.That(provider1.TraceWriter).IsNull();
        await Assert.That(provider2.TraceWriter).IsNull();
    }
}


================================================================================
FILE: qodana.yaml
SIZE: 0.96 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify IDE code to run analysis without container (Applied in CI/CD pipeline)
ide: QDNET

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)


===============================================================================
EXPORT COMPLETED: Thu Jan  1 09:57:55 AM CST 2026
Total Files Exported: 67
Output File: /home/kushal/src/dotnet/MyImapDownloader/docs/llm/dump.txt
===============================================================================
