===============================================================================
PROJECT EXPORT
Generated: Thu Dec 25 09:31:46 PM CST 2025
Project Path: /home/kushal/src/dotnet/MyImapDownloader
===============================================================================

DIRECTORY STRUCTURE:
===================

/home/kushal/src/dotnet/MyImapDownloader
├── Directory.Build.props
├── Directory.Build.targets
├── Directory.Packages.props
├── export.ps1
├── export.sh
├── .github
│   └── workflows
│       └── ci.yml
├── .gitignore
├── global.json
├── LICENSE
├── MyImapDownloader
│   ├── appsettings.json
│   ├── DownloadOptions.cs
│   ├── EmailDownloadException.cs
│   ├── EmailDownloadService.cs
│   ├── EmailMetadata.cs
│   ├── EmailStorageService.cs
│   ├── ImapConfiguration.cs
│   ├── MyImapDownloader.csproj
│   ├── Program.cs
│   └── Telemetry
│       ├── ActivityExtension.cs
│       ├── DiagnosticsConfig.cs
│       ├── JsonFileLogExporter.cs
│       ├── JsonFileMetricsExporter.cs
│       ├── JsonFileTraceExporter.cs
│       ├── JsonTelemetryFileWriter.cs
│       ├── TelemetryConfiguration.cs
│       ├── TelemetryDirectoryResolver.cs
│       └── TelemetryExtensions.cs
├── MyImapDownloader.sln
├── MyImapDownloader.Tests
│   ├── DownloadOptionsTests.cs
│   ├── EmailDownloadExceptionTests.cs
│   ├── ImapConfigurationTests.cs
│   ├── MyImapDownloader.Tests.csproj
│   └── Telemetry
│       ├── ActivityExtensionsTests.cs
│       ├── DiagnosticsConfigTests.cs
│       ├── JsonExporterTests.cs
│       ├── JsonTelemetryFileWriterTests.cs
│       ├── TelemetryConfigurationTests.cs
│       ├── TelemetryDirectoryResolverTests.cs
│       ├── TelemetryExtensionsTests.cs
│       └── TelemetryWriterProviderTests.cs
├── qodana.yaml
└── README.md


FILE CONTENTS:
==============

================================================================================
FILE: Directory.Build.props
SIZE: 0.79 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  <PropertyGroup>
    <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
    <TestingPlatformCaptureOutput>false</TestingPlatformCaptureOutput>
  </PropertyGroup>
  <PropertyGroup>
    <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
  </PropertyGroup>
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>

================================================================================
FILE: Directory.Packages.props
SIZE: 1.71 KB
MODIFIED: 2025-12-23 04:58:50
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  <ItemGroup>
    <PackageVersion Include="CommandLineParser" Version="2.9.1" />
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="MailKit" Version="4.14.1" />
    <PackageVersion Include="Microsoft.Data.Sqlite" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Json" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.UserSecrets" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Console" Version="10.0.1" />
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    <PackageVersion Include="Polly" Version="8.6.5" />
    
    <PackageVersion Include="TUnit" Version="1.6.20" />
    <PackageVersion Include="NSubstitute" Version="5.3.0" />
    <PackageVersion Include="FluentAssertions" Version="8.8.0" />
  </ItemGroup>
</Project>

================================================================================
FILE: .github/workflows/ci.yml
SIZE: 1.30 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

name: Build and Test

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  build-and-test:
    name: ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'ga'
      
      - name: Display .NET info
        run: dotnet --info
      
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build solution
        run: dotnet build --no-restore --configuration Release
      
      - name: Run tests
        run: dotnet test --no-build --configuration Release --verbosity normal
      
      - name: Publish application
        run: dotnet publish MyImapDownloader/MyImapDownloader.csproj --no-build --configuration Release --output ./publish
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MyImapDownloader-${{ matrix.os }}
          path: ./publish/
          retention-days: 7


================================================================================
FILE: global.json
SIZE: 0.07 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

{
    "test": {
        "runner": "Microsoft.Testing.Platform"
    }
}


================================================================================
FILE: MyImapDownloader/appsettings.json
SIZE: 0.43 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

{
  "Telemetry": {
    "ServiceName": "MyImapDownloader",
    "ServiceVersion": "1.0.0",
    "OutputDirectory": "telemetry",
    "MaxFileSizeMB": 25,
    "EnableTracing": true,
    "EnableMetrics": true,
    "EnableLogging": true,
    "FlushIntervalSeconds": 5,
    "MetricsExportIntervalSeconds": 15
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}


================================================================================
FILE: MyImapDownloader/DownloadOptions.cs
SIZE: 1.25 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿using CommandLine;

namespace MyImapDownloader;

public class DownloadOptions
{
    [Option('s', "server", Required = true, HelpText = "IMAP server address")]
    public required string Server { get; set; }

    [Option('u', "username", Required = true, HelpText = "Email username")]
    public required string Username { get; set; }

    [Option('p', "password", Required = true, HelpText = "Email password")]
    public required string Password { get; set; }

    [Option('r', "port", Default = 993, HelpText = "IMAP port (default: 993)")]
    public int Port { get; set; } = 993;

    [Option('o', "output", Default = "EmailArchive", HelpText = "Output directory for archived emails")]
    public required string OutputDirectory { get; set; }

    [Option("start-date", HelpText = "Download emails from this date (yyyy-MM-dd)")]
    public DateTime? StartDate { get; set; }

    [Option("end-date", HelpText = "Download emails until this date (yyyy-MM-dd)")]
    public DateTime? EndDate { get; set; }

    [Option('a', "all-folders", Default = false, HelpText = "Download from all folders, not just INBOX")]
    public bool AllFolders { get; set; }

    [Option('v', "verbose", Default = false, HelpText = "Enable verbose logging")]
    public bool Verbose { get; set; }
}


================================================================================
FILE: MyImapDownloader/EmailDownloadException.cs
SIZE: 0.24 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿namespace MyImapDownloader;

// Custom Exceptions
public class EmailDownloadException(string message, int messageIndex, Exception innerException)
    : Exception(message, innerException)
{
    public int MessageIndex { get; } = messageIndex;
}


================================================================================
FILE: MyImapDownloader/EmailDownloadService.cs
SIZE: 8.04 KB
MODIFIED: 2025-12-23 05:07:01
================================================================================

﻿using System.Diagnostics;
using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MailKit.Security;
using Microsoft.Extensions.Logging;
using MyImapDownloader.Telemetry;
using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;

namespace MyImapDownloader;

public class EmailDownloadService
{
    private readonly ILogger<EmailDownloadService> _logger;
    private readonly ImapConfiguration _config;
    private readonly EmailStorageService _storage;
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    public EmailDownloadService(
        ILogger<EmailDownloadService> logger,
        ImapConfiguration config,
        EmailStorageService storage)
    {
        _logger = logger;
        _config = config;
        _storage = storage;

        _retryPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .WaitAndRetryForeverAsync(
                retryAttempt => TimeSpan.FromSeconds(Math.Min(Math.Pow(2, retryAttempt), 300)),
                (exception, retryCount, timeSpan) =>
                {
                    _logger.LogWarning("Retry {Count} in {Delay}: {Message}", retryCount, timeSpan, exception.Message);
                });

        _circuitBreakerPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .CircuitBreakerAsync(5, TimeSpan.FromMinutes(2));
    }

    public async Task DownloadEmailsAsync(DownloadOptions options, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("DownloadEmails");

        // Ensure Storage/DB is ready
        await _storage.InitializeAsync(ct);

        var policy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);

        await policy.ExecuteAsync(async () =>
        {
            using var client = new ImapClient { Timeout = 180_000 };
            try
            {
                await ConnectAndAuthenticateAsync(client, ct);

                var folders = options.AllFolders
                    ? await GetAllFoldersAsync(client, ct)
                    : [client.Inbox];

                foreach (var folder in folders)
                {
                    await ProcessFolderAsync(folder, options, ct);
                }
            }
            finally
            {
                if (client.IsConnected) await client.DisconnectAsync(true, ct);
            }
        });
    }

    private async Task ProcessFolderAsync(IMailFolder folder, DownloadOptions options, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("ProcessFolder");
        activity?.SetTag("folder", folder.FullName);

        try
        {
            await folder.OpenAsync(FolderAccess.ReadOnly, ct);

            // DELTA SYNC STRATEGY
            // 1. Get the last UID we successfully processed for this folder
            long lastUidVal = await _storage.GetLastUidAsync(folder.FullName, folder.UidValidity, ct);
            UniqueId? startUid = lastUidVal > 0 ? new UniqueId((uint)lastUidVal) : null;

            _logger.LogInformation("Syncing {Folder}. Last UID: {Uid}", folder.FullName, startUid);

            // 2. Search only for newer items
            var query = SearchQuery.All;
            if (startUid.HasValue)
            {
                // FIX: Use SearchQuery.Uids with a UniqueIdRange instead of SearchQuery.Uid
                // Fetch everything strictly greater than last seen
                var range = new UniqueIdRange(new UniqueId(startUid.Value.Id + 1), UniqueId.MaxValue);
                query = SearchQuery.Uids(range);
            }
            // Overrides for manual date ranges
            if (options.StartDate.HasValue) query = query.And(SearchQuery.DeliveredAfter(options.StartDate.Value));
            if (options.EndDate.HasValue) query = query.And(SearchQuery.DeliveredBefore(options.EndDate.Value));

            var uids = await folder.SearchAsync(query, ct);
            _logger.LogInformation("Found {Count} new messages in {Folder}", uids.Count, folder.FullName);

            // 3. Process in batches
            int batchSize = 50;
            for (int i = 0; i < uids.Count; i += batchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = uids.Skip(i).Take(batchSize).ToList();
                long maxUidInBatch = await DownloadBatchAsync(folder, batch, ct);

                // 4. Update checkpoint after successful batch
                if (maxUidInBatch > 0)
                {
                    // FIX: folder.UidValidity is a uint, it does not have an .Id property
                    await _storage.UpdateLastUidAsync(folder.FullName, maxUidInBatch, folder.UidValidity, ct);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing folder {Folder}", folder.FullName);
            throw; // Let Polly handle retry
        }
    }

    private async Task<long> DownloadBatchAsync(IMailFolder folder, IList<UniqueId> uids, CancellationToken ct)
    {
        long maxUid = 0;

        // 1. Fetch Envelopes first (PEEK) - lightweight
        var items = await folder.FetchAsync(uids, MessageSummaryItems.Envelope | MessageSummaryItems.UniqueId | MessageSummaryItems.InternalDate, ct);

        foreach (var item in items)
        {
            using var activity = DiagnosticsConfig.ActivitySource.StartActivity("ProcessEmail");

            // Track max UID for checkpointing
            if (item.UniqueId.Id > maxUid) maxUid = item.UniqueId.Id;

            // 2. Check DB before downloading body
            // Note: Imap Message-ID can be null, handle gracefully
            string msgId = item.Envelope.MessageId ?? $"NO-ID-{item.InternalDate?.Ticks}";

            if (await _storage.ExistsAsync(msgId, ct))
            {
                _logger.LogDebug("Skipping duplicate {Id}", msgId);
                continue;
            }

            // 3. Stream body
            try
            {
                using var stream = await folder.GetStreamAsync(item.UniqueId, ct);
                // FIX: Handle potential null MessageId explicitly to silence warning CS8604
                bool isNew = await _storage.SaveStreamAsync(
                    stream,
                    item.Envelope.MessageId ?? string.Empty,
                    item.InternalDate ?? DateTimeOffset.UtcNow,
                    folder.FullName,
                    ct);

                if (isNew) _logger.LogInformation("Downloaded: {Subject}", item.Envelope.Subject);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to download UID {Uid}", item.UniqueId);
                // We do NOT stop the batch for one failed email, but we might not want to update the cursor 
                // past this point if we want to retry it later. 
                // For simplicity in this script, we log and continue.
            }
        }

        return maxUid;
    }

    private async Task ConnectAndAuthenticateAsync(ImapClient client, CancellationToken ct)
    {
        _logger.LogInformation("Connecting to {Server}:{Port}", _config.Server, _config.Port);
        await client.ConnectAsync(_config.Server, _config.Port, SecureSocketOptions.SslOnConnect, ct);
        await client.AuthenticateAsync(_config.Username, _config.Password, ct);
    }

    private async Task<List<IMailFolder>> GetAllFoldersAsync(ImapClient client, CancellationToken ct)
    {
        var folders = new List<IMailFolder>();
        var personal = client.GetFolder(client.PersonalNamespaces[0]);
        await CollectFoldersRecursiveAsync(personal, folders, ct);
        if (!folders.Contains(client.Inbox)) folders.Insert(0, client.Inbox);
        return folders;
    }

    private async Task CollectFoldersRecursiveAsync(IMailFolder parent, List<IMailFolder> folders, CancellationToken ct)
    {
        foreach (var folder in await parent.GetSubfoldersAsync(false, ct))
        {
            folders.Add(folder);
            await CollectFoldersRecursiveAsync(folder, folders, ct);
        }
    }
}


================================================================================
FILE: MyImapDownloader/EmailMetadata.cs
SIZE: 0.39 KB
MODIFIED: 2025-12-23 04:59:40
================================================================================

namespace MyImapDownloader;

public class EmailMetadata
{
    public required string MessageId { get; set; }
    public string? Subject { get; set; }
    public string? From { get; set; }
    public string? To { get; set; }
    public DateTime Date { get; set; }
    public required string Folder { get; set; }
    public DateTime ArchivedAt { get; set; }
    public bool HasAttachments { get; set; }
}


================================================================================
FILE: MyImapDownloader/EmailStorageService.cs
SIZE: 13.27 KB
MODIFIED: 2025-12-23 04:55:49
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader;

public class EmailStorageService : IAsyncDisposable
{
    private readonly ILogger<EmailStorageService> _logger;
    private readonly string _baseDirectory;
    private readonly string _dbPath;
    private SqliteConnection? _connection;

    // Metrics
    private static readonly Counter<long> FilesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.files.written", unit: "files", description: "Number of email files written to disk");
    private static readonly Counter<long> BytesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.bytes.written", unit: "bytes", description: "Total bytes written to disk");
    private static readonly Histogram<double> WriteLatency = DiagnosticsConfig.Meter.CreateHistogram<double>(
        "storage.write.latency", unit: "ms", description: "Time to write email to disk");

    public EmailStorageService(ILogger<EmailStorageService> logger, string baseDirectory)
    {
        _logger = logger;
        _baseDirectory = baseDirectory;
        // Each output directory (account) gets its own isolated database
        _dbPath = Path.Combine(baseDirectory, "index.v1.db");
    }

    public async Task InitializeAsync(CancellationToken ct)
    {
        Directory.CreateDirectory(_baseDirectory);

        // Fault Tolerance: Try to open/init. If corrupt, back up and start over.
        try
        {
            await OpenAndMigrateAsync(ct);
        }
        catch (SqliteException ex)
        {
            _logger.LogError(ex, "Database corruption detected. Initiating recovery...");
            await RecoverDatabaseAsync(ct);
        }
    }

    private async Task OpenAndMigrateAsync(CancellationToken ct)
    {
        var connStr = new SqliteConnectionStringBuilder { DataSource = _dbPath }.ToString();
        _connection = new SqliteConnection(connStr);
        await _connection.OpenAsync(ct);

        // WAL mode for better concurrency
        using (var cmd = _connection.CreateCommand())
        {
            cmd.CommandText = "PRAGMA journal_mode = WAL; PRAGMA synchronous = NORMAL;";
            await cmd.ExecuteNonQueryAsync(ct);
        }

        using (var trans = await _connection.BeginTransactionAsync(ct))
        {
            var cmd = _connection.CreateCommand();
            cmd.Transaction = (SqliteTransaction)trans;
            cmd.CommandText = @"
                CREATE TABLE IF NOT EXISTS Messages (
                    MessageId TEXT PRIMARY KEY,
                    Folder TEXT NOT NULL,
                    ImportedAt TEXT NOT NULL
                );
                CREATE TABLE IF NOT EXISTS SyncState (
                    Folder TEXT PRIMARY KEY,
                    LastUid INTEGER NOT NULL,
                    UidValidity INTEGER NOT NULL
                );
                CREATE INDEX IF NOT EXISTS IX_Messages_Folder ON Messages(Folder);
            ";
            await cmd.ExecuteNonQueryAsync(ct);
            await trans.CommitAsync(ct);
        }
    }

    private async Task RecoverDatabaseAsync(CancellationToken ct)
    {
        if (_connection != null)
        {
            await _connection.DisposeAsync();
            _connection = null;
        }

        // 1. Move corrupt DB aside
        if (File.Exists(_dbPath))
        {
            var backupPath = _dbPath + $".corrupt.{DateTime.UtcNow.Ticks}";
            File.Move(_dbPath, backupPath);
            _logger.LogWarning("Moved corrupt database to {Path}", backupPath);
        }

        // 2. Create fresh DB
        await OpenAndMigrateAsync(ct);

        // 3. Rebuild from disk (Source of Truth)
        _logger.LogInformation("Rebuilding index from disk...");
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("RebuildIndex");
        int count = 0;

        // Scan all .meta.json files
        foreach (var metaFile in Directory.EnumerateFiles(_baseDirectory, "*.meta.json", SearchOption.AllDirectories))
        {
            try
            {
                var json = await File.ReadAllTextAsync(metaFile, ct);
                var meta = JsonSerializer.Deserialize<EmailMetadata>(json);
                if (!string.IsNullOrEmpty(meta?.MessageId) && !string.IsNullOrEmpty(meta.Folder))
                {
                    // Insert without validation to recover fast
                    await InsertMessageRecordAsync(meta.MessageId, meta.Folder, ct);
                    count++;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Skipping malformed meta file {File}: {Error}", metaFile, ex.Message);
            }
        }

        _logger.LogInformation("Recovery complete. Re-indexed {Count} emails.", count);
    }

    public async Task<long> GetLastUidAsync(string folderName, long currentValidity, CancellationToken ct)
    {
        if (_connection == null) await InitializeAsync(ct);

        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT LastUid, UidValidity FROM SyncState WHERE Folder = @folder";
        cmd.Parameters.AddWithValue("@folder", folderName);

        using var reader = await cmd.ExecuteReaderAsync(ct);
        if (await reader.ReadAsync(ct))
        {
            long storedValidity = reader.GetInt64(1);
            if (storedValidity == currentValidity)
            {
                return reader.GetInt64(0);
            }
            else
            {
                _logger.LogWarning("UIDVALIDITY changed for {Folder}. Resetting cursor.", folderName);
                return 0;
            }
        }
        return 0;
    }

    public async Task UpdateLastUidAsync(string folderName, long lastUid, long validity, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = @"
            INSERT INTO SyncState (Folder, LastUid, UidValidity) 
            VALUES (@folder, @uid, @validity)
            ON CONFLICT(Folder) DO UPDATE SET 
                LastUid = @uid, 
                UidValidity = @validity
            WHERE LastUid < @uid OR UidValidity != @validity;";

        cmd.Parameters.AddWithValue("@folder", folderName);
        cmd.Parameters.AddWithValue("@uid", lastUid);
        cmd.Parameters.AddWithValue("@validity", validity);
        await cmd.ExecuteNonQueryAsync(ct);
    }

    public async Task<bool> ExistsAsync(string messageId, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(messageId)) return false;

        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT 1 FROM Messages WHERE MessageId = @id LIMIT 1";
        cmd.Parameters.AddWithValue("@id", NormalizeMessageId(messageId));
        return (await cmd.ExecuteScalarAsync(ct)) != null;
    }

    /// <summary>
    /// Streams an email to disk. Returns true if saved, false if duplicate.
    /// </summary>
    public async Task<bool> SaveStreamAsync(
        Stream networkStream,
        string messageId,
        DateTimeOffset internalDate,
        string folderName,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("SaveStream");
        var sw = Stopwatch.StartNew();

        string safeId = string.IsNullOrWhiteSpace(messageId)
            ? ComputeHash(internalDate.ToString())
            : NormalizeMessageId(messageId);

        // 1. Double check DB (fast)
        if (await ExistsAsync(safeId, ct)) return false;

        string folderPath = GetFolderPath(folderName);
        EnsureMaildirStructure(folderPath);

        // 2. Stream to TMP file (atomic write pattern)
        string tempName = $"{internalDate.ToUnixTimeSeconds()}.{Guid.NewGuid()}.tmp";
        string tempPath = Path.Combine(folderPath, "tmp", tempName);

        long bytesWritten = 0;
        EmailMetadata? metadata = null;

        try
        {
            // Stream network -> disk directly (Low RAM usage)
            using (var fileStream = File.Create(tempPath))
            {
                await networkStream.CopyToAsync(fileStream, ct);
                bytesWritten = fileStream.Length;
            }

            // 3. Parse headers only from the file on disk to get metadata
            // We use MimeKit to parse just the headers, stopping at the body
            using (var fileStream = File.OpenRead(tempPath))
            {
                var parser = new MimeParser(fileStream, MimeFormat.Entity);
                var message = await parser.ParseMessageAsync(ct);

                // If ID was missing in Envelope, try to get it from parsed headers
                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(message.MessageId))
                {
                    safeId = NormalizeMessageId(message.MessageId);
                    // Re-check existence with the real ID
                    if (await ExistsAsync(safeId, ct))
                    {
                        File.Delete(tempPath);
                        return false;
                    }
                }

                metadata = new EmailMetadata
                {
                    MessageId = safeId,
                    Subject = message.Subject,
                    From = message.From?.ToString(),
                    To = message.To?.ToString(),
                    Date = message.Date.UtcDateTime,
                    Folder = folderName,
                    ArchivedAt = DateTime.UtcNow,
                    HasAttachments = message.Attachments.Any() // This might require parsing body, careful
                };
            }

            // 4. Move to CUR
            string finalName = GenerateFilename(internalDate, safeId);
            string finalPath = Path.Combine(folderPath, "cur", finalName);

            // Handle race condition if file exists (hash collision or race)
            if (File.Exists(finalPath))
            {
                File.Delete(tempPath);
                // Even if file exists on disk, ensure DB knows about it
                await InsertMessageRecordAsync(safeId, folderName, ct);
                return false;
            }

            File.Move(tempPath, finalPath);

            // 5. Write Sidecar
            if (metadata != null)
            {
                string metaPath = finalPath + ".meta.json";
                await using var metaStream = File.Create(metaPath);
                await JsonSerializer.SerializeAsync(metaStream, metadata, new JsonSerializerOptions { WriteIndented = true }, ct);
            }

            // 6. Update DB
            await InsertMessageRecordAsync(safeId, folderName, ct);

            sw.Stop();
            FilesWritten.Add(1);
            BytesWritten.Add(bytesWritten);
            WriteLatency.Record(sw.Elapsed.TotalMilliseconds);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save email {Id}", safeId);
            try { if (File.Exists(tempPath)) File.Delete(tempPath); } catch { }
            throw;
        }
    }

    private async Task InsertMessageRecordAsync(string messageId, string folder, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "INSERT OR IGNORE INTO Messages (MessageId, Folder, ImportedAt) VALUES (@id, @folder, @date)";
        cmd.Parameters.AddWithValue("@id", messageId);
        cmd.Parameters.AddWithValue("@folder", folder);
        cmd.Parameters.AddWithValue("@date", DateTime.UtcNow.ToString("O"));
        await cmd.ExecuteNonQueryAsync(ct);
    }

    private string GetFolderPath(string folderName)
    {
        string safeName = SanitizeForFilename(folderName, 100);
        return Path.Combine(_baseDirectory, safeName);
    }

    private static void EnsureMaildirStructure(string folderPath)
    {
        Directory.CreateDirectory(Path.Combine(folderPath, "cur"));
        Directory.CreateDirectory(Path.Combine(folderPath, "new"));
        Directory.CreateDirectory(Path.Combine(folderPath, "tmp"));
    }

    private static string GenerateFilename(DateTimeOffset date, string safeId)
    {
        string hostname = SanitizeForFilename(Environment.MachineName, 20);
        return $"{date.ToUnixTimeSeconds()}.{safeId}.{hostname}:2,S.eml";
    }

    private static string NormalizeMessageId(string messageId)
    {
        return messageId?.Trim().Trim('<', '>').ToLowerInvariant() ?? "unknown";
    }

    private static string ComputeHash(string input)
    {
        byte[] bytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));
        return Convert.ToHexString(bytes)[..16].ToLowerInvariant();
    }

    private static string SanitizeForFilename(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input)) return "unknown";
        var sb = new StringBuilder(Math.Min(input.Length, maxLength));
        foreach (char c in input)
        {
            if (char.IsLetterOrDigit(c) || c == '-' || c == '_' || c == '.') sb.Append(c);
            else if (sb.Length > 0 && sb[^1] != '_') sb.Append('_');
            if (sb.Length >= maxLength) break;
        }
        return sb.ToString().Trim('_');
    }

    public async ValueTask DisposeAsync()
    {
        if (_connection != null)
        {
            await _connection.DisposeAsync();
        }
    }
}


================================================================================
FILE: MyImapDownloader/ImapConfiguration.cs
SIZE: 0.31 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿namespace MyImapDownloader;

// Configuration Model
public class ImapConfiguration
{
    public required string Server { get; set; }
    public int Port { get; set; }
    public required string Username { get; set; }
    public required string Password { get; set; }
    public bool UseSsl { get; set; } = true;
}


================================================================================
FILE: MyImapDownloader/MyImapDownloader.csproj
SIZE: 1.14 KB
MODIFIED: 2025-12-23 04:50:11
================================================================================

﻿<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CommandLineParser" />
    <PackageReference Include="MailKit" />
    <PackageReference Include="Microsoft.Data.Sqlite" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    <PackageReference Include="Polly" />
  </ItemGroup>
  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>

================================================================================
FILE: MyImapDownloader/Program.cs
SIZE: 4.33 KB
MODIFIED: 2025-12-23 05:01:42
================================================================================

﻿using System.Diagnostics;
using CommandLine;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyImapDownloader;
using MyImapDownloader.Telemetry;

var parseResult = Parser.Default.ParseArguments<DownloadOptions>(args);

await parseResult.WithParsedAsync(async options =>
{
    var host = Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, config) =>
        {
            config.SetBasePath(AppContext.BaseDirectory);
            config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((context, logging) =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.SetMinimumLevel(options.Verbose ? LogLevel.Debug : LogLevel.Information);
            logging.AddTelemetryLogging(context.Configuration);
        })
        .ConfigureServices((context, services) =>
        {
            // Add telemetry
            services.AddTelemetry(context.Configuration);

            services.AddSingleton(options);
            services.AddSingleton(new ImapConfiguration
            {
                Server = options.Server,
                Username = options.Username,
                Password = options.Password,
                Port = options.Port
            });
            services.AddSingleton(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<EmailStorageService>>();
                return new EmailStorageService(logger, options.OutputDirectory);
            });
            services.AddTransient<EmailDownloadService>();
        })
        .Build();

    var downloadService = host.Services.GetRequiredService<EmailDownloadService>();
    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    var telemetryConfig = host.Services.GetRequiredService<TelemetryConfiguration>();

    // Create root activity for the entire session
    using var rootActivity = DiagnosticsConfig.ActivitySource.StartActivity(
        "EmailArchiveSession", ActivityKind.Server);

    rootActivity?.SetTag("service.name", telemetryConfig.ServiceName);
    rootActivity?.SetTag("service.version", telemetryConfig.ServiceVersion);
    rootActivity?.SetTag("host.name", Environment.MachineName);
    rootActivity?.SetTag("process.pid", Environment.ProcessId);
    rootActivity?.SetTag("telemetry.directory", telemetryConfig.OutputDirectory);

    var sessionStopwatch = Stopwatch.StartNew();

    try
    {
        logger.LogInformation("Starting email archive download...");
        logger.LogInformation("Output: {Output}", Path.GetFullPath(options.OutputDirectory));
        logger.LogInformation("Telemetry output: {TelemetryOutput}",
            Path.GetFullPath(telemetryConfig.OutputDirectory));

        rootActivity?.AddEvent(new ActivityEvent("DownloadStarted"));

        await downloadService.DownloadEmailsAsync(options, CancellationToken.None);

        sessionStopwatch.Stop();

        rootActivity?.SetTag("session_duration_ms", sessionStopwatch.ElapsedMilliseconds);
        rootActivity?.SetStatus(ActivityStatusCode.Ok);
        rootActivity?.AddEvent(new ActivityEvent("DownloadCompleted"));

        logger.LogInformation("Archive complete! Session duration: {Duration}ms",
            sessionStopwatch.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        rootActivity?.SetStatus(ActivityStatusCode.Error, ex.Message);
        rootActivity?.RecordException(ex);
        rootActivity?.AddEvent(new ActivityEvent("DownloadFailed", tags: new ActivityTagsCollection
        {
            ["exception.type"] = ex.GetType().FullName,
            ["exception.message"] = ex.Message
        }));

        logger.LogCritical(ex, "Fatal error during download");
        Environment.ExitCode = 1;
    }
    finally
    {
        // Ensure all telemetry is flushed before exit
        logger.LogInformation("Flushing telemetry data...");

        // Give time for async exporters to flush
        await Task.Delay(TimeSpan.FromSeconds(2));

        // Dispose file writers to flush remaining data
        var traceWriter = host.Services.GetService<JsonTelemetryFileWriter>();
        traceWriter?.Dispose();
    }
});

parseResult.WithNotParsed(errors =>
{
    Environment.ExitCode = 1;
});


================================================================================
FILE: MyImapDownloader.sln
SIZE: 1.48 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

﻿Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyImapDownloader", "MyImapDownloader\MyImapDownloader.csproj", "{8E3B6382-B4FA-491C-8889-8964BC556B71}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyImapDownloader.Tests", "MyImapDownloader.Tests\MyImapDownloader.Tests.csproj", "{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.Build.0 = Release|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1B2C3D4-E5F6-7890-ABCD-EF1234567890}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal


================================================================================
FILE: MyImapDownloader/Telemetry/ActivityExtension.cs
SIZE: 1.29 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for Activity to provide RecordException functionality
/// that works across OpenTelemetry versions.
/// </summary>
public static class ActivityExtensions
{
    /// <summary>
    /// Records an exception as an event on the activity with standard attributes.
    /// </summary>
    public static void RecordException(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        var tags = new ActivityTagsCollection
        {
            ["exception.type"] = exception.GetType().FullName,
            ["exception.message"] = exception.Message,
        };

        if (!string.IsNullOrEmpty(exception.StackTrace))
        {
            tags["exception.stacktrace"] = exception.StackTrace;
        }

        activity.AddEvent(new ActivityEvent("exception", tags: tags));
    }

    /// <summary>
    /// Sets the activity status to error with the exception message.
    /// </summary>
    public static void SetErrorStatus(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
        activity.RecordException(exception);
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/DiagnosticsConfig.cs
SIZE: 4.21 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Central configuration for all diagnostics sources used in the application.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyImapDownloader";
    public const string ServiceVersion = "1.0.0";

    // ActivitySource for distributed tracing
    public static readonly ActivitySource ActivitySource = new(ServiceName, ServiceVersion);

    // Meter for metrics
    public static readonly Meter Meter = new(ServiceName, ServiceVersion);

    // Counters
    public static readonly Counter<long> EmailsDownloaded = Meter.CreateCounter<long>(
        "emails.downloaded",
        unit: "emails",
        description: "Total number of emails successfully downloaded");

    public static readonly Counter<long> EmailsSkipped = Meter.CreateCounter<long>(
        "emails.skipped",
        unit: "emails",
        description: "Number of emails skipped (duplicates)");

    public static readonly Counter<long> EmailErrors = Meter.CreateCounter<long>(
        "emails.errors",
        unit: "errors",
        description: "Number of email download errors");

    public static readonly Counter<long> BytesDownloaded = Meter.CreateCounter<long>(
        "bytes.downloaded",
        unit: "bytes",
        description: "Total bytes downloaded");

    public static readonly Counter<long> FoldersProcessed = Meter.CreateCounter<long>(
        "folders.processed",
        unit: "folders",
        description: "Number of folders processed");

    public static readonly Counter<long> ConnectionAttempts = Meter.CreateCounter<long>(
        "connection.attempts",
        unit: "attempts",
        description: "Number of IMAP connection attempts");

    public static readonly Counter<long> RetryAttempts = Meter.CreateCounter<long>(
        "retry.attempts",
        unit: "retries",
        description: "Number of retry attempts due to failures");

    // Histograms
    public static readonly Histogram<double> EmailDownloadDuration = Meter.CreateHistogram<double>(
        "email.download.duration",
        unit: "ms",
        description: "Time taken to download individual emails");

    public static readonly Histogram<double> FolderProcessingDuration = Meter.CreateHistogram<double>(
        "folder.processing.duration",
        unit: "ms",
        description: "Time taken to process entire folders");

    public static readonly Histogram<double> BatchProcessingDuration = Meter.CreateHistogram<double>(
        "batch.processing.duration",
        unit: "ms",
        description: "Time taken to process email batches");

    public static readonly Histogram<long> EmailSize = Meter.CreateHistogram<long>(
        "email.size",
        unit: "bytes",
        description: "Size of downloaded emails");

    // Gauges (using ObservableGauge for current state)
    private static int _activeConnections;
    private static int _queuedEmails;
    private static long _totalEmailsInSession;

    public static readonly ObservableGauge<int> ActiveConnections = Meter.CreateObservableGauge(
        "connections.active",
        () => _activeConnections,
        unit: "connections",
        description: "Number of active IMAP connections");

    public static readonly ObservableGauge<int> QueuedEmails = Meter.CreateObservableGauge(
        "emails.queued",
        () => _queuedEmails,
        unit: "emails",
        description: "Number of emails queued for processing");

    public static readonly ObservableGauge<long> TotalEmailsInSession = Meter.CreateObservableGauge(
        "emails.total.session",
        () => _totalEmailsInSession,
        unit: "emails",
        description: "Total emails processed in current session");

    // Methods to update gauge values
    public static void SetActiveConnections(int count) => _activeConnections = count;
    public static void IncrementActiveConnections() => Interlocked.Increment(ref _activeConnections);
    public static void DecrementActiveConnections() => Interlocked.Decrement(ref _activeConnections);
    public static void SetQueuedEmails(int count) => _queuedEmails = count;
    public static void IncrementTotalEmails() => Interlocked.Increment(ref _totalEmailsInSession);
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileLogExporter.cs
SIZE: 3.05 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter : BaseExporter<LogRecord>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileLogExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs
SIZE: 6.55 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter : BaseExporter<Metric>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileMetricsExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        MeterVersion = metric.MeterVersion,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    _writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?> ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags;
    }

    private static MetricValue ExtractValue(Metric metric, MetricPoint point)
    {
        var value = new MetricValue();

        try
        {
            switch (metric.MetricType)
            {
                case MetricType.LongSum:
                    value.LongValue = point.GetSumLong();
                    break;
                case MetricType.DoubleSum:
                    value.DoubleValue = point.GetSumDouble();
                    break;
                case MetricType.LongGauge:
                    value.LongValue = point.GetGaugeLastValueLong();
                    break;
                case MetricType.DoubleGauge:
                    value.DoubleValue = point.GetGaugeLastValueDouble();
                    break;
                case MetricType.Histogram:
                    value.DoubleValue = point.GetHistogramSum();
                    value.Count = (long)point.GetHistogramCount();
                    value.Buckets = ExtractHistogramBuckets(point);
                    break;
                case MetricType.ExponentialHistogram:
                    // ExponentialHistogramData in OpenTelemetry 1.14.0 uses different API
                    // Access count and sum through the MetricPoint directly
                    var expHistData = point.GetExponentialHistogramData();
                    value.Count = GetExponentialHistogramCount(expHistData);
                    value.DoubleValue = GetExponentialHistogramSum(expHistData);
                    break;
            }
        }
        catch
        {
            // If extraction fails, return partial data
        }

        return value;
    }

    private static long GetExponentialHistogramCount(ExponentialHistogramData data)
    {
        try
        {
            // Try accessing via reflection for API compatibility
            var countProperty = typeof(ExponentialHistogramData).GetProperty("Count");
            if (countProperty != null)
            {
                var val = countProperty.GetValue(data);
                if (val is long l) return l;
                if (val is ulong ul) return (long)ul;
                if (val is int i) return i;
            }

            // Try ZeroCount + positive/negative bucket counts as fallback
            var zeroCountProp = typeof(ExponentialHistogramData).GetProperty("ZeroCount");
            if (zeroCountProp != null)
            {
                var zeroCount = Convert.ToInt64(zeroCountProp.GetValue(data) ?? 0);
                return zeroCount; // This is a partial count but better than nothing
            }
        }
        catch
        {
            // Ignore reflection errors
        }

        return 0;
    }

    private static double GetExponentialHistogramSum(ExponentialHistogramData data)
    {
        try
        {
            // Try to access Sum via reflection for API compatibility
            var sumProperty = typeof(ExponentialHistogramData).GetProperty("Sum");
            if (sumProperty != null)
            {
                var val = sumProperty.GetValue(data);
                if (val is double d) return d;
            }
        }
        catch
        {
            // Ignore reflection errors
        }

        return 0.0;
    }

    private static List<HistogramBucket>? ExtractHistogramBuckets(MetricPoint point)
    {
        try
        {
            var buckets = new List<HistogramBucket>();
            foreach (var bucket in point.GetHistogramBuckets())
            {
                buckets.Add(new HistogramBucket
                {
                    ExplicitBound = bucket.ExplicitBound,
                    BucketCount = bucket.BucketCount
                });
            }
            return buckets.Count > 0 ? buckets : null;
        }
        catch
        {
            return null;
        }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public string? MeterVersion { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public MetricValue? Value { get; init; }
}

public record MetricValue
{
    public long? LongValue { get; set; }
    public double? DoubleValue { get; set; }
    public long? Count { get; set; }
    public List<HistogramBucket>? Buckets { get; set; }
}

public record HistogramBucket
{
    public double ExplicitBound { get; init; }
    public long BucketCount { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileTraceExporter.cs
SIZE: 3.93 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;
using OpenTelemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter : BaseExporter<Activity>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileTraceExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList(),
                    Links = activity.Links.Select(l => new SpanLink
                    {
                        TraceId = l.Context.TraceId.ToString(),
                        SpanId = l.Context.SpanId.ToString()
                    }).ToList(),
                    Resource = new ResourceInfo
                    {
                        ServiceName = activity.GetTagItem("service.name")?.ToString(),
                        ServiceVersion = activity.GetTagItem("service.version")?.ToString()
                    }
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
    public List<SpanLink>? Links { get; init; }
    public ResourceInfo? Resource { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}

public record SpanLink
{
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
}

public record ResourceInfo
{
    public string? ServiceName { get; init; }
    public string? ServiceVersion { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs
SIZE: 4.98 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using System.Collections.Concurrent;
using System.Text.Json;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Thread-safe JSON file writer that manages daily files with size limits.
/// Each telemetry record is written as a separate JSON line (JSONL format).
/// Gracefully handles write failures without crashing the application.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _baseDirectory;
    private readonly string _prefix;
    private readonly long _maxFileSizeBytes;
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly ConcurrentQueue<object> _buffer = new();
    private readonly Timer _flushTimer;
    private readonly JsonSerializerOptions _jsonOptions;

    private string _currentDate = "";
    private string _currentFilePath = "";
    private int _fileSequence;
    private long _currentFileSize;
    private bool _disposed;
    private bool _writeEnabled = true;

    public JsonTelemetryFileWriter(
        string baseDirectory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _baseDirectory = baseDirectory;
        _prefix = prefix;
        _maxFileSizeBytes = maxFileSizeBytes;

        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = false, // JSONL format - single line per record
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };

        // Try to create base directory - if it fails, disable writes
        try
        {
            Directory.CreateDirectory(_baseDirectory);
        }
        catch
        {
            _writeEnabled = false;
        }

        _flushTimer = new Timer(_ => FlushAsync().ConfigureAwait(false), null, flushInterval, flushInterval);
    }

    public void Enqueue(object record)
    {
        if (_disposed || !_writeEnabled) return;
        _buffer.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        if (_disposed || !_writeEnabled || _buffer.IsEmpty) return;

        if (!await _writeLock.WaitAsync(TimeSpan.FromSeconds(5)))
            return; // Skip this flush cycle if we can't get the lock

        try
        {
            var records = new List<object>();
            while (_buffer.TryDequeue(out var record))
            {
                records.Add(record);
            }

            foreach (var record in records)
            {
                await WriteRecordAsync(record);
            }
        }
        catch
        {
            // If we consistently fail to write, disable future writes
            // to avoid accumulating memory
            if (_buffer.Count > 10000)
            {
                _writeEnabled = false;
                while (_buffer.TryDequeue(out _)) { } // Clear buffer
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordAsync(object record)
    {
        if (!_writeEnabled) return;

        try
        {
            string today = DateTime.UtcNow.ToString("yyyy-MM-dd");

            // Check if we need a new file (new day or size exceeded)
            if (today != _currentDate || _currentFileSize >= _maxFileSizeBytes)
            {
                if (today != _currentDate)
                {
                    _currentDate = today;
                    _fileSequence = 0;
                }
                RotateFile();
            }

            // Each record is a complete JSON object on a single line (JSONL format)
            string json = JsonSerializer.Serialize(record, record.GetType(), _jsonOptions);
            string line = json + Environment.NewLine;
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(line);

            // Check if adding this record would exceed size limit
            if (_currentFileSize + bytes.Length > _maxFileSizeBytes && _currentFileSize > 0)
            {
                RotateFile();
            }

            await File.AppendAllTextAsync(_currentFilePath, line);
            _currentFileSize += bytes.Length;
        }
        catch
        {
            // Individual write failures are silently ignored
            // The application continues normally
        }
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = Path.Combine(
            _baseDirectory,
            $"{_prefix}_{_currentDate}_{_fileSequence:D4}.jsonl");

        try
        {
            _currentFileSize = File.Exists(_currentFilePath) ? new FileInfo(_currentFilePath).Length : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _flushTimer.Dispose();

        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }

        _writeLock.Dispose();
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryConfiguration.cs
SIZE: 0.77 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs
SIZE: 3.16 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification
/// with graceful fallback behavior.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName = "MyImapDownloader")
    {
        // Try locations in order of preference
        var candidates = GetCandidateDirectories(appName);

        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }

        return null; // No writable location found - telemetry will be disabled
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        // 1. XDG_DATA_HOME (Linux/macOS) or LocalApplicationData (Windows)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, appName, "telemetry");
        }

        // 2. Platform-specific user data directory
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            yield return Path.Combine(localAppData, appName, "telemetry");
        }

        // 3. XDG_STATE_HOME for state/log data (more appropriate for telemetry)
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, appName, "telemetry");
        }

        // 4. Fallback to ~/.local/state on Unix-like systems
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            yield return Path.Combine(homeDir, ".local", "state", appName, "telemetry");
            yield return Path.Combine(homeDir, ".local", "share", appName, "telemetry");
        }

        // 5. Directory relative to executable
        var exeDir = AppContext.BaseDirectory;
        if (!string.IsNullOrEmpty(exeDir))
        {
            yield return Path.Combine(exeDir, "telemetry");
        }

        // 6. Current working directory as last resort
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            // Attempt to create the directory
            Directory.CreateDirectory(path);

            // Verify we can write to it
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryExtensions.cs
SIZE: 8.33 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for configuring OpenTelemetry with JSON file exporters.
/// </summary>
public static class TelemetryExtensions
{
    public static IServiceCollection AddTelemetry(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);
        services.AddSingleton(config);

        // Resolve telemetry directory with XDG compliance and fallback
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);

        if (telemetryBaseDir == null)
        {
            // No writable location found - register placeholder services
            // Telemetry will be effectively disabled but app continues normally
            services.AddSingleton<ITelemetryWriterProvider>(new NullTelemetryWriterProvider());
            config.EnableTracing = false;
            config.EnableMetrics = false;
            config.EnableLogging = false;

            return services;
        }

        // Update config with resolved directory
        config.OutputDirectory = telemetryBaseDir;

        var tracesDir = Path.Combine(telemetryBaseDir, "traces");
        var metricsDir = Path.Combine(telemetryBaseDir, "metrics");
        var logsDir = Path.Combine(telemetryBaseDir, "logs");

        TryCreateDirectory(tracesDir);
        TryCreateDirectory(metricsDir);
        TryCreateDirectory(logsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        // Create file writers
        JsonTelemetryFileWriter? traceWriter = null;
        JsonTelemetryFileWriter? metricsWriter = null;
        JsonTelemetryFileWriter? logsWriter = null;

        try
        {
            traceWriter = new JsonTelemetryFileWriter(
                tracesDir, "traces", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Trace writing disabled */ }

        try
        {
            metricsWriter = new JsonTelemetryFileWriter(
                metricsDir, "metrics", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Metrics writing disabled */ }

        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Log writing disabled */ }

        // Register the writer provider instead of nullable writers directly
        var writerProvider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);
        services.AddSingleton<ITelemetryWriterProvider>(writerProvider);

        // Also register the trace writer directly for Program.cs disposal
        if (traceWriter != null)
        {
            services.AddSingleton(traceWriter);
        }

        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(
                serviceName: config.ServiceName,
                serviceVersion: config.ServiceVersion)
            .AddAttributes(new Dictionary<string, object>
            {
                ["host.name"] = Environment.MachineName,
                ["os.type"] = Environment.OSVersion.Platform.ToString(),
                ["os.version"] = Environment.OSVersion.VersionString,
                ["process.runtime.name"] = ".NET",
                ["process.runtime.version"] = Environment.Version.ToString(),
                ["telemetry.directory"] = telemetryBaseDir
            });

        // Configure OpenTelemetry
        var otelBuilder = services.AddOpenTelemetry()
            .ConfigureResource(r => r.AddService(config.ServiceName, serviceVersion: config.ServiceVersion));

        if (config.EnableTracing && traceWriter != null)
        {
            otelBuilder.WithTracing(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddSource(DiagnosticsConfig.ServiceName)
                    .SetSampler(new AlwaysOnSampler())
                    .AddProcessor(new BatchActivityExportProcessor(
                        new JsonFileTraceExporter(traceWriter),
                        maxQueueSize: 2048,
                        scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                        exporterTimeoutMilliseconds: 30000,
                        maxExportBatchSize: 512));
            });
        }

        if (config.EnableMetrics && metricsWriter != null)
        {
            otelBuilder.WithMetrics(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddMeter(DiagnosticsConfig.ServiceName)
                    .AddRuntimeInstrumentation()
                    .AddReader(new PeriodicExportingMetricReader(
                        new JsonFileMetricsExporter(metricsWriter),
                        exportIntervalMilliseconds: config.MetricsExportIntervalSeconds * 1000));
            });
        }

        return services;
    }

    public static ILoggingBuilder AddTelemetryLogging(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);

        if (!config.EnableLogging)
            return builder;

        // Resolve telemetry directory
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        if (telemetryBaseDir == null)
            return builder; // No writable location - skip telemetry logging

        var logsDir = Path.Combine(telemetryBaseDir, "logs");
        if (!TryCreateDirectory(logsDir))
            return builder;

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        JsonTelemetryFileWriter? logsWriter = null;
        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch
        {
            return builder; // Failed to create writer - skip telemetry logging
        }

        builder.AddOpenTelemetry(options =>
        {
            options.IncludeFormattedMessage = true;
            options.IncludeScopes = true;
            options.ParseStateValues = true;
            options.AddProcessor(new BatchLogRecordExportProcessor(
                new JsonFileLogExporter(logsWriter),
                maxQueueSize: 2048,
                scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                exporterTimeoutMilliseconds: 30000,
                maxExportBatchSize: 512));
        });

        return builder;
    }

    private static bool TryCreateDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

/// <summary>
/// Interface for accessing telemetry file writers.
/// </summary>
public interface ITelemetryWriterProvider
{
    JsonTelemetryFileWriter? TraceWriter { get; }
    JsonTelemetryFileWriter? MetricsWriter { get; }
    JsonTelemetryFileWriter? LogsWriter { get; }
}

/// <summary>
/// Provides access to telemetry file writers.
/// </summary>
public sealed class TelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter { get; }
    public JsonTelemetryFileWriter? MetricsWriter { get; }
    public JsonTelemetryFileWriter? LogsWriter { get; }

    public TelemetryWriterProvider(
        JsonTelemetryFileWriter? traceWriter,
        JsonTelemetryFileWriter? metricsWriter,
        JsonTelemetryFileWriter? logsWriter)
    {
        TraceWriter = traceWriter;
        MetricsWriter = metricsWriter;
        LogsWriter = logsWriter;
    }
}

/// <summary>
/// Null implementation when telemetry is disabled.
/// </summary>
public sealed class NullTelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => null;
    public JsonTelemetryFileWriter? MetricsWriter => null;
    public JsonTelemetryFileWriter? LogsWriter => null;
}


================================================================================
FILE: MyImapDownloader.Tests/DownloadOptionsTests.cs
SIZE: 3.99 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using FluentAssertions;

namespace MyImapDownloader.Tests;

public class DownloadOptionsTests
{
    [Test]
    public async Task DefaultValues_AreSet()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output"
        };

        await Assert.That(options.Port).IsEqualTo(993);
        await Assert.That(options.StartDate).IsNull();
        await Assert.That(options.EndDate).IsNull();
        await Assert.That(options.AllFolders).IsFalse();
        await Assert.That(options.Verbose).IsFalse();
    }

    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var options = new DownloadOptions
        {
            Server = "mail.test.com",
            Username = "testuser",
            Password = "testpass",
            OutputDirectory = "emails"
        };

        await Assert.That(options.Server).IsEqualTo("mail.test.com");
        await Assert.That(options.Username).IsEqualTo("testuser");
        await Assert.That(options.Password).IsEqualTo("testpass");
        await Assert.That(options.OutputDirectory).IsEqualTo("emails");
    }

    [Test]
    public async Task Port_CanBeCustomized()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            Port = 143
        };

        await Assert.That(options.Port).IsEqualTo(143);
    }

    [Test]
    public async Task DateFilters_CanBeSet()
    {
        var startDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        var endDate = new DateTime(2024, 12, 31, 23, 59, 59, DateTimeKind.Utc);

        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            StartDate = startDate,
            EndDate = endDate
        };

        await Assert.That(options.StartDate).IsEqualTo(startDate);
        await Assert.That(options.EndDate).IsEqualTo(endDate);
    }

    [Test]
    public async Task DateRange_CanBeCalculated()
    {
        var startDate = new DateTime(2024, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        var endDate = new DateTime(2024, 12, 31, 23, 59, 59, DateTimeKind.Utc);

        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            StartDate = startDate,
            EndDate = endDate
        };

        var daySpan = (options.EndDate!.Value - options.StartDate!.Value).Days;
        await Assert.That(daySpan).IsEqualTo(365);
    }

    [Test]
    public async Task AllFolders_CanBeEnabled()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            AllFolders = true
        };

        await Assert.That(options.AllFolders).IsTrue();
    }

    [Test]
    public async Task Verbose_CanBeEnabled()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output",
            Verbose = true
        };

        await Assert.That(options.Verbose).IsTrue();
    }

    [Test]
    public async Task NullableDateProperties_CanRemainNull()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password123",
            OutputDirectory = "output"
        };

        await Assert.That(options.StartDate).IsNull();
        await Assert.That(options.EndDate).IsNull();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/EmailDownloadExceptionTests.cs
SIZE: 3.46 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using FluentAssertions;

namespace MyImapDownloader.Tests;

public class EmailDownloadExceptionTests
{
    [Test]
    public async Task Constructor_SetsAllProperties()
    {
        var inner = new IOException("Network error");
        var exception = new EmailDownloadException("Download failed", 42, inner);

        await Assert.That(exception.Message).IsEqualTo("Download failed");
        await Assert.That(exception.MessageIndex).IsEqualTo(42);
        await Assert.That(exception.InnerException).IsEqualTo(inner);
    }

    [Test]
    public async Task MessageIndex_IsAccessible()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Error at index", 5, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(5);
    }

    [Test]
    public async Task InheritsFromException()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Test", 0, inner);

        exception.Should().BeAssignableTo<Exception>();
    }

    [Test]
    public async Task CanBeCaughtAsException()
    {
        Exception? caught = null;
        var inner = new Exception("Inner");

        try
        {
            throw new EmailDownloadException("Test error", 1, inner);
        }
        catch (Exception ex)
        {
            caught = ex;
        }

        await Assert.That(caught).IsNotNull();
        caught.Should().BeOfType<EmailDownloadException>();
    }

    [Test]
    public async Task CanBeCaughtSpecifically()
    {
        EmailDownloadException? caught = null;
        var inner = new Exception("Inner");

        try
        {
            throw new EmailDownloadException("Specific error", 10, inner);
        }
        catch (EmailDownloadException ex)
        {
            caught = ex;
        }

        await Assert.That(caught).IsNotNull();
        await Assert.That(caught!.Message).IsEqualTo("Specific error");
        await Assert.That(caught.MessageIndex).IsEqualTo(10);
    }

    [Test]
    public async Task InnerException_ChainIsPreserved()
    {
        var level1 = new InvalidOperationException("Level 1");
        var level2 = new EmailDownloadException("Level 2", 1, level1);
        var level3 = new EmailDownloadException("Level 3", 2, level2);

        await Assert.That(level3.InnerException).IsEqualTo(level2);
        await Assert.That(level3.InnerException!.InnerException).IsEqualTo(level1);
    }

    [Test]
    public async Task StackTrace_IsAvailable_WhenThrown()
    {
        EmailDownloadException? caught = null;

        try
        {
            ThrowHelper();
        }
        catch (EmailDownloadException ex)
        {
            caught = ex;
        }

        caught!.StackTrace.Should().NotBeNullOrEmpty();
        caught.StackTrace.Should().Contain("ThrowHelper");
    }

    [Test]
    public async Task MessageIndex_ZeroIsValid()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("First message failed", 0, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(0);
    }

    [Test]
    public async Task MessageIndex_LargeValueIsValid()
    {
        var inner = new Exception("Inner");
        var exception = new EmailDownloadException("Message failed", 999999, inner);

        await Assert.That(exception.MessageIndex).IsEqualTo(999999);
    }

    private static void ThrowHelper()
    {
        var inner = new Exception("Inner");
        throw new EmailDownloadException("From helper", 0, inner);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/ImapConfigurationTests.cs
SIZE: 3.99 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using FluentAssertions;
using Microsoft.Extensions.Configuration;

namespace MyImapDownloader.Tests;

public class ImapConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreSet()
    {
        var config = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };

        await Assert.That(config.Port).IsEqualTo(0); // No default in current implementation
        await Assert.That(config.UseSsl).IsTrue();
        await Assert.That(config.Server).IsEmpty();
        await Assert.That(config.Username).IsEmpty();
        await Assert.That(config.Password).IsEmpty();
    }

    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret123"
        };

        await Assert.That(config.Server).IsEqualTo("imap.example.com");
        await Assert.That(config.Username).IsEqualTo("user@example.com");
        await Assert.That(config.Password).IsEqualTo("secret123");
    }

    [Test]
    public async Task CanBindFromConfiguration()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Imap:Server"] = "imap.example.com",
            ["Imap:Port"] = "587",
            ["Imap:Username"] = "user@example.com",
            ["Imap:Password"] = "secret123",
            ["Imap:UseSsl"] = "false"
        };

        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        var imapConfig = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };
        configuration.GetSection("Imap").Bind(imapConfig);

        await Assert.That(imapConfig.Server).IsEqualTo("imap.example.com");
        await Assert.That(imapConfig.Port).IsEqualTo(587);
        await Assert.That(imapConfig.Username).IsEqualTo("user@example.com");
        await Assert.That(imapConfig.Password).IsEqualTo("secret123");
        await Assert.That(imapConfig.UseSsl).IsFalse();
    }

    [Test]
    public async Task PartialConfiguration_UsesDefaults()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Imap:Server"] = "mail.test.com",
            ["Imap:Username"] = "testuser",
            ["Imap:Password"] = "testpass"
        };

        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        var imapConfig = new ImapConfiguration
        {
            Server = "",
            Username = "",
            Password = ""
        };
        configuration.GetSection("Imap").Bind(imapConfig);

        // Configured values
        await Assert.That(imapConfig.Server).IsEqualTo("mail.test.com");
        await Assert.That(imapConfig.Username).IsEqualTo("testuser");
        await Assert.That(imapConfig.Password).IsEqualTo("testpass");

        // Default value preserved
        await Assert.That(imapConfig.UseSsl).IsTrue();
    }

    [Test]
    [Arguments(993, true)]   // Standard IMAPS
    [Arguments(143, false)]  // Standard IMAP
    [Arguments(587, true)]   // Custom with SSL
    [Arguments(2993, true)]  // Non-standard with SSL
    public async Task PortAndSslCombinations_AreValid(int port, bool useSsl)
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password",
            Port = port,
            UseSsl = useSsl
        };

        await Assert.That(config.Port).IsEqualTo(port);
        await Assert.That(config.UseSsl).IsEqualTo(useSsl);
    }

    [Test]
    public async Task UseSsl_DefaultsToTrue()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "password"
        };

        await Assert.That(config.UseSsl).IsTrue();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/MyImapDownloader.Tests.csproj
SIZE: 0.72 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TUnit requires the test project to be an Exe -->
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="FluentAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader\MyImapDownloader.csproj" />
  </ItemGroup>

</Project>


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/ActivityExtensionsTests.cs
SIZE: 5.56 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using System.Diagnostics;
using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class ActivityExtensionsTests : IDisposable
{
    private readonly ActivitySource _activitySource;
    private readonly ActivityListener _listener;
    private readonly List<Activity> _recordedActivities = [];

    public ActivityExtensionsTests()
    {
        _activitySource = new ActivitySource("TestSource");
        _listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded,
            ActivityStopped = activity => _recordedActivities.Add(activity)
        };
        ActivitySource.AddActivityListener(_listener);
    }

    public void Dispose()
    {
        _listener.Dispose();
        _activitySource.Dispose();
    }

    [Test]
    public async Task RecordException_AddsExceptionEvent_ToActivity()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new InvalidOperationException("Test error message");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(1);

        var exceptionEvent = events[0];
        await Assert.That(exceptionEvent.Name).IsEqualTo("exception");
    }

    [Test]
    public async Task RecordException_IncludesExceptionType()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new ArgumentNullException("paramName");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.type");
        tags["exception.type"].Should().Be(typeof(ArgumentNullException).FullName);
    }

    [Test]
    public async Task RecordException_IncludesExceptionMessage()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Specific error details");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.message");
        tags["exception.message"]!.ToString().Should().Contain("Specific error details");
    }

    [Test]
    public async Task RecordException_IncludesStackTrace_WhenAvailable()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        Exception? capturedException = null;
        try
        {
            throw new Exception("Error with stack trace");
        }
        catch (Exception ex)
        {
            capturedException = ex;
        }

        activity.RecordException(capturedException!);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.stacktrace");
        tags["exception.stacktrace"]!.ToString().Should().Contain("RecordException_IncludesStackTrace");
    }

    [Test]
    public async Task RecordException_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.RecordException(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_WithNullException_DoesNotThrow()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        // Should not throw
        activity.RecordException(null!);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(0);
    }

    [Test]
    public async Task SetErrorStatus_SetsStatusToError()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Operation failed");

        activity.SetErrorStatus(exception);

        await Assert.That(activity!.Status).IsEqualTo(ActivityStatusCode.Error);
    }

    [Test]
    public async Task SetErrorStatus_IncludesExceptionMessage_InStatusDescription()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Detailed failure reason");

        activity.SetErrorStatus(exception);

        activity!.StatusDescription.Should().Contain("Detailed failure reason");
    }

    [Test]
    public async Task SetErrorStatus_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.SetErrorStatus(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_HandlesNestedExceptions()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var inner = new ArgumentException("Inner error");
        var outer = new InvalidOperationException("Outer error", inner);

        activity.RecordException(outer);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        // Should record the outer exception's details
        tags["exception.type"].Should().Be(typeof(InvalidOperationException).FullName);
        tags["exception.message"]!.ToString().Should().Contain("Outer error");
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/DiagnosticsConfigTests.cs
SIZE: 2.53 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class DiagnosticsConfigTests
{
    [Test]
    public async Task ServiceName_IsExpectedValue()
    {
        var serviceName = DiagnosticsConfig.ServiceName;
        await Assert.That(serviceName).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_HasCorrectName()
    {
        var source = DiagnosticsConfig.ActivitySource;

        source.Should().NotBeNull();
        await Assert.That(source.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task Meter_HasCorrectName()
    {
        var meter = DiagnosticsConfig.Meter;

        meter.Should().NotBeNull();
        await Assert.That(meter.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_CanCreateActivity()
    {
        // Need a listener to actually create activities
        using var listener = new ActivityListener
        {
            ShouldListenTo = source => source.Name == DiagnosticsConfig.ServiceName,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("TestOperation");

        activity.Should().NotBeNull();
        await Assert.That(activity!.OperationName).IsEqualTo("TestOperation");
    }

    [Test]
    public async Task Meter_CanCreateCounter()
    {
        var counter = DiagnosticsConfig.Meter.CreateCounter<long>("test_counter");

        counter.Should().NotBeNull();
        counter.Name.Should().Be("test_counter");
    }

    [Test]
    public async Task Meter_CanCreateHistogram()
    {
        var histogram = DiagnosticsConfig.Meter.CreateHistogram<double>("test_histogram");

        histogram.Should().NotBeNull();
        histogram.Name.Should().Be("test_histogram");
    }

    [Test]
    public async Task ActivitySource_IsSingleton()
    {
        var source1 = DiagnosticsConfig.ActivitySource;
        var source2 = DiagnosticsConfig.ActivitySource;

        var areSame = ReferenceEquals(source1, source2);
        await Assert.That(areSame).IsTrue();
    }

    [Test]
    public async Task Meter_IsSingleton()
    {
        var meter1 = DiagnosticsConfig.Meter;
        var meter2 = DiagnosticsConfig.Meter;

        var areSame = ReferenceEquals(meter1, meter2);
        await Assert.That(areSame).IsTrue();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/JsonExporterTests.cs
SIZE: 4.73 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using System.Diagnostics;
using FluentAssertions;
using MyImapDownloader.Telemetry;
using OpenTelemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonFileTraceExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonFileTraceExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"trace_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix = "traces")
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileTraceExporter(null);

        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }

    [Test]
    public async Task Export_WithWriter_EnqueuesRecords()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        using var activitySource = new ActivitySource("Test");
        using var listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = activitySource.StartActivity("ExportTest");
        activity?.SetTag("test.key", "test.value");
        activity?.Stop();

        var batch = new Batch<Activity>([activity!], 1);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);

        // Flush and verify
        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("ExportTest");
    }

    [Test]
    public async Task Export_ReturnsSuccess_EvenOnError()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        // Empty batch should still return success
        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileLogExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileLogExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"log_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileLogExporter(null);

        // Test with empty batch
        var batch = new Batch<OpenTelemetry.Logs.LogRecord>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileMetricsExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileMetricsExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"metrics_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileMetricsExporter(null);

        var batch = new Batch<OpenTelemetry.Metrics.Metric>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/JsonTelemetryFileWriterTests.cs
SIZE: 5.63 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using System.Text.Json;
using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonTelemetryFileWriterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonTelemetryFileWriterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"telemetry_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string? subDir = null, string prefix = "test", long maxSize = 1024 * 1024)
    {
        var dir = subDir != null ? Path.Combine(_testDirectory, subDir) : _testDirectory;
        var writer = new JsonTelemetryFileWriter(dir, prefix, maxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_CreatesDirectory_WhenItDoesNotExist()
    {
        var newDir = Path.Combine(_testDirectory, "new_subdir");

        var writer = new JsonTelemetryFileWriter(newDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        await Assert.That(Directory.Exists(newDir)).IsTrue();
    }

    [Test]
    public async Task Enqueue_DoesNotThrow_WhenCalled()
    {
        var writer = CreateWriter();

        var record = new { Message = "Test", Timestamp = DateTime.UtcNow };

        // Should not throw
        writer.Enqueue(record);

        // If we get here, the test passed
        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task FlushAsync_WritesEnqueuedRecords_ToFile()
    {
        var writer = CreateWriter();

        var record = new TestRecord { Id = 1, Message = "Hello" };
        writer.Enqueue(record);

        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("Hello");
        content.Should().Contain("\"id\":1");
    }

    [Test]
    public async Task FlushAsync_WritesMultipleRecords_InJsonlFormat()
    {
        var writer = CreateWriter();

        writer.Enqueue(new TestRecord { Id = 1, Message = "First" });
        writer.Enqueue(new TestRecord { Id = 2, Message = "Second" });
        writer.Enqueue(new TestRecord { Id = 3, Message = "Third" });

        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        var lines = await File.ReadAllLinesAsync(files[0]);

        // Each record should be on its own line (JSONL format)
        await Assert.That(lines.Length).IsEqualTo(3);

        // Each line should be valid JSON
        foreach (var line in lines)
        {
            var parsed = JsonSerializer.Deserialize<TestRecord>(line);
            parsed.Should().NotBeNull();
        }
    }

    [Test]
    public async Task Dispose_CanBeCalledMultipleTimes()
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, "dispose", 1024 * 1024, TimeSpan.FromSeconds(30));

        // Should not throw when called multiple times
        writer.Dispose();
        writer.Dispose();
        writer.Dispose();

        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task Dispose_FlushesRemainingRecords()
    {
        var subDir = Path.Combine(_testDirectory, "dispose_flush");
        Directory.CreateDirectory(subDir);

        var writer = new JsonTelemetryFileWriter(subDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));

        writer.Enqueue(new { Test = true });

        // Force a flush before dispose to ensure it works
        await writer.FlushAsync();

        writer.Dispose();

        var files = Directory.GetFiles(subDir, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }

    [Test]
    public async Task FlushAsync_WithEmptyBuffer_DoesNotCreateFile()
    {
        var emptyDir = Path.Combine(_testDirectory, "empty");
        Directory.CreateDirectory(emptyDir);

        var writer = CreateWriter("empty");

        await writer.FlushAsync();

        var files = Directory.GetFiles(emptyDir, "*.jsonl");
        await Assert.That(files.Length).IsEqualTo(0);
    }

    [Test]
    public async Task FileRotation_OccursWhenSizeExceeded()
    {
        // Small max file size to trigger rotation quickly
        const long smallMaxSize = 500; // 500 bytes
        var rotateDir = Path.Combine(_testDirectory, "rotate");
        Directory.CreateDirectory(rotateDir);

        var writer = new JsonTelemetryFileWriter(rotateDir, "rotate", smallMaxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        // Write enough data to trigger rotation (each record ~50-100 bytes)
        for (int i = 0; i < 20; i++)
        {
            writer.Enqueue(new TestRecord { Id = i, Message = $"Record number {i} with some padding text" });
        }

        await writer.FlushAsync();

        var files = Directory.GetFiles(rotateDir, "rotate_*.jsonl");

        // Should have created multiple files due to rotation
        await Assert.That(files.Length).IsGreaterThan(1);
    }

    private record TestRecord
    {
        public int Id { get; init; }
        public string? Message { get; init; }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryConfigurationTests.cs
SIZE: 2.66 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreReasonable()
    {
        var config = new TelemetryConfiguration();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.ServiceVersion).IsEqualTo("1.0.0");
        await Assert.That(config.EnableTracing).IsTrue();
        await Assert.That(config.EnableMetrics).IsTrue();
        await Assert.That(config.EnableLogging).IsTrue();
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(25);
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(5);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(15);
    }

    [Test]
    public async Task MaxFileSizeBytes_CalculatesCorrectly()
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = 10 };

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(10L * 1024L * 1024L);
    }

    [Test]
    [Arguments(1)]
    [Arguments(25)]
    [Arguments(100)]
    [Arguments(1024)]
    public async Task MaxFileSizeBytes_ScalesWithMB(int megabytes)
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = megabytes };
        var expected = (long)megabytes * 1024L * 1024L;

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(expected);
    }

    [Test]
    public async Task SectionName_IsExpectedValue()
    {
        var sectionName = TelemetryConfiguration.SectionName;
        await Assert.That(sectionName).IsEqualTo("Telemetry");
    }

    [Test]
    public async Task AllPropertiesAreMutable()
    {
        var config = new TelemetryConfiguration
        {
            ServiceName = "CustomService",
            ServiceVersion = "2.0.0",
            OutputDirectory = "/custom/path",
            MaxFileSizeMB = 50,
            EnableTracing = false,
            EnableMetrics = false,
            EnableLogging = false,
            FlushIntervalSeconds = 10,
            MetricsExportIntervalSeconds = 30
        };

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.OutputDirectory).IsEqualTo("/custom/path");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableTracing).IsFalse();
        await Assert.That(config.EnableMetrics).IsFalse();
        await Assert.That(config.EnableLogging).IsFalse();
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(10);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(30);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryDirectoryResolverTests.cs
SIZE: 3.41 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryDirectoryResolverTests
{
    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsNonNullPath()
    {
        // On any normal system, at least one location should be writable
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        // This could be null in a sandboxed environment, but typically won't be
        // We're testing that the method runs without throwing
        result.Should().NotBeNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsWritablePath_WhenSuccessful()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        if (result != null)
        {
            // If a path is returned, it should be writable
            var testFile = Path.Combine(result, $".test_{Guid.NewGuid():N}");
            try
            {
                await File.WriteAllTextAsync(testFile, "test");
                await Assert.That(File.Exists(testFile)).IsTrue();
                File.Delete(testFile);
            }
            finally
            {
                if (File.Exists(testFile))
                    File.Delete(testFile);
            }
        }
        else
        {
            // Null is acceptable if no writable location exists
            await Assert.That(result).IsNull();
        }
    }

    [Test]
    public async Task ResolveTelemetryDirectory_IncludesAppName_InPath()
    {
        const string appName = "MyUniqueTestApp";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        if (result != null)
        {
            result.Should().Contain(appName);
        }

        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_UsesDefaultAppName_WhenNotSpecified()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory();

        // Should use "MyImapDownloader" as default
        if (result != null)
        {
            result.Should().Contain("MyImapDownloader");
        }

        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_CreatesDirectory_WhenItDoesNotExist()
    {
        var uniqueAppName = $"TestApp_{Guid.NewGuid():N}";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(uniqueAppName);

        try
        {
            if (result != null)
            {
                await Assert.That(Directory.Exists(result)).IsTrue();
            }
        }
        finally
        {
            // Cleanup
            if (result != null && Directory.Exists(result))
            {
                try { Directory.Delete(result, recursive: true); } catch { }
            }
        }
    }

    [Test]
    [Arguments("SimpleApp")]
    [Arguments("App-With-Dashes")]
    [Arguments("App_With_Underscores")]
    [Arguments("AppWithNumbers123")]
    public async Task ResolveTelemetryDirectory_HandlesVariousAppNames(string appName)
    {
        // Should not throw for valid app names
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        result.Should().NotBeNull();

        // Cleanup if directory was created
        if (result != null && Directory.Exists(result))
        {
            try { Directory.Delete(result, recursive: true); } catch { }
        }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryExtensionsTests.cs
SIZE: 4.33 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using FluentAssertions;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryExtensionsTests
{
    [Test]
    public async Task AddTelemetry_RegistersTelemetryConfiguration()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetService<TelemetryConfiguration>();
        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_RegistersWriterProvider()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_BindsConfigurationValues()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:ServiceName"] = "CustomService",
            ["Telemetry:ServiceVersion"] = "2.0.0",
            ["Telemetry:MaxFileSizeMB"] = "50",
            ["Telemetry:EnableTracing"] = "true",
            ["Telemetry:EnableMetrics"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableMetrics).IsFalse();
    }

    [Test]
    public async Task AddTelemetry_WithDisabledTelemetry_RegistersNullProvider()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:EnableTracing"] = "false",
            ["Telemetry:EnableMetrics"] = "false",
            ["Telemetry:EnableLogging"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_CanBeCalledMultipleTimes_WithoutError()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        // Should not throw on multiple calls
        services.AddTelemetry(configuration);
        services.AddTelemetry(configuration);

        var provider = services.BuildServiceProvider();
        var config = provider.GetService<TelemetryConfiguration>();

        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_WithEmptyConfiguration_UsesDefaults()
    {
        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder().Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.EnableTracing).IsTrue();
    }

    [Test]
    public async Task AddTelemetry_ReturnsServiceCollection_ForChaining()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        var result = services.AddTelemetry(configuration);

        result.Should().BeSameAs(services);
    }

    private static IConfiguration CreateConfiguration()
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Telemetry:ServiceName"] = "TestService"
            })
            .Build();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryWriterProviderTests.cs
SIZE: 3.47 KB
MODIFIED: 2025-12-22 14:54:28
================================================================================

using FluentAssertions;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryWriterProviderTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = new();

    public TelemetryWriterProviderTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"provider_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix)
    {
        var writer = new JsonTelemetryFileWriter(
            _testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_AcceptsAllWriters()
    {
        var traceWriter = CreateWriter("traces");
        var metricsWriter = CreateWriter("metrics");
        var logsWriter = CreateWriter("logs");

        var provider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsEqualTo(metricsWriter);
        await Assert.That(provider.LogsWriter).IsEqualTo(logsWriter);
    }

    [Test]
    public async Task Constructor_AcceptsNullWriters()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task Constructor_AcceptsMixedNullAndNonNullWriters()
    {
        var traceWriter = CreateWriter("traces");

        var provider = new TelemetryWriterProvider(traceWriter, null, null);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task ImplementsInterface()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task NullProvider_ReturnsAllNull()
    {
        var provider = new NullTelemetryWriterProvider();

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task NullProvider_ImplementsInterface()
    {
        var provider = new NullTelemetryWriterProvider();

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task ProvidersAreInterchangeable()
    {
        ITelemetryWriterProvider provider1 = new NullTelemetryWriterProvider();
        ITelemetryWriterProvider provider2 = new TelemetryWriterProvider(null, null, null);

        // Both should work identically through the interface
        await Assert.That(provider1.TraceWriter).IsNull();
        await Assert.That(provider2.TraceWriter).IsNull();
    }
}


================================================================================
FILE: qodana.yaml
SIZE: 0.96 KB
MODIFIED: 2025-12-18 17:29:53
================================================================================

#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify IDE code to run analysis without container (Applied in CI/CD pipeline)
ide: QDNET

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)


===============================================================================
EXPORT COMPLETED: Thu Dec 25 09:31:46 PM CST 2025
Total Files Exported: 36
Output File: /home/kushal/src/dotnet/MyImapDownloader/docs/llm/dump.txt
===============================================================================
