
===============================================================================
PROJECT EXPORT
Generated: 12/18/2025 14:36:24
Project Path: C:\Users\kushal\source\repos\MyImapDownloader
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\MYIMAPDOWNLOADER
|   .gitignore
|   Directory.Build.props
|   Directory.Build.targets
|   Directory.Packages.props
|   export.ps1
|   MyImapDownloader.sln
|   qodana.yaml
|   README.md
|   
+---docs
|   \---llm
|           .gitkeep
|           claude.md
|           dump.txt
|           ImplementationSummary.md
|           output.txt
|           
\---MyImapDownloader
    |   appsettings.json
    |   DownloadOptions.cs
    |   EmailDownloadException.cs
    |   EmailDownloadService.cs
    |   EmailStorageService.cs
    |   ImapConfiguration.cs
    |   MyImapDownloader.csproj
    |   Program.cs
    |   
    +---bin
    |   \---Debug
    |       \---net10.0
    +---obj
    |   |   MyImapDownloader.csproj.nuget.dgspec.json
    |   |   MyImapDownloader.csproj.nuget.g.props
    |   |   MyImapDownloader.csproj.nuget.g.targets
    |   |   project.assets.json
    |   |   project.nuget.cache
    |   |   
    |   \---Debug
    |       \---net10.0
    |           |   .NETCoreApp,Version=v10.0.AssemblyAttributes.cs
    |           |   MyImapDownloader.AssemblyInfo.cs
    |           |   MyImapDownloader.AssemblyInfoInputs.cache
    |           |   MyImapDownloader.assets.cache
    |           |   MyImapDownloader.csproj.AssemblyReference.cache
    |           |   MyImapDownloader.csproj.CoreCompileInputs.cache
    |           |   MyImapDownloader.csproj.FileListAbsolute.txt
    |           |   MyImapDownloader.GeneratedMSBuildEditorConfig.editorconfig
    |           |   MyImapDownloader.GlobalUsings.g.cs
    |           |   MyImapDownloader.sourcelink.json
    |           |   
    |           +---ref
    |           \---refint
    \---Telemetry
            ActivityExtension.cs
            DiagnosticsConfig.cs
            JsonFileLogExporter.cs
            JsonFileMetricsExporter.cs
            JsonFileTraceExporter.cs
            JsonTelemetryFileWriter.cs
            TelemetryConfiguration.cs
            TelemetryDirectoryResolver.cs
            TelemetryExtensions.cs
            


FILE CONTENTS:
==============

================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\Directory.Build.props
SIZE: 0.51 KB
MODIFIED: 12/18/2025 13:51:47
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\Directory.Packages.props
SIZE: 1.38 KB
MODIFIED: 12/18/2025 14:13:14
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  <ItemGroup>
    <PackageVersion Include="CommandLineParser" Version="2.9.1" />
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="MailKit" Version="4.14.1" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Json" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.UserSecrets" Version="6.0.1" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Console" Version="10.0.1" />
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    <PackageVersion Include="Polly" Version="8.6.5" />
  </ItemGroup>
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader.sln
SIZE: 1 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================


Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MyImapDownloader", "MyImapDownloader\MyImapDownloader.csproj", "{8E3B6382-B4FA-491C-8889-8964BC556B71}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E3B6382-B4FA-491C-8889-8964BC556B71}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\appsettings.json
SIZE: 0.45 KB
MODIFIED: 12/18/2025 14:08:04
================================================================================

{
  "Telemetry": {
    "ServiceName": "MyImapDownloader",
    "ServiceVersion": "1.0.0",
    "OutputDirectory": "telemetry",
    "MaxFileSizeMB": 25,
    "EnableTracing": true,
    "EnableMetrics": true,
    "EnableLogging": true,
    "FlushIntervalSeconds": 5,
    "MetricsExportIntervalSeconds": 15
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\DownloadOptions.cs
SIZE: 1.28 KB
MODIFIED: 12/18/2025 13:48:35
================================================================================

using CommandLine;

namespace MyImapDownloader;

public class DownloadOptions
{
    [Option('s', "server", Required = true, HelpText = "IMAP server address")]
    public required string Server { get; set; }

    [Option('u', "username", Required = true, HelpText = "Email username")]
    public required string Username { get; set; }

    [Option('p', "password", Required = true, HelpText = "Email password")]
    public required string Password { get; set; }

    [Option('r', "port", Default = 993, HelpText = "IMAP port (default: 993)")]
    public int Port { get; set; } = 993;

    [Option('o', "output", Default = "EmailArchive", HelpText = "Output directory for archived emails")]
    public required string OutputDirectory { get; set; }

    [Option("start-date", HelpText = "Download emails from this date (yyyy-MM-dd)")]
    public DateTime? StartDate { get; set; }

    [Option("end-date", HelpText = "Download emails until this date (yyyy-MM-dd)")]
    public DateTime? EndDate { get; set; }

    [Option('a', "all-folders", Default = false, HelpText = "Download from all folders, not just INBOX")]
    public bool AllFolders { get; set; }

    [Option('v', "verbose", Default = false, HelpText = "Enable verbose logging")]
    public bool Verbose { get; set; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailDownloadException.cs
SIZE: 0.25 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

namespace MyImapDownloader;

// Custom Exceptions
public class EmailDownloadException(string message, int messageIndex, Exception innerException)
    : Exception(message, innerException)
{
    public int MessageIndex { get; } = messageIndex;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailDownloadService.cs
SIZE: 17.6 KB
MODIFIED: 12/18/2025 14:28:19
================================================================================

using System.Diagnostics;
using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MailKit.Security;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyImapDownloader.Telemetry;
using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;

namespace MyImapDownloader;

public class EmailDownloadService
{
    private readonly ILogger<EmailDownloadService> _logger;
    private readonly ImapConfiguration _config;
    private readonly EmailStorageService _storage;
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    public EmailDownloadService(
        ILogger<EmailDownloadService> logger,
        ImapConfiguration config,
        EmailStorageService storage)
    {
        _logger = logger;
        _config = config;
        _storage = storage;

        _retryPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .WaitAndRetryAsync(
                3,
                retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                (exception, timeSpan, retryCount, _) =>
                {
                    DiagnosticsConfig.RetryAttempts.Add(1,
                        new KeyValuePair<string, object?>("retry_count", retryCount),
                        new KeyValuePair<string, object?>("exception_type", exception.GetType().Name));

                    _logger.LogWarning(exception,
                        "Retry {RetryCount} with delay {Delay}",
                        retryCount, timeSpan);
                });

        _circuitBreakerPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .CircuitBreakerAsync(
                exceptionsAllowedBeforeBreaking: 5,
                durationOfBreak: TimeSpan.FromMinutes(2),
                onBreak: (ex, duration) =>
                {
                    using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
                        "CircuitBreakerOpened", ActivityKind.Internal);
                    activity?.SetTag("duration_seconds", duration.TotalSeconds);
                    activity?.SetTag("exception_type", ex.GetType().Name);
                    activity?.SetStatus(ActivityStatusCode.Error, "Circuit breaker opened");

                    _logger.LogError(ex, "Circuit breaker opened for {Duration}", duration);
                },
                onReset: () =>
                {
                    using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
                        "CircuitBreakerReset", ActivityKind.Internal);
                    _logger.LogInformation("Circuit breaker reset");
                });
    }

    public async Task DownloadEmailsAsync(
        DownloadOptions options,
        CancellationToken cancellationToken = default)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "DownloadEmails", ActivityKind.Client);

        activity?.SetTag("server", _config.Server);
        activity?.SetTag("port", _config.Port);
        activity?.SetTag("all_folders", options.AllFolders);
        activity?.SetTag("output_directory", options.OutputDirectory);

        if (options.StartDate.HasValue)
            activity?.SetTag("start_date", options.StartDate.Value.ToString("yyyy-MM-dd"));
        if (options.EndDate.HasValue)
            activity?.SetTag("end_date", options.EndDate.Value.ToString("yyyy-MM-dd"));

        var policy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);
        var stats = new DownloadStats();
        var sessionStopwatch = Stopwatch.StartNew();

        try
        {
            await policy.ExecuteAsync(async () =>
            {
                using var client = new ImapClient { Timeout = 180_000 };

                try
                {
                    await ConnectAndAuthenticateAsync(client, cancellationToken);

                    var folders = options.AllFolders
                        ? await GetAllFoldersAsync(client, cancellationToken)
                        : [client.Inbox];

                    activity?.SetTag("folder_count", folders.Count());

                    foreach (var folder in folders)
                    {
                        await DownloadFolderAsync(folder, options, stats, cancellationToken);
                    }
                }
                finally
                {
                    await DisconnectSafelyAsync(client);
                    await _storage.SaveIndexAsync(cancellationToken);
                }
            });

            activity?.SetStatus(ActivityStatusCode.Ok);
        }
        catch (AuthenticationException ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, "Authentication failed");
            activity?.RecordException(ex);
            _logger.LogCritical("Aborting: Authentication failed");
            throw;
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            throw;
        }
        finally
        {
            sessionStopwatch.Stop();

            activity?.SetTag("emails_new", stats.NewEmails);
            activity?.SetTag("emails_skipped", stats.SkippedDuplicates);
            activity?.SetTag("emails_errors", stats.Errors);
            activity?.SetTag("total_duration_ms", sessionStopwatch.ElapsedMilliseconds);

            _logger.LogInformation(
                "Download complete. New: {New}, Skipped: {Skipped}, Errors: {Errors}, Duration: {Duration}ms",
                stats.NewEmails, stats.SkippedDuplicates, stats.Errors, sessionStopwatch.ElapsedMilliseconds);
        }
    }

    private async Task<IEnumerable<IMailFolder>> GetAllFoldersAsync(
        ImapClient client, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "GetAllFolders", ActivityKind.Internal);

        var folders = new List<IMailFolder>();
        var personal = client.GetFolder(client.PersonalNamespaces[0]);

        await CollectFoldersRecursiveAsync(personal, folders, ct);

        if (!folders.Contains(client.Inbox))
            folders.Insert(0, client.Inbox);

        activity?.SetTag("folder_count", folders.Count);
        return folders;
    }

    private async Task CollectFoldersRecursiveAsync(
        IMailFolder parent, List<IMailFolder> folders, CancellationToken ct)
    {
        foreach (var folder in await parent.GetSubfoldersAsync(false, ct))
        {
            folders.Add(folder);
            await CollectFoldersRecursiveAsync(folder, folders, ct);
        }
    }

    private async Task DownloadFolderAsync(
        IMailFolder folder,
        DownloadOptions options,
        DownloadStats stats,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "DownloadFolder", ActivityKind.Internal);

        var folderStopwatch = Stopwatch.StartNew();
        activity?.SetTag("folder_name", folder.FullName);

        try
        {
            await folder.OpenAsync(FolderAccess.ReadOnly, ct);

            activity?.SetTag("message_count", folder.Count);
            _logger.LogInformation("Processing folder: {Folder} ({Count} messages)",
                folder.FullName, folder.Count);

            if (folder.Count == 0)
            {
                activity?.AddEvent(new ActivityEvent("EmptyFolder"));
                return;
            }

            var query = BuildSearchQuery(options.StartDate, options.EndDate);
            var uids = query != null
                ? await folder.SearchAsync(query, ct)
                : await folder.SearchAsync(SearchQuery.All, ct);

            activity?.SetTag("matching_messages", uids.Count);
            DiagnosticsConfig.SetQueuedEmails(uids.Count);

            _logger.LogInformation("Found {Count} messages matching criteria", uids.Count);

            const int batchSize = 50;
            for (int i = 0; i < uids.Count; i += batchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = uids.Skip(i).Take(batchSize).ToList();
                await DownloadBatchAsync(folder, batch, stats, ct);

                int processed = Math.Min(i + batchSize, uids.Count);
                double progress = (double)processed / uids.Count * 100;

                activity?.AddEvent(new ActivityEvent("BatchComplete", tags: new ActivityTagsCollection
                {
                    ["batch_end"] = processed,
                    ["total"] = uids.Count,
                    ["progress_percent"] = progress
                }));

                _logger.LogInformation("Progress: {Current}/{Total} ({Percent:F1}%)",
                    processed, uids.Count, progress);
            }

            DiagnosticsConfig.FoldersProcessed.Add(1,
                new KeyValuePair<string, object?>("folder_name", folder.FullName));

            activity?.SetStatus(ActivityStatusCode.Ok);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            _logger.LogError(ex, "Error processing folder: {Folder}", folder.FullName);
        }
        finally
        {
            folderStopwatch.Stop();
            DiagnosticsConfig.FolderProcessingDuration.Record(
                folderStopwatch.Elapsed.TotalMilliseconds,
                new KeyValuePair<string, object?>("folder_name", folder.FullName));
        }
    }

    private async Task DownloadBatchAsync(
        IMailFolder folder,
        IList<UniqueId> uids,
        DownloadStats stats,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "DownloadBatch", ActivityKind.Internal);

        var batchStopwatch = Stopwatch.StartNew();
        activity?.SetTag("folder_name", folder.FullName);
        activity?.SetTag("batch_size", uids.Count);

        int batchNew = 0, batchSkipped = 0, batchErrors = 0;

        foreach (var uid in uids)
        {
            if (ct.IsCancellationRequested) break;

            var emailStopwatch = Stopwatch.StartNew();

            try
            {
                using var emailActivity = DiagnosticsConfig.ActivitySource.StartActivity(
                    "DownloadEmail", ActivityKind.Client);

                emailActivity?.SetTag("folder", folder.FullName);
                emailActivity?.SetTag("uid", uid.Id);

                using var timeoutCts = new CancellationTokenSource(TimeSpan.FromMinutes(2));
                using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
                    timeoutCts.Token, ct);

                var message = await folder.GetMessageAsync(uid, linkedCts.Token);

                emailActivity?.SetTag("message_id", message.MessageId);
                emailActivity?.SetTag("subject", Truncate(message.Subject, 100));
                emailActivity?.SetTag("from", message.From?.ToString());
                emailActivity?.SetTag("date", message.Date.ToString("O"));

                long messageSize = EstimateMessageSize(message);
                DiagnosticsConfig.EmailSize.Record(messageSize,
                    new KeyValuePair<string, object?>("folder", folder.FullName));

                bool isNew = await _storage.StoreEmailAsync(message, folder.FullName, linkedCts.Token);

                emailStopwatch.Stop();
                DiagnosticsConfig.EmailDownloadDuration.Record(
                    emailStopwatch.Elapsed.TotalMilliseconds,
                    new KeyValuePair<string, object?>("folder", folder.FullName),
                    new KeyValuePair<string, object?>("is_new", isNew));

                if (isNew)
                {
                    batchNew++;
                    stats.NewEmails++;
                    DiagnosticsConfig.EmailsDownloaded.Add(1,
                        new KeyValuePair<string, object?>("folder", folder.FullName));
                    DiagnosticsConfig.BytesDownloaded.Add(messageSize,
                        new KeyValuePair<string, object?>("folder", folder.FullName));
                    DiagnosticsConfig.IncrementTotalEmails();
                }
                else
                {
                    batchSkipped++;
                    stats.SkippedDuplicates++;
                    DiagnosticsConfig.EmailsSkipped.Add(1,
                        new KeyValuePair<string, object?>("folder", folder.FullName));
                }

                emailActivity?.SetTag("is_new", isNew);
                emailActivity?.SetStatus(ActivityStatusCode.Ok);
            }
            catch (OperationCanceledException)
            {
                batchErrors++;
                stats.Errors++;
                DiagnosticsConfig.EmailErrors.Add(1,
                    new KeyValuePair<string, object?>("folder", folder.FullName),
                    new KeyValuePair<string, object?>("error_type", "timeout"));

                _logger.LogWarning("Timeout downloading message {Uid} in {Folder}", uid, folder.FullName);
            }
            catch (Exception ex)
            {
                batchErrors++;
                stats.Errors++;
                DiagnosticsConfig.EmailErrors.Add(1,
                    new KeyValuePair<string, object?>("folder", folder.FullName),
                    new KeyValuePair<string, object?>("error_type", ex.GetType().Name));

                _logger.LogError(ex, "Error downloading {Uid} in {Folder}", uid, folder.FullName);
            }
        }

        batchStopwatch.Stop();
        DiagnosticsConfig.BatchProcessingDuration.Record(
            batchStopwatch.Elapsed.TotalMilliseconds,
            new KeyValuePair<string, object?>("folder", folder.FullName),
            new KeyValuePair<string, object?>("batch_size", uids.Count));

        activity?.SetTag("new_emails", batchNew);
        activity?.SetTag("skipped_emails", batchSkipped);
        activity?.SetTag("errors", batchErrors);
        activity?.SetTag("duration_ms", batchStopwatch.ElapsedMilliseconds);
    }

    private static long EstimateMessageSize(MimeMessage message)
    {
        using var stream = new MemoryStream();
        message.WriteTo(stream);
        return stream.Length;
    }

    private static SearchQuery? BuildSearchQuery(DateTime? startDate, DateTime? endDate)
    {
        SearchQuery? query = null;

        if (startDate.HasValue)
            query = SearchQuery.DeliveredAfter(startDate.Value);

        if (endDate.HasValue)
        {
            var endQuery = SearchQuery.DeliveredBefore(endDate.Value.AddDays(1));
            query = query != null ? query.And(endQuery) : endQuery;
        }

        return query;
    }

    private async Task ConnectAndAuthenticateAsync(ImapClient client, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "ConnectAndAuthenticate", ActivityKind.Client);

        activity?.SetTag("server", _config.Server);
        activity?.SetTag("port", _config.Port);

        DiagnosticsConfig.ConnectionAttempts.Add(1,
            new KeyValuePair<string, object?>("server", _config.Server));

        var connectStopwatch = Stopwatch.StartNew();

        try
        {
            _logger.LogInformation("Connecting to {Server}:{Port}", _config.Server, _config.Port);

            await client.ConnectAsync(
                _config.Server,
                _config.Port,
                SecureSocketOptions.SslOnConnect,
                ct);

            activity?.AddEvent(new ActivityEvent("Connected"));

            await client.AuthenticateAsync(_config.Username, _config.Password, ct);

            connectStopwatch.Stop();

            DiagnosticsConfig.IncrementActiveConnections();
            activity?.SetTag("connect_duration_ms", connectStopwatch.ElapsedMilliseconds);
            activity?.SetStatus(ActivityStatusCode.Ok);

            _logger.LogInformation("Connected successfully in {Duration}ms",
                connectStopwatch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            throw;
        }
    }

    private async Task DisconnectSafelyAsync(ImapClient client)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "Disconnect", ActivityKind.Client);

        try
        {
            if (client.IsConnected)
            {
                await client.DisconnectAsync(true);
                DiagnosticsConfig.DecrementActiveConnections();
                activity?.SetStatus(ActivityStatusCode.Ok);
                _logger.LogDebug("Disconnected from server");
            }
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            _logger.LogWarning(ex, "Error during disconnect");
        }
    }

    private static string Truncate(string? input, int maxLength)
    {
        if (string.IsNullOrEmpty(input)) return "(no subject)";
        return input.Length <= maxLength ? input : input[..(maxLength - 3)] + "...";
    }

    private class DownloadStats
    {
        public int NewEmails;
        public int SkippedDuplicates;
        public int Errors;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\EmailStorageService.cs
SIZE: 12.86 KB
MODIFIED: 12/18/2025 14:28:36
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using MimeKit;
using MyImapDownloader.Telemetry;

namespace MyImapDownloader;

/// <summary>
/// Stores emails in a Maildir-inspired structure with deduplication and metadata tracking.
/// </summary>
public class EmailStorageService
{
    private readonly ILogger<EmailStorageService> _logger;
    private readonly string _baseDirectory;
    private readonly HashSet<string> _knownMessageIds;
    private readonly string _indexPath;

    // Storage-specific metrics
    private static readonly Counter<long> FilesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.files.written", unit: "files", description: "Number of email files written to disk");
    private static readonly Counter<long> BytesWritten = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.bytes.written", unit: "bytes", description: "Total bytes written to disk");
    private static readonly Histogram<double> WriteLatency = DiagnosticsConfig.Meter.CreateHistogram<double>(
        "storage.write.latency", unit: "ms", description: "Time to write email to disk");
    private static readonly Counter<long> DuplicatesDetected = DiagnosticsConfig.Meter.CreateCounter<long>(
        "storage.duplicates.detected", unit: "emails", description: "Number of duplicate emails detected");

    public EmailStorageService(ILogger<EmailStorageService> logger, string baseDirectory)
    {
        _logger = logger;
        _baseDirectory = baseDirectory;
        _indexPath = Path.Combine(baseDirectory, ".email-index.json");
        _knownMessageIds = LoadIndex();
    }

    /// <summary>
    /// Stores an email message, returning true if it was new, false if duplicate.
    /// </summary>
    public async Task<bool> StoreEmailAsync(
        MimeMessage message,
        string folderName,
        CancellationToken ct = default)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "StoreEmail", ActivityKind.Internal);

        var stopwatch = Stopwatch.StartNew();
        string messageId = GetMessageIdentifier(message);

        activity?.SetTag("message_id", messageId);
        activity?.SetTag("folder", folderName);
        activity?.SetTag("subject", Truncate(message.Subject, 100));

        if (_knownMessageIds.Contains(messageId))
        {
            DuplicatesDetected.Add(1, new KeyValuePair<string, object?>("folder", folderName));
            activity?.SetTag("is_duplicate", true);
            activity?.SetStatus(ActivityStatusCode.Ok, "Duplicate skipped");
            _logger.LogDebug("Skipping duplicate: {MessageId}", messageId);
            return false;
        }

        string folderPath = GetFolderPath(folderName);
        EnsureMaildirStructure(folderPath);

        string filename = GenerateFilename(message, messageId);
        string tempPath = Path.Combine(folderPath, "tmp", filename);
        string finalPath = Path.Combine(folderPath, "cur", filename);

        activity?.SetTag("file_path", finalPath);

        try
        {
            long bytesWritten;

            // Write to tmp first (atomic write pattern)
            await using (var stream = File.Create(tempPath))
            {
                await message.WriteToAsync(stream, ct);
                bytesWritten = stream.Length;
            }

            // Move to cur (atomic on most filesystems)
            File.Move(tempPath, finalPath, overwrite: false);

            // Write sidecar metadata
            await WriteMetadataAsync(finalPath, message, folderName, ct);

            _knownMessageIds.Add(messageId);

            stopwatch.Stop();

            // Record metrics
            FilesWritten.Add(1, new KeyValuePair<string, object?>("folder", folderName));
            BytesWritten.Add(bytesWritten, new KeyValuePair<string, object?>("folder", folderName));
            WriteLatency.Record(stopwatch.Elapsed.TotalMilliseconds,
                new KeyValuePair<string, object?>("folder", folderName));

            activity?.SetTag("bytes_written", bytesWritten);
            activity?.SetTag("write_duration_ms", stopwatch.ElapsedMilliseconds);
            activity?.SetTag("is_duplicate", false);
            activity?.SetStatus(ActivityStatusCode.Ok);

            _logger.LogInformation("Stored: {Subject} -> {Path} ({Size} bytes in {Duration}ms)",
                Truncate(message.Subject, 50), finalPath, bytesWritten, stopwatch.ElapsedMilliseconds);

            return true;
        }
        catch (IOException ex) when (File.Exists(finalPath))
        {
            // Race condition - file already exists, treat as duplicate
            activity?.SetTag("race_condition", true);
            activity?.SetStatus(ActivityStatusCode.Ok, "Race condition duplicate");
            _logger.LogDebug("The exception is {message}", ex.Message);
            _logger.LogDebug("File already exists (race): {Path}", finalPath);
            TryDelete(tempPath);
            return false;
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            _logger.LogError(ex, "Failed to store email: {MessageId}", messageId);
            TryDelete(tempPath);
            throw;
        }
    }

    /// <summary>
    /// Gets a unique identifier for the message, preferring Message-ID header.
    /// </summary>
    private static string GetMessageIdentifier(MimeMessage message)
    {
        if (!string.IsNullOrWhiteSpace(message.MessageId))
        {
            return NormalizeMessageId(message.MessageId);
        }

        var sb = new StringBuilder();
        sb.Append(message.Date.ToUniversalTime().ToString("O"));
        sb.Append('|');
        sb.Append(message.From?.ToString() ?? "");
        sb.Append('|');
        sb.Append(message.Subject ?? "");

        return ComputeHash(sb.ToString());
    }

    private static string NormalizeMessageId(string messageId)
    {
        return messageId.Trim().Trim('<', '>').ToLowerInvariant();
    }

    private static string ComputeHash(string input)
    {
        byte[] bytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));
        return Convert.ToHexString(bytes)[..16].ToLowerInvariant();
    }

    private static string GenerateFilename(MimeMessage message, string messageId)
    {
        long timestamp = message.Date.ToUnixTimeSeconds();
        string safeId = SanitizeForFilename(messageId, 40);
        string hostname = SanitizeForFilename(Environment.MachineName, 20);

        return $"{timestamp}.{safeId}.{hostname}:2,S.eml";
    }

    private static string SanitizeForFilename(string input, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(input))
            return "unknown";

        var sb = new StringBuilder(Math.Min(input.Length, maxLength));
        foreach (char c in input)
        {
            if (char.IsLetterOrDigit(c) || c == '-' || c == '_' || c == '.')
                sb.Append(c);
            else if (sb.Length > 0 && sb[^1] != '_')
                sb.Append('_');

            if (sb.Length >= maxLength)
                break;
        }

        return sb.ToString().Trim('_');
    }

    private string GetFolderPath(string folderName)
    {
        string safeName = SanitizeForFilename(folderName, 100);
        return Path.Combine(_baseDirectory, safeName);
    }

    private static void EnsureMaildirStructure(string folderPath)
    {
        Directory.CreateDirectory(Path.Combine(folderPath, "cur"));
        Directory.CreateDirectory(Path.Combine(folderPath, "new"));
        Directory.CreateDirectory(Path.Combine(folderPath, "tmp"));
    }

    private static async Task WriteMetadataAsync(
        string emlPath,
        MimeMessage message,
        string folderName,
        CancellationToken ct)
    {
        var metadata = new EmailMetadata
        {
            MessageId = message.MessageId,
            Subject = message.Subject,
            From = message.From?.ToString(),
            To = message.To?.ToString(),
            Date = message.Date.UtcDateTime,
            Folder = folderName,
            ArchivedAt = DateTime.UtcNow,
            HasAttachments = message.Attachments.Any(),
            AttachmentCount = message.Attachments.Count()
        };

        string metaPath = emlPath + ".meta.json";
        await using var stream = File.Create(metaPath);
        await JsonSerializer.SerializeAsync(stream, metadata,
            new JsonSerializerOptions { WriteIndented = true }, ct);
    }

    private HashSet<string> LoadIndex()
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "LoadIndex", ActivityKind.Internal);

        try
        {
            if (File.Exists(_indexPath))
            {
                string json = File.ReadAllText(_indexPath);
                var ids = JsonSerializer.Deserialize<List<string>>(json);
                var result = ids != null ? new HashSet<string>(ids) : [];

                activity?.SetTag("index_count", result.Count);
                activity?.SetTag("source", "file");
                activity?.SetStatus(ActivityStatusCode.Ok);

                return result;
            }
        }
        catch (Exception ex)
        {
            activity?.RecordException(ex);
            _logger.LogWarning(ex, "Could not load index, will rebuild from files");
        }

        activity?.SetTag("source", "rebuild");
        return RebuildIndexFromFiles();
    }

    private HashSet<string> RebuildIndexFromFiles()
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "RebuildIndex", ActivityKind.Internal);

        var stopwatch = Stopwatch.StartNew();
        var ids = new HashSet<string>();

        if (!Directory.Exists(_baseDirectory))
        {
            activity?.SetTag("index_count", 0);
            return ids;
        }

        int filesScanned = 0;
        foreach (var metaFile in Directory.EnumerateFiles(
            _baseDirectory, "*.meta.json", SearchOption.AllDirectories))
        {
            filesScanned++;
            try
            {
                string json = File.ReadAllText(metaFile);
                var meta = JsonSerializer.Deserialize<EmailMetadata>(json);
                if (!string.IsNullOrEmpty(meta?.MessageId))
                    ids.Add(NormalizeMessageId(meta.MessageId));
            }
            catch { /* Skip malformed metadata */ }
        }

        stopwatch.Stop();

        activity?.SetTag("files_scanned", filesScanned);
        activity?.SetTag("index_count", ids.Count);
        activity?.SetTag("rebuild_duration_ms", stopwatch.ElapsedMilliseconds);
        activity?.SetStatus(ActivityStatusCode.Ok);

        _logger.LogInformation("Rebuilt index with {Count} known emails from {Files} files in {Duration}ms",
            ids.Count, filesScanned, stopwatch.ElapsedMilliseconds);

        return ids;
    }

    public async Task SaveIndexAsync(CancellationToken ct = default)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity(
            "SaveIndex", ActivityKind.Internal);

        var stopwatch = Stopwatch.StartNew();

        try
        {
            Directory.CreateDirectory(_baseDirectory);
            await using var stream = File.Create(_indexPath);
            await JsonSerializer.SerializeAsync(stream, _knownMessageIds.ToList(), cancellationToken: ct);

            stopwatch.Stop();

            activity?.SetTag("index_count", _knownMessageIds.Count);
            activity?.SetTag("save_duration_ms", stopwatch.ElapsedMilliseconds);
            activity?.SetStatus(ActivityStatusCode.Ok);
        }
        catch (Exception ex)
        {
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            activity?.RecordException(ex);
            throw;
        }
    }

    private static void TryDelete(string path)
    {
        try { File.Delete(path); } catch { /* Ignore cleanup failures */ }
    }

    private static string Truncate(string? input, int maxLength)
    {
        if (string.IsNullOrEmpty(input)) return "(no subject)";
        return input.Length <= maxLength ? input : input[..(maxLength - 3)] + "...";
    }
}

public record EmailMetadata
{
    public string? MessageId { get; init; }
    public string? Subject { get; init; }
    public string? From { get; init; }
    public string? To { get; init; }
    public DateTime Date { get; init; }
    public string? Folder { get; init; }
    public DateTime ArchivedAt { get; init; }
    public bool HasAttachments { get; init; }
    public int AttachmentCount { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\ImapConfiguration.cs
SIZE: 0.32 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

namespace MyImapDownloader;

// Configuration Model
public class ImapConfiguration
{
    public required string Server { get; set; }
    public int Port { get; set; }
    public required string Username { get; set; }
    public required string Password { get; set; }
    public bool UseSsl { get; set; } = true;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\MyImapDownloader.csproj
SIZE: 1.2 KB
MODIFIED: 12/18/2025 14:24:43
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TargetFramework, ImplicitUsings, Nullable, LangVersion come from Directory.Build.props -->
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="CommandLineParser" />
    <PackageReference Include="MailKit" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    <PackageReference Include="Polly" />
  </ItemGroup>
  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Program.cs
SIZE: 4.42 KB
MODIFIED: 12/18/2025 14:24:55
================================================================================

using System.Diagnostics;
using CommandLine;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using MyImapDownloader;
using MyImapDownloader.Telemetry;

var parseResult = Parser.Default.ParseArguments<DownloadOptions>(args);

await parseResult.WithParsedAsync(async options =>
{
    var host = Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, config) =>
        {
            config.SetBasePath(AppContext.BaseDirectory);
            config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((context, logging) =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.SetMinimumLevel(options.Verbose ? LogLevel.Debug : LogLevel.Information);
            logging.AddTelemetryLogging(context.Configuration);
        })
        .ConfigureServices((context, services) =>
        {
            // Add telemetry
            services.AddTelemetry(context.Configuration);

            services.AddSingleton(options);
            services.AddSingleton(new ImapConfiguration
            {
                Server = options.Server,
                Username = options.Username,
                Password = options.Password,
                Port = options.Port
            });
            services.AddSingleton(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<EmailStorageService>>();
                return new EmailStorageService(logger, options.OutputDirectory);
            });
            services.AddTransient<EmailDownloadService>();
        })
        .Build();

    var downloadService = host.Services.GetRequiredService<EmailDownloadService>();
    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    var telemetryConfig = host.Services.GetRequiredService<TelemetryConfiguration>();

    // Create root activity for the entire session
    using var rootActivity = DiagnosticsConfig.ActivitySource.StartActivity(
        "EmailArchiveSession", ActivityKind.Server);

    rootActivity?.SetTag("service.name", telemetryConfig.ServiceName);
    rootActivity?.SetTag("service.version", telemetryConfig.ServiceVersion);
    rootActivity?.SetTag("host.name", Environment.MachineName);
    rootActivity?.SetTag("process.pid", Environment.ProcessId);
    rootActivity?.SetTag("telemetry.directory", telemetryConfig.OutputDirectory);

    var sessionStopwatch = Stopwatch.StartNew();

    try
    {
        logger.LogInformation("Starting email archive download...");
        logger.LogInformation("Output: {Output}", Path.GetFullPath(options.OutputDirectory));
        logger.LogInformation("Telemetry output: {TelemetryOutput}",
            Path.GetFullPath(telemetryConfig.OutputDirectory));

        rootActivity?.AddEvent(new ActivityEvent("DownloadStarted"));

        await downloadService.DownloadEmailsAsync(options);

        sessionStopwatch.Stop();

        rootActivity?.SetTag("session_duration_ms", sessionStopwatch.ElapsedMilliseconds);
        rootActivity?.SetStatus(ActivityStatusCode.Ok);
        rootActivity?.AddEvent(new ActivityEvent("DownloadCompleted"));

        logger.LogInformation("Archive complete! Session duration: {Duration}ms",
            sessionStopwatch.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        rootActivity?.SetStatus(ActivityStatusCode.Error, ex.Message);
        rootActivity?.RecordException(ex);
        rootActivity?.AddEvent(new ActivityEvent("DownloadFailed", tags: new ActivityTagsCollection
        {
            ["exception.type"] = ex.GetType().FullName,
            ["exception.message"] = ex.Message
        }));

        logger.LogCritical(ex, "Fatal error during download");
        Environment.ExitCode = 1;
    }
    finally
    {
        // Ensure all telemetry is flushed before exit
        logger.LogInformation("Flushing telemetry data...");

        // Give time for async exporters to flush
        await Task.Delay(TimeSpan.FromSeconds(2));

        // Dispose file writers to flush remaining data
        var traceWriter = host.Services.GetService<JsonTelemetryFileWriter>();
        traceWriter?.Dispose();
    }
});

parseResult.WithNotParsed(errors =>
{
    Environment.ExitCode = 1;
});



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\ActivityExtension.cs
SIZE: 1.33 KB
MODIFIED: 12/18/2025 14:26:06
================================================================================

using System.Diagnostics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for Activity to provide RecordException functionality
/// that works across OpenTelemetry versions.
/// </summary>
public static class ActivityExtensions
{
    /// <summary>
    /// Records an exception as an event on the activity with standard attributes.
    /// </summary>
    public static void RecordException(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        var tags = new ActivityTagsCollection
        {
            ["exception.type"] = exception.GetType().FullName,
            ["exception.message"] = exception.Message,
        };

        if (!string.IsNullOrEmpty(exception.StackTrace))
        {
            tags["exception.stacktrace"] = exception.StackTrace;
        }

        activity.AddEvent(new ActivityEvent("exception", tags: tags));
    }

    /// <summary>
    /// Sets the activity status to error with the exception message.
    /// </summary>
    public static void SetErrorStatus(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
        activity.RecordException(exception);
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\DiagnosticsConfig.cs
SIZE: 4.31 KB
MODIFIED: 12/18/2025 14:06:08
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Central configuration for all diagnostics sources used in the application.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyImapDownloader";
    public const string ServiceVersion = "1.0.0";

    // ActivitySource for distributed tracing
    public static readonly ActivitySource ActivitySource = new(ServiceName, ServiceVersion);

    // Meter for metrics
    public static readonly Meter Meter = new(ServiceName, ServiceVersion);

    // Counters
    public static readonly Counter<long> EmailsDownloaded = Meter.CreateCounter<long>(
        "emails.downloaded",
        unit: "emails",
        description: "Total number of emails successfully downloaded");

    public static readonly Counter<long> EmailsSkipped = Meter.CreateCounter<long>(
        "emails.skipped",
        unit: "emails",
        description: "Number of emails skipped (duplicates)");

    public static readonly Counter<long> EmailErrors = Meter.CreateCounter<long>(
        "emails.errors",
        unit: "errors",
        description: "Number of email download errors");

    public static readonly Counter<long> BytesDownloaded = Meter.CreateCounter<long>(
        "bytes.downloaded",
        unit: "bytes",
        description: "Total bytes downloaded");

    public static readonly Counter<long> FoldersProcessed = Meter.CreateCounter<long>(
        "folders.processed",
        unit: "folders",
        description: "Number of folders processed");

    public static readonly Counter<long> ConnectionAttempts = Meter.CreateCounter<long>(
        "connection.attempts",
        unit: "attempts",
        description: "Number of IMAP connection attempts");

    public static readonly Counter<long> RetryAttempts = Meter.CreateCounter<long>(
        "retry.attempts",
        unit: "retries",
        description: "Number of retry attempts due to failures");

    // Histograms
    public static readonly Histogram<double> EmailDownloadDuration = Meter.CreateHistogram<double>(
        "email.download.duration",
        unit: "ms",
        description: "Time taken to download individual emails");

    public static readonly Histogram<double> FolderProcessingDuration = Meter.CreateHistogram<double>(
        "folder.processing.duration",
        unit: "ms",
        description: "Time taken to process entire folders");

    public static readonly Histogram<double> BatchProcessingDuration = Meter.CreateHistogram<double>(
        "batch.processing.duration",
        unit: "ms",
        description: "Time taken to process email batches");

    public static readonly Histogram<long> EmailSize = Meter.CreateHistogram<long>(
        "email.size",
        unit: "bytes",
        description: "Size of downloaded emails");

    // Gauges (using ObservableGauge for current state)
    private static int _activeConnections;
    private static int _queuedEmails;
    private static long _totalEmailsInSession;

    public static readonly ObservableGauge<int> ActiveConnections = Meter.CreateObservableGauge(
        "connections.active",
        () => _activeConnections,
        unit: "connections",
        description: "Number of active IMAP connections");

    public static readonly ObservableGauge<int> QueuedEmails = Meter.CreateObservableGauge(
        "emails.queued",
        () => _queuedEmails,
        unit: "emails",
        description: "Number of emails queued for processing");

    public static readonly ObservableGauge<long> TotalEmailsInSession = Meter.CreateObservableGauge(
        "emails.total.session",
        () => _totalEmailsInSession,
        unit: "emails",
        description: "Total emails processed in current session");

    // Methods to update gauge values
    public static void SetActiveConnections(int count) => _activeConnections = count;
    public static void IncrementActiveConnections() => Interlocked.Increment(ref _activeConnections);
    public static void DecrementActiveConnections() => Interlocked.Decrement(ref _activeConnections);
    public static void SetQueuedEmails(int count) => _queuedEmails = count;
    public static void IncrementTotalEmails() => Interlocked.Increment(ref _totalEmailsInSession);
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonFileLogExporter.cs
SIZE: 3.14 KB
MODIFIED: 12/18/2025 14:24:19
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter : BaseExporter<LogRecord>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileLogExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonFileMetricsExporter.cs
SIZE: 6.78 KB
MODIFIED: 12/18/2025 14:35:39
================================================================================

using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter : BaseExporter<Metric>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileMetricsExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        MeterVersion = metric.MeterVersion,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    _writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?> ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags;
    }

    private static MetricValue ExtractValue(Metric metric, MetricPoint point)
    {
        var value = new MetricValue();

        try
        {
            switch (metric.MetricType)
            {
                case MetricType.LongSum:
                    value.LongValue = point.GetSumLong();
                    break;
                case MetricType.DoubleSum:
                    value.DoubleValue = point.GetSumDouble();
                    break;
                case MetricType.LongGauge:
                    value.LongValue = point.GetGaugeLastValueLong();
                    break;
                case MetricType.DoubleGauge:
                    value.DoubleValue = point.GetGaugeLastValueDouble();
                    break;
                case MetricType.Histogram:
                    value.DoubleValue = point.GetHistogramSum();
                    value.Count = (long)point.GetHistogramCount();
                    value.Buckets = ExtractHistogramBuckets(point);
                    break;
                case MetricType.ExponentialHistogram:
                    // ExponentialHistogramData in OpenTelemetry 1.14.0 uses different API
                    // Access count and sum through the MetricPoint directly
                    var expHistData = point.GetExponentialHistogramData();
                    value.Count = GetExponentialHistogramCount(expHistData);
                    value.DoubleValue = GetExponentialHistogramSum(expHistData);
                    break;
            }
        }
        catch
        {
            // If extraction fails, return partial data
        }

        return value;
    }

    private static long GetExponentialHistogramCount(ExponentialHistogramData data)
    {
        try
        {
            // Try accessing via reflection for API compatibility
            var countProperty = typeof(ExponentialHistogramData).GetProperty("Count");
            if (countProperty != null)
            {
                var val = countProperty.GetValue(data);
                if (val is long l) return l;
                if (val is ulong ul) return (long)ul;
                if (val is int i) return i;
            }
            
            // Try ZeroCount + positive/negative bucket counts as fallback
            var zeroCountProp = typeof(ExponentialHistogramData).GetProperty("ZeroCount");
            if (zeroCountProp != null)
            {
                var zeroCount = Convert.ToInt64(zeroCountProp.GetValue(data) ?? 0);
                return zeroCount; // This is a partial count but better than nothing
            }
        }
        catch
        {
            // Ignore reflection errors
        }
        
        return 0;
    }

    private static double GetExponentialHistogramSum(ExponentialHistogramData data)
    {
        try
        {
            // Try to access Sum via reflection for API compatibility
            var sumProperty = typeof(ExponentialHistogramData).GetProperty("Sum");
            if (sumProperty != null)
            {
                var val = sumProperty.GetValue(data);
                if (val is double d) return d;
            }
        }
        catch
        {
            // Ignore reflection errors
        }
        
        return 0.0;
    }

    private static List<HistogramBucket>? ExtractHistogramBuckets(MetricPoint point)
    {
        try
        {
            var buckets = new List<HistogramBucket>();
            foreach (var bucket in point.GetHistogramBuckets())
            {
                buckets.Add(new HistogramBucket
                {
                    ExplicitBound = bucket.ExplicitBound,
                    BucketCount = bucket.BucketCount
                });
            }
            return buckets.Count > 0 ? buckets : null;
        }
        catch
        {
            return null;
        }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public string? MeterVersion { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public MetricValue? Value { get; init; }
}

public record MetricValue
{
    public long? LongValue { get; set; }
    public double? DoubleValue { get; set; }
    public long? Count { get; set; }
    public List<HistogramBucket>? Buckets { get; set; }
}

public record HistogramBucket
{
    public double ExplicitBound { get; init; }
    public long BucketCount { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonFileTraceExporter.cs
SIZE: 4.05 KB
MODIFIED: 12/18/2025 14:24:29
================================================================================

using System.Diagnostics;
using OpenTelemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter : BaseExporter<Activity>
{
    private readonly JsonTelemetryFileWriter? _writer;

    public JsonFileTraceExporter(JsonTelemetryFileWriter? writer)
    {
        _writer = writer;
    }

    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (_writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList(),
                    Links = activity.Links.Select(l => new SpanLink
                    {
                        TraceId = l.Context.TraceId.ToString(),
                        SpanId = l.Context.SpanId.ToString()
                    }).ToList(),
                    Resource = new ResourceInfo
                    {
                        ServiceName = activity.GetTagItem("service.name")?.ToString(),
                        ServiceVersion = activity.GetTagItem("service.version")?.ToString()
                    }
                };

                _writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
    public List<SpanLink>? Links { get; init; }
    public ResourceInfo? Resource { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}

public record SpanLink
{
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
}

public record ResourceInfo
{
    public string? ServiceName { get; init; }
    public string? ServiceVersion { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\JsonTelemetryFileWriter.cs
SIZE: 5.17 KB
MODIFIED: 12/18/2025 14:23:58
================================================================================

using System.Collections.Concurrent;
using System.Text.Json;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Thread-safe JSON file writer that manages daily files with size limits.
/// Each telemetry record is written as a separate JSON line (JSONL format).
/// Gracefully handles write failures without crashing the application.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _baseDirectory;
    private readonly string _prefix;
    private readonly long _maxFileSizeBytes;
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly ConcurrentQueue<object> _buffer = new();
    private readonly Timer _flushTimer;
    private readonly JsonSerializerOptions _jsonOptions;

    private string _currentDate = "";
    private string _currentFilePath = "";
    private int _fileSequence;
    private long _currentFileSize;
    private bool _disposed;
    private bool _writeEnabled = true;

    public JsonTelemetryFileWriter(
        string baseDirectory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _baseDirectory = baseDirectory;
        _prefix = prefix;
        _maxFileSizeBytes = maxFileSizeBytes;

        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = false, // JSONL format - single line per record
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };

        // Try to create base directory - if it fails, disable writes
        try
        {
            Directory.CreateDirectory(_baseDirectory);
        }
        catch
        {
            _writeEnabled = false;
        }

        _flushTimer = new Timer(_ => FlushAsync().ConfigureAwait(false), null, flushInterval, flushInterval);
    }

    public void Enqueue(object record)
    {
        if (_disposed || !_writeEnabled) return;
        _buffer.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        if (_disposed || !_writeEnabled || _buffer.IsEmpty) return;

        if (!await _writeLock.WaitAsync(TimeSpan.FromSeconds(5)))
            return; // Skip this flush cycle if we can't get the lock

        try
        {
            var records = new List<object>();
            while (_buffer.TryDequeue(out var record))
            {
                records.Add(record);
            }

            foreach (var record in records)
            {
                await WriteRecordAsync(record);
            }
        }
        catch
        {
            // If we consistently fail to write, disable future writes
            // to avoid accumulating memory
            if (_buffer.Count > 10000)
            {
                _writeEnabled = false;
                while (_buffer.TryDequeue(out _)) { } // Clear buffer
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordAsync(object record)
    {
        if (!_writeEnabled) return;

        try
        {
            string today = DateTime.UtcNow.ToString("yyyy-MM-dd");

            // Check if we need a new file (new day or size exceeded)
            if (today != _currentDate || _currentFileSize >= _maxFileSizeBytes)
            {
                if (today != _currentDate)
                {
                    _currentDate = today;
                    _fileSequence = 0;
                }
                RotateFile();
            }

            // Each record is a complete JSON object on a single line (JSONL format)
            string json = JsonSerializer.Serialize(record, record.GetType(), _jsonOptions);
            string line = json + Environment.NewLine;
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(line);

            // Check if adding this record would exceed size limit
            if (_currentFileSize + bytes.Length > _maxFileSizeBytes && _currentFileSize > 0)
            {
                RotateFile();
            }

            await File.AppendAllTextAsync(_currentFilePath, line);
            _currentFileSize += bytes.Length;
        }
        catch
        {
            // Individual write failures are silently ignored
            // The application continues normally
        }
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = Path.Combine(
            _baseDirectory,
            $"{_prefix}_{_currentDate}_{_fileSequence:D4}.jsonl");
        
        try
        {
            _currentFileSize = File.Exists(_currentFilePath) ? new FileInfo(_currentFilePath).Length : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _flushTimer.Dispose();
        
        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }
        
        _writeLock.Dispose();
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\TelemetryConfiguration.cs
SIZE: 0.79 KB
MODIFIED: 12/18/2025 14:07:42
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\TelemetryDirectoryResolver.cs
SIZE: 3.32 KB
MODIFIED: 12/18/2025 14:26:39
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification
/// with graceful fallback behavior.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName = "MyImapDownloader")
    {
        // Try locations in order of preference
        var candidates = GetCandidateDirectories(appName);
        
        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }
        
        return null; // No writable location found - telemetry will be disabled
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        // 1. XDG_DATA_HOME (Linux/macOS) or LocalApplicationData (Windows)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, appName, "telemetry");
        }
        
        // 2. Platform-specific user data directory
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            yield return Path.Combine(localAppData, appName, "telemetry");
        }
        
        // 3. XDG_STATE_HOME for state/log data (more appropriate for telemetry)
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, appName, "telemetry");
        }
        
        // 4. Fallback to ~/.local/state on Unix-like systems
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            yield return Path.Combine(homeDir, ".local", "state", appName, "telemetry");
            yield return Path.Combine(homeDir, ".local", "share", appName, "telemetry");
        }
        
        // 5. Directory relative to executable
        var exeDir = AppContext.BaseDirectory;
        if (!string.IsNullOrEmpty(exeDir))
        {
            yield return Path.Combine(exeDir, "telemetry");
        }
        
        // 6. Current working directory as last resort
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            // Attempt to create the directory
            Directory.CreateDirectory(path);
            
            // Verify we can write to it
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\MyImapDownloader\Telemetry\TelemetryExtensions.cs
SIZE: 8.61 KB
MODIFIED: 12/18/2025 14:35:30
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for configuring OpenTelemetry with JSON file exporters.
/// </summary>
public static class TelemetryExtensions
{
    public static IServiceCollection AddTelemetry(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);
        services.AddSingleton(config);

        // Resolve telemetry directory with XDG compliance and fallback
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        
        if (telemetryBaseDir == null)
        {
            // No writable location found - register placeholder services
            // Telemetry will be effectively disabled but app continues normally
            services.AddSingleton<ITelemetryWriterProvider>(new NullTelemetryWriterProvider());
            config.EnableTracing = false;
            config.EnableMetrics = false;
            config.EnableLogging = false;
            
            return services;
        }

        // Update config with resolved directory
        config.OutputDirectory = telemetryBaseDir;

        var tracesDir = Path.Combine(telemetryBaseDir, "traces");
        var metricsDir = Path.Combine(telemetryBaseDir, "metrics");
        var logsDir = Path.Combine(telemetryBaseDir, "logs");

        TryCreateDirectory(tracesDir);
        TryCreateDirectory(metricsDir);
        TryCreateDirectory(logsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        // Create file writers
        JsonTelemetryFileWriter? traceWriter = null;
        JsonTelemetryFileWriter? metricsWriter = null;
        JsonTelemetryFileWriter? logsWriter = null;

        try
        {
            traceWriter = new JsonTelemetryFileWriter(
                tracesDir, "traces", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Trace writing disabled */ }

        try
        {
            metricsWriter = new JsonTelemetryFileWriter(
                metricsDir, "metrics", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Metrics writing disabled */ }

        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch { /* Log writing disabled */ }

        // Register the writer provider instead of nullable writers directly
        var writerProvider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);
        services.AddSingleton<ITelemetryWriterProvider>(writerProvider);
        
        // Also register the trace writer directly for Program.cs disposal
        if (traceWriter != null)
        {
            services.AddSingleton(traceWriter);
        }

        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(
                serviceName: config.ServiceName,
                serviceVersion: config.ServiceVersion)
            .AddAttributes(new Dictionary<string, object>
            {
                ["host.name"] = Environment.MachineName,
                ["os.type"] = Environment.OSVersion.Platform.ToString(),
                ["os.version"] = Environment.OSVersion.VersionString,
                ["process.runtime.name"] = ".NET",
                ["process.runtime.version"] = Environment.Version.ToString(),
                ["telemetry.directory"] = telemetryBaseDir
            });

        // Configure OpenTelemetry
        var otelBuilder = services.AddOpenTelemetry()
            .ConfigureResource(r => r.AddService(config.ServiceName, serviceVersion: config.ServiceVersion));

        if (config.EnableTracing && traceWriter != null)
        {
            otelBuilder.WithTracing(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddSource(DiagnosticsConfig.ServiceName)
                    .SetSampler(new AlwaysOnSampler())
                    .AddProcessor(new BatchActivityExportProcessor(
                        new JsonFileTraceExporter(traceWriter),
                        maxQueueSize: 2048,
                        scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                        exporterTimeoutMilliseconds: 30000,
                        maxExportBatchSize: 512));
            });
        }

        if (config.EnableMetrics && metricsWriter != null)
        {
            otelBuilder.WithMetrics(builder =>
            {
                builder
                    .SetResourceBuilder(resourceBuilder)
                    .AddMeter(DiagnosticsConfig.ServiceName)
                    .AddRuntimeInstrumentation()
                    .AddReader(new PeriodicExportingMetricReader(
                        new JsonFileMetricsExporter(metricsWriter),
                        exportIntervalMilliseconds: config.MetricsExportIntervalSeconds * 1000));
            });
        }

        return services;
    }

    public static ILoggingBuilder AddTelemetryLogging(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);

        if (!config.EnableLogging)
            return builder;

        // Resolve telemetry directory
        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        if (telemetryBaseDir == null)
            return builder; // No writable location - skip telemetry logging

        var logsDir = Path.Combine(telemetryBaseDir, "logs");
        if (!TryCreateDirectory(logsDir))
            return builder;

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);
        
        JsonTelemetryFileWriter? logsWriter = null;
        try
        {
            logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);
        }
        catch
        {
            return builder; // Failed to create writer - skip telemetry logging
        }

        builder.AddOpenTelemetry(options =>
        {
            options.IncludeFormattedMessage = true;
            options.IncludeScopes = true;
            options.ParseStateValues = true;
            options.AddProcessor(new BatchLogRecordExportProcessor(
                new JsonFileLogExporter(logsWriter),
                maxQueueSize: 2048,
                scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                exporterTimeoutMilliseconds: 30000,
                maxExportBatchSize: 512));
        });

        return builder;
    }

    private static bool TryCreateDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

/// <summary>
/// Interface for accessing telemetry file writers.
/// </summary>
public interface ITelemetryWriterProvider
{
    JsonTelemetryFileWriter? TraceWriter { get; }
    JsonTelemetryFileWriter? MetricsWriter { get; }
    JsonTelemetryFileWriter? LogsWriter { get; }
}

/// <summary>
/// Provides access to telemetry file writers.
/// </summary>
public sealed class TelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter { get; }
    public JsonTelemetryFileWriter? MetricsWriter { get; }
    public JsonTelemetryFileWriter? LogsWriter { get; }

    public TelemetryWriterProvider(
        JsonTelemetryFileWriter? traceWriter,
        JsonTelemetryFileWriter? metricsWriter,
        JsonTelemetryFileWriter? logsWriter)
    {
        TraceWriter = traceWriter;
        MetricsWriter = metricsWriter;
        LogsWriter = logsWriter;
    }
}

/// <summary>
/// Null implementation when telemetry is disabled.
/// </summary>
public sealed class NullTelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => null;
    public JsonTelemetryFileWriter? MetricsWriter => null;
    public JsonTelemetryFileWriter? LogsWriter => null;
}



================================================================================
FILE: :\Users\kushal\source\repos\MyImapDownloader\qodana.yaml
SIZE: 0.99 KB
MODIFIED: 12/18/2025 13:21:09
================================================================================

#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify IDE code to run analysis without container (Applied in CI/CD pipeline)
ide: QDNET

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)



===============================================================================
EXPORT COMPLETED: 12/18/2025 14:36:24
Total Files Exported: 21
Output File: .\docs\llm\dump.txt
===============================================================================
