===============================================================================
PROJECT EXPORT
Generated: Wed Feb 18 08:00:58 PM EST 2026
Project Path: /home/kushal/src/dotnet/MyImapDownloader
===============================================================================

DIRECTORY STRUCTURE:
===================

/home/kushal/src/dotnet/MyImapDownloader
â”œâ”€â”€ add-tests.sh
â”œâ”€â”€ Directory.Build.props
â”œâ”€â”€ Directory.Build.targets
â”œâ”€â”€ Directory.Packages.props
â”œâ”€â”€ .editorconfig
â”œâ”€â”€ export.sh
â”œâ”€â”€ .github
â”‚Â Â  â””â”€â”€ workflows
â”‚Â Â      â”œâ”€â”€ ci.yml
â”‚Â Â      â””â”€â”€ release.yml
â”œâ”€â”€ .gitignore
â”œâ”€â”€ global.json
â”œâ”€â”€ install.sh
â”œâ”€â”€ LICENSE
â”œâ”€â”€ MyEmailSearch
â”‚Â Â  â”œâ”€â”€ appsettings.json
â”‚Â Â  â”œâ”€â”€ Commands
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ IndexCommand.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RebuildCommand.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchCommand.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ StatusCommand.cs
â”‚Â Â  â”œâ”€â”€ Configuration
â”‚Â Â  â”‚Â Â  â””â”€â”€ PathResolver.cs
â”‚Â Â  â”œâ”€â”€ Data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DatabaseStatistics.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EmailDocument.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ IndexStatistics.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchDatabase.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchQuery.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ SearchResult.cs
â”‚Â Â  â”œâ”€â”€ Indexing
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ArchiveScanner.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EmailParser.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ IndexManager.cs
â”‚Â Â  â”œâ”€â”€ MyEmailSearch.csproj
â”‚Â Â  â”œâ”€â”€ Program.cs
â”‚Â Â  â”œâ”€â”€ Search
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ QueryParser.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchEngine.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ SnippetGenerator.cs
â”‚Â Â  â””â”€â”€ Telemetry
â”‚Â Â      â””â”€â”€ DiagnosticsConfig.cs
â”œâ”€â”€ MyEmailSearch.Tests
â”‚Â Â  â”œâ”€â”€ Configuration
â”‚Â Â  â”‚Â Â  â””â”€â”€ PathResolverTests.cs
â”‚Â Â  â”œâ”€â”€ Data
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Fts5HelperTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchDatabaseBatchTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchDatabaseCountTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchDatabaseEscapingTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchDatabaseFtsTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchDatabaseMetadataTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ SearchDatabaseTests.cs
â”‚Â Â  â”œâ”€â”€ Indexing
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ArchiveScannerExtractionTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ArchiveScannerTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EmailParserEdgeCaseTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EmailParserTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ IndexManagerCancellationTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ IndexManagerTests.cs
â”‚Â Â  â”œâ”€â”€ Integration
â”‚Â Â  â”œâ”€â”€ MyEmailSearch.Tests.csproj
â”‚Â Â  â”œâ”€â”€ Search
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ QueryParserEdgeCaseTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ QueryParserTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchEngineCountTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchEngineEdgeCaseTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SearchEngineTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SnippetGeneratorEdgeCaseTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ SnippetGeneratorTests.cs
â”‚Â Â  â”œâ”€â”€ SmokeTests.cs
â”‚Â Â  â”œâ”€â”€ Telemetry
â”‚Â Â  â””â”€â”€ TestFixtures
â”‚Â Â      â””â”€â”€ SampleEmails
â”‚Â Â          â”œâ”€â”€ sample1.eml
â”‚Â Â          â””â”€â”€ sample2.eml
â”œâ”€â”€ MyImapDownloader
â”‚Â Â  â”œâ”€â”€ appsettings.json
â”‚Â Â  â”œâ”€â”€ DownloadOptions.cs
â”‚Â Â  â”œâ”€â”€ EmailDownloadException.cs
â”‚Â Â  â”œâ”€â”€ EmailDownloadService.cs
â”‚Â Â  â”œâ”€â”€ EmailMetadata.cs
â”‚Â Â  â”œâ”€â”€ EmailStorageService.cs
â”‚Â Â  â”œâ”€â”€ ImapConfiguration.cs
â”‚Â Â  â”œâ”€â”€ MyImapDownloader.csproj
â”‚Â Â  â”œâ”€â”€ Program.cs
â”‚Â Â  â””â”€â”€ Telemetry
â”‚Â Â      â”œâ”€â”€ ActivityExtension.cs
â”‚Â Â      â”œâ”€â”€ DiagnosticsConfig.cs
â”‚Â Â      â”œâ”€â”€ JsonFileLogExporter.cs
â”‚Â Â      â”œâ”€â”€ JsonFileMetricsExporter.cs
â”‚Â Â      â”œâ”€â”€ JsonFileTraceExporter.cs
â”‚Â Â      â”œâ”€â”€ JsonTelemetryFileWriter.cs
â”‚Â Â      â”œâ”€â”€ TelemetryConfiguration.cs
â”‚Â Â      â”œâ”€â”€ TelemetryDirectoryResolver.cs
â”‚Â Â      â””â”€â”€ TelemetryExtensions.cs
â”œâ”€â”€ MyImapDownloader.Core
â”‚Â Â  â”œâ”€â”€ Configuration
â”‚Â Â  â”‚Â Â  â””â”€â”€ PathResolver.cs
â”‚Â Â  â”œâ”€â”€ Data
â”‚Â Â  â”‚Â Â  â””â”€â”€ EmailMetadata.cs
â”‚Â Â  â”œâ”€â”€ Infrastructure
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SqliteHelper.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TempDirectory.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ TestLogger.cs
â”‚Â Â  â”œâ”€â”€ MyImapDownloader.Core.csproj
â”‚Â Â  â””â”€â”€ Telemetry
â”‚Â Â      â”œâ”€â”€ DiagnosticsConfig.cs
â”‚Â Â      â”œâ”€â”€ JsonFileLogExporter.cs
â”‚Â Â      â”œâ”€â”€ JsonFileMetricsExporter.cs
â”‚Â Â      â”œâ”€â”€ JsonFileTraceExporter.cs
â”‚Â Â      â”œâ”€â”€ JsonTelemetryFileWriter.cs
â”‚Â Â      â”œâ”€â”€ TelemetryConfiguration.cs
â”‚Â Â      â”œâ”€â”€ TelemetryDirectoryResolver.cs
â”‚Â Â      â””â”€â”€ TelemetryExtensions.cs
â”œâ”€â”€ MyImapDownloader.Core.Tests
â”‚Â Â  â”œâ”€â”€ Configuration
â”‚Â Â  â”‚Â Â  â””â”€â”€ PathResolverTests.cs
â”‚Â Â  â”œâ”€â”€ Data
â”‚Â Â  â”‚Â Â  â””â”€â”€ EmailMetadataTests.cs
â”‚Â Â  â”œâ”€â”€ Infrastructure
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SqliteHelperTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ TempDirectoryTests.cs
â”‚Â Â  â”œâ”€â”€ MyImapDownloader.Core.Tests.csproj
â”‚Â Â  â”œâ”€â”€ Telemetry
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ JsonTelemetryFileWriterTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ TelemetryConfigurationTests.cs
â”‚Â Â  â””â”€â”€ TestFixtures
â”œâ”€â”€ MyImapDownloader.slnx
â”œâ”€â”€ MyImapDownloader.Tests
â”‚Â Â  â”œâ”€â”€ DownloadOptionsTests.cs
â”‚Â Â  â”œâ”€â”€ EmailDownloadExceptionTests.cs
â”‚Â Â  â”œâ”€â”€ EmailStorageSanitizationTests.cs
â”‚Â Â  â”œâ”€â”€ EmailStorageServiceParsingTests.cs
â”‚Â Â  â”œâ”€â”€ EmailStorageServiceTests.cs
â”‚Â Â  â”œâ”€â”€ ImapConfigurationTests.cs
â”‚Â Â  â”œâ”€â”€ MyImapDownloader.Tests.csproj
â”‚Â Â  â”œâ”€â”€ NormalizeMessageIdTests.cs
â”‚Â Â  â”œâ”€â”€ Services
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EmailStorageSanitizationTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ EmailStorageServiceTests.cs
â”‚Â Â  â”œâ”€â”€ Telemetry
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ActivityExtensionsTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DiagnosticsConfigTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ JsonExporterTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ JsonTelemetryFileWriterTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TelemetryConfigurationTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TelemetryDirectoryResolverTests.cs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TelemetryExtensionsTests.cs
â”‚Â Â  â”‚Â Â  â””â”€â”€ TelemetryWriterProviderTests.cs
â”‚Â Â  â”œâ”€â”€ TempDirectory.cs
â”‚Â Â  â””â”€â”€ TestLogger.cs
â””â”€â”€ README.md


FILE CONTENTS:
==============

================================================================================
FILE: Directory.Build.props
SIZE: 0.77 KB
MODIFIED: 2026-02-18 19:45:19
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  <PropertyGroup>
    <TestingPlatformDotnetTestSupport>true</TestingPlatformDotnetTestSupport>
    <TestingPlatformCaptureOutput>false</TestingPlatformCaptureOutput>
  </PropertyGroup>
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>

================================================================================
FILE: Directory.Packages.props
SIZE: 3.12 KB
MODIFIED: 2026-02-18 19:38:39
================================================================================

<Project>
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  
  <ItemGroup>
    <!-- =========================================================================
         SHARED PACKAGES (used by multiple projects)
         ========================================================================= -->
    
    <!-- Microsoft.Extensions.* - Core infrastructure -->
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.3" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Json" Version="10.0.3" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="10.0.2" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.UserSecrets" Version="10.0.1" />
    <PackageVersion Include="Microsoft.Extensions.DependencyInjection" Version="10.0.3" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.3" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="10.0.3" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.2" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Console" Version="10.0.3" />
    
    <!-- Database -->
    <PackageVersion Include="Microsoft.Data.Sqlite" Version="10.0.3" />
    
    <!-- OpenTelemetry -->
    <PackageVersion Include="OpenTelemetry" Version="1.15.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.15.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.15.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.15.0" />
    
    <!-- Resilience -->
    <PackageVersion Include="Polly" Version="8.6.5" />
    
    <!-- CLI -->
    <PackageVersion Include="CommandLineParser" Version="2.9.1" />
    <PackageVersion Include="System.CommandLine" Version="2.0.3" />
    
    <!-- =========================================================================
         MyImapDownloader SPECIFIC PACKAGES
         ========================================================================= -->
    <PackageVersion Include="MailKit" Version="4.15.0" />
    <PackageVersion Include="Dapper" Version="2.1.66" />
    <PackageVersion Include="Microsoft.Data.SqlClient" Version="6.0.1" />
    <PackageVersion Include="SQLitePCLRaw.bundle_e_sqlite3" Version="3.0.2" />
    
    <!-- =========================================================================
         MyEmailSearch SPECIFIC PACKAGES
         ========================================================================= -->
    <PackageVersion Include="MimeKit" Version="4.15.0" />
    
    <!-- =========================================================================
         TEST PACKAGES (shared by all test projects)
         ========================================================================= -->
    <PackageVersion Include="TUnit" Version="1.16.4" />
    <PackageVersion Include="NSubstitute" Version="5.3.0" />
    <PackageVersion Include="AwesomeAssertions" Version="9.4.0" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
  </ItemGroup>
</Project>


================================================================================
FILE: .github/workflows/ci.yml
SIZE: 4.95 KB
MODIFIED: 2025-12-31 10:01:56
================================================================================

# =============================================================================
# CI/CD Pipeline for MyImapDownloader and MyEmailSearch
# =============================================================================
# This workflow:
#   - Builds and tests on every push/PR to any branch
#   - Runs on Windows, macOS, and Linux
#   - Publishes artifacts on pushes to main/master/develop
# =============================================================================

name: Build and Test

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  # ===========================================================================
  # Build and Test Job
  # ===========================================================================
  build-and-test:
    name: ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'ga'
      
      - name: Display .NET info
        run: dotnet --info
      
      # Build entire solution (all projects)
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build solution
        run: dotnet build --no-restore --configuration Release
      
      # Run all tests across all test projects
      - name: Run tests
        run: dotnet test --no-build --configuration Release --verbosity normal
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: '**/TestResults/**'
          retention-days: 7

  # ===========================================================================
  # Publish Job (only on main/master/develop branches)
  # ===========================================================================
  publish:
    name: Publish
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'ga'
      
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build Release
        run: dotnet build --configuration Release
      
      # Publish MyImapDownloader
      - name: Publish MyImapDownloader (Linux x64)
        run: |
          dotnet publish MyImapDownloader/MyImapDownloader.csproj \
            --configuration Release \
            --runtime linux-x64 \
            --self-contained false \
            --output ./publish/MyImapDownloader/linux-x64
      
      - name: Publish MyImapDownloader (Windows x64)
        run: |
          dotnet publish MyImapDownloader/MyImapDownloader.csproj \
            --configuration Release \
            --runtime win-x64 \
            --self-contained false \
            --output ./publish/MyImapDownloader/win-x64
      
      - name: Publish MyImapDownloader (macOS ARM64)
        run: |
          dotnet publish MyImapDownloader/MyImapDownloader.csproj \
            --configuration Release \
            --runtime osx-arm64 \
            --self-contained false \
            --output ./publish/MyImapDownloader/osx-arm64
      
      # Publish MyEmailSearch
      - name: Publish MyEmailSearch (Linux x64)
        run: |
          dotnet publish MyEmailSearch/MyEmailSearch.csproj \
            --configuration Release \
            --runtime linux-x64 \
            --self-contained false \
            --output ./publish/MyEmailSearch/linux-x64
      
      - name: Publish MyEmailSearch (Windows x64)
        run: |
          dotnet publish MyEmailSearch/MyEmailSearch.csproj \
            --configuration Release \
            --runtime win-x64 \
            --self-contained false \
            --output ./publish/MyEmailSearch/win-x64
      
      - name: Publish MyEmailSearch (macOS ARM64)
        run: |
          dotnet publish MyEmailSearch/MyEmailSearch.csproj \
            --configuration Release \
            --runtime osx-arm64 \
            --self-contained false \
            --output ./publish/MyEmailSearch/osx-arm64
      
      # Upload all artifacts
      - name: Upload MyImapDownloader artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MyImapDownloader
          path: ./publish/MyImapDownloader/
          retention-days: 30
      
      - name: Upload MyEmailSearch artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MyEmailSearch
          path: ./publish/MyEmailSearch/
          retention-days: 30


================================================================================
FILE: .github/workflows/release.yml
SIZE: 3.88 KB
MODIFIED: 2026-01-01 18:35:08
================================================================================

name: Rolling Release

on:
  push:
    branches: [main, master, develop]

jobs:

  build-and-test:
    name: ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'
          dotnet-quality: 'ga'
      
      - name: Display .NET info
        run: dotnet --info
      
      # Build entire solution (all projects)
      - name: Restore dependencies
        run: dotnet restore
      
      - name: Build solution
        run: dotnet build --no-restore --configuration Release
      
      # Run all tests across all test projects
      - name: Run tests
        run: dotnet test --no-build --configuration Release --verbosity normal
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.os }}
          path: '**/TestResults/**'
          retention-days: 7

  publish:
    name: Generate Rolling Release
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set Version String
        id: version
        # Format: YYYY.MM.DD.RUN_NUMBER
        run: echo "REL_VERSION=$(date +'%Y.%m.%d').${{ github.run_number }}" >> $GITHUB_OUTPUT

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Publish Full-Fat Binaries
        run: |
          # Define runtimes - added osx-x64 for maximum compatibility
          for runtime in linux-x64 win-x64 osx-arm64 osx-x64; do
            echo "--- Processing $runtime ---"
            
            # 1. Build MyImapDownloader
            dotnet publish MyImapDownloader/MyImapDownloader.csproj -c Release -r $runtime \
              --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=false \
              -p:OutputExtensionsInBundle=true \
              -p:IncludeNativeLibrariesForSelfExtract=true \
              -p:Version=${{ steps.version.outputs.REL_VERSION }} \
              -o ./dist/downloader-$runtime

            # 2. Build MyEmailSearch
            dotnet publish MyEmailSearch/MyEmailSearch.csproj -c Release -r $runtime \
              --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=false \
              -p:OutputExtensionsInBundle=true \
              -p:IncludeNativeLibrariesForSelfExtract=true \
              -p:Version=${{ steps.version.outputs.REL_VERSION }} \
              -o ./dist/search-$runtime
            
            # 3. Zip with versioned filenames for the release page
            # This makes it easier for users to know exactly what they downloaded
            (cd ./dist/downloader-$runtime && zip -r ../../MyImapDownloader-$runtime-${{ steps.version.outputs.REL_VERSION }}.zip .)
            (cd ./dist/search-$runtime && zip -r ../../MyEmailSearch-$runtime-${{ steps.version.outputs.REL_VERSION }}.zip .)
          done

      - name: Create Rolling Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: rolling-build-${{ steps.version.outputs.REL_VERSION }}
          name: "Rolling Release: ${{ steps.version.outputs.REL_VERSION }}"
          body: |
            ### ðŸš€ Automated Rolling Release
            - **Version:** `${{ steps.version.outputs.REL_VERSION }}`
            - **Commit:** `${{ github.sha }}`
            - **Build Date:** $(date +'%Y-%m-%d %H:%M:%S')
            
            This is a full-fat production build. No .NET runtime installation is required on the target machine.
          files: |
            *.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


================================================================================
FILE: global.json
SIZE: 0.07 KB
MODIFIED: 2025-12-18 18:29:53
================================================================================

{
    "test": {
        "runner": "Microsoft.Testing.Platform"
    }
}


================================================================================
FILE: MyEmailSearch/appsettings.json
SIZE: 0.31 KB
MODIFIED: 2025-12-31 11:38:38
================================================================================

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  },
  "Search": {
    "DefaultResultLimit": 100,
    "MaxResultLimit": 1000,
    "SnippetLength": 200
  },
  "Indexing": {
    "BatchSize": 100,
    "IncludeContentByDefault": false
  }
}


================================================================================
FILE: MyEmailSearch/Commands/IndexCommand.cs
SIZE: 3.54 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.CommandLine;

using Microsoft.Extensions.DependencyInjection;

using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'index' command for building/updating the search index.
/// </summary>
public static class IndexCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var fullOption = new Option<bool>("--full", "-f")
        {
            Description = "Force full re-index (ignore incremental state)"
        };

        var contentOption = new Option<bool>("--content")
        {
            Description = "Index email body content for full-text search"
        };

        var command = new Command("index", "Build or update the search index");
        command.Options.Add(fullOption);
        command.Options.Add(contentOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var full = parseResult.GetValue(fullOption);
            var content = parseResult.GetValue(contentOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(full, content, archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        bool full,
        bool content,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        Console.WriteLine($"Indexing emails from: {archivePath}");
        Console.WriteLine($"Database location:    {databasePath}");
        Console.WriteLine($"Mode:                 {(full ? "Full rebuild" : "Incremental")}");
        Console.WriteLine($"Index content:        {(content ? "Yes" : "No")}");
        Console.WriteLine();

        // Ensure database directory exists
        var dbDir = Path.GetDirectoryName(databasePath);
        if (!string.IsNullOrEmpty(dbDir) && !Directory.Exists(dbDir))
        {
            Directory.CreateDirectory(dbDir);
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var indexManager = sp.GetRequiredService<IndexManager>();

        await database.InitializeAsync(ct);

        var progress = new Progress<IndexingProgress>(p =>
        {
            var pct = p.Total > 0 ? (double)p.Processed / p.Total * 100 : 0;
            Console.Write($"\rProcessing: {p.Processed:N0}/{p.Total:N0} ({pct:F1}%) - {p.CurrentFile ?? ""}".PadRight(100)[..100]);
        });

        IndexingResult result;
        if (full)
        {
            result = await indexManager.RebuildIndexAsync(archivePath, content, progress, ct);
        }
        else
        {
            result = await indexManager.IndexAsync(archivePath, content, progress, ct);
        }

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine("Indexing complete:");
        Console.WriteLine($"  New emails indexed: {result.Indexed:N0}");
        Console.WriteLine($"  Skipped (existing): {result.Skipped:N0}");
        Console.WriteLine($"  Errors:             {result.Errors:N0}");
        Console.WriteLine($"  Duration:           {result.Duration}");
    }
}


================================================================================
FILE: MyEmailSearch/Commands/RebuildCommand.cs
SIZE: 3.40 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.CommandLine;

using Microsoft.Extensions.DependencyInjection;

using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'rebuild' command for completely rebuilding the search index.
/// </summary>
public static class RebuildCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var confirmOption = new Option<bool>("--yes", "-y")
        {
            Description = "Skip confirmation prompt"
        };

        var contentOption = new Option<bool>("--content")
        {
            Description = "Also index email body content"
        };

        var command = new Command("rebuild", "Rebuild the entire search index from scratch");
        command.Options.Add(confirmOption);
        command.Options.Add(contentOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var confirm = parseResult.GetValue(confirmOption);
            var content = parseResult.GetValue(contentOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(confirm, content, archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        bool confirm,
        bool content,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        if (!confirm)
        {
            Console.Write("This will delete and rebuild the entire index. Continue? [y/N]: ");
            var response = Console.ReadLine();
            if (!string.Equals(response, "y", StringComparison.OrdinalIgnoreCase))
            {
                Console.WriteLine("Cancelled.");
                return;
            }
        }

        Console.WriteLine("Rebuilding index...");
        Console.WriteLine($"Archive path: {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine();

        // Ensure database directory exists
        var dbDir = Path.GetDirectoryName(databasePath);
        if (!string.IsNullOrEmpty(dbDir) && !Directory.Exists(dbDir))
        {
            Directory.CreateDirectory(dbDir);
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var indexManager = sp.GetRequiredService<IndexManager>();

        var progress = new Progress<IndexingProgress>(p =>
        {
            var pct = p.Total > 0 ? (double)p.Processed / p.Total * 100 : 0;
            Console.Write($"\rProcessing: {p.Processed:N0}/{p.Total:N0} ({pct:F1}%)".PadRight(60));
        });

        var result = await indexManager.RebuildIndexAsync(archivePath, content, progress, ct);

        Console.WriteLine();
        Console.WriteLine();
        Console.WriteLine("Rebuild complete:");
        Console.WriteLine($"  Indexed: {result.Indexed:N0}");
        Console.WriteLine($"  Errors:  {result.Errors:N0}");
        Console.WriteLine($"  Time:    {result.Duration}");
    }
}


================================================================================
FILE: MyEmailSearch/Commands/SearchCommand.cs
SIZE: 10.74 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.CommandLine;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text.Json;

using Microsoft.Extensions.DependencyInjection;

using MyEmailSearch.Configuration;
using MyEmailSearch.Data;
using MyEmailSearch.Search;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'search' command for querying the email index.
/// </summary>
public static class SearchCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var queryArgument = new Argument<string>("query")
        {
            Description = "Search query (e.g., 'from:alice@example.com subject:report kafka')"
        };

        var limitOption = new Option<int>("--limit", "-l")
        {
            Description = "Maximum number of results to return",
            DefaultValueFactory = _ => 100
        };

        var formatOption = new Option<string>("--format", "-f")
        {
            Description = "Output format: table, json, or csv",
            DefaultValueFactory = _ => "table"
        };

        var openOption = new Option<bool>("--open", "-o")
        {
            Description = "Interactively select and open an email in your default application",
            DefaultValueFactory = _ => false
        };

        var command = new Command("search", "Search emails in the archive");
        command.Arguments.Add(queryArgument);
        command.Options.Add(limitOption);
        command.Options.Add(formatOption);
        command.Options.Add(openOption);

        command.SetAction(async (parseResult, ct) =>
        {
            var query = parseResult.GetValue(queryArgument)!;
            var limit = parseResult.GetValue(limitOption);
            var format = parseResult.GetValue(formatOption)!;
            var openInteractive = parseResult.GetValue(openOption);
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(query, limit, format, openInteractive, archivePath, databasePath, verbose, ct)
                .ConfigureAwait(false);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        string query,
        int limit,
        string format,
        bool openInteractive,
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(query))
        {
            Console.Error.WriteLine("Error: Search query cannot be empty");
            return;
        }

        if (!File.Exists(databasePath))
        {
            Console.Error.WriteLine($"Error: No index exists at {databasePath}");
            Console.Error.WriteLine("Run 'myemailsearch index' first to create the index.");
            return;
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();
        var searchEngine = sp.GetRequiredService<SearchEngine>();

        await database.InitializeAsync(ct).ConfigureAwait(false);

        var results = await searchEngine.SearchAsync(query, limit, 0, ct).ConfigureAwait(false);

        try
        {
            if (openInteractive && results.Results.Count > 0)
            {
                await HandleInteractiveOpenAsync(results, ct).ConfigureAwait(false);
            }
            else
            {
                switch (format.ToLowerInvariant())
                {
                    case "json":
                        OutputJson(results);
                        break;
                    case "csv":
                        OutputCsv(results);
                        break;
                    default:
                        OutputTable(results);
                        break;
                }
            }
        }
        catch (IOException ex)
        {
            if (verbose)
            {
                Console.Error.WriteLine($"Output error: {ex.Message}");
            }
        }
    }

    private static async Task HandleInteractiveOpenAsync(SearchResultSet results, CancellationToken ct)
    {
        Console.WriteLine($"Found {results.TotalCount} results ({results.QueryTime.TotalMilliseconds:F0}ms):");
        Console.WriteLine();

        var displayCount = Math.Min(results.Results.Count, 20);
        for (var i = 0; i < displayCount; i++)
        {
            var result = results.Results[i];
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd") ?? "Unknown";
            var from = TruncateString(result.Email.FromAddress ?? "Unknown", 25);
            var subject = TruncateString(result.Email.Subject ?? "(no subject)", 45);

            Console.WriteLine($"[{i + 1,2}] {date}  {from,-25}  {subject}");
        }

        if (results.TotalCount > displayCount)
        {
            Console.WriteLine($"... and {results.TotalCount - displayCount} more (use --limit to see more)");
        }

        Console.WriteLine();
        Console.Write($"Open which result? (1-{displayCount}, or q to quit): ");

        var input = await ReadLineAsync(ct).ConfigureAwait(false);

        if (string.IsNullOrWhiteSpace(input) || input.Trim().ToLowerInvariant() == "q")
        {
            Console.WriteLine("Cancelled.");
            return;
        }

        if (!int.TryParse(input.Trim(), out var selection) || selection < 1 || selection > displayCount)
        {
            Console.Error.WriteLine($"Invalid selection. Please enter a number between 1 and {displayCount}.");
            return;
        }

        var selectedResult = results.Results[selection - 1];
        var filePath = selectedResult.Email.FilePath;

        if (!File.Exists(filePath))
        {
            Console.Error.WriteLine($"Error: Email file not found: {filePath}");
            return;
        }

        Console.WriteLine($"Opening: {filePath}");
        OpenFileWithDefaultApplication(filePath);
    }

    private static async Task<string?> ReadLineAsync(CancellationToken ct)
    {
        return await Task.Run(() =>
        {
            try
            {
                return Console.ReadLine();
            }
            catch (IOException)
            {
                return null;
            }
        }, ct).ConfigureAwait(false);
    }

    private static void OpenFileWithDefaultApplication(string filePath)
    {
        try
        {
            ProcessStartInfo psi;

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                psi = new ProcessStartInfo
                {
                    FileName = "xdg-open",
                    Arguments = $"\"{filePath}\"",
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    RedirectStandardError = true
                };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                psi = new ProcessStartInfo
                {
                    FileName = "open",
                    Arguments = $"\"{filePath}\"",
                    UseShellExecute = false,
                    CreateNoWindow = true
                };
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                psi = new ProcessStartInfo
                {
                    FileName = "cmd",
                    Arguments = $"/c start \"\" \"{filePath}\"",
                    UseShellExecute = false,
                    CreateNoWindow = true
                };
            }
            else
            {
                Console.Error.WriteLine("Unsupported platform for opening files.");
                return;
            }

            using var process = Process.Start(psi);
            process?.WaitForExit(1000);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error opening file: {ex.Message}");
        }
    }

    private static void OutputTable(SearchResultSet results)
    {
        if (results.TotalCount == 0)
        {
            Console.WriteLine("No results found.");
            return;
        }

        Console.WriteLine($"Found {results.TotalCount} results ({results.QueryTime.TotalMilliseconds:F0}ms):");
        Console.WriteLine();
        Console.WriteLine($"{"Date",-12} {"From",-30} {"Subject",-50}");
        Console.WriteLine(new string('-', 94));

        foreach (var result in results.Results)
        {
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd") ?? "Unknown";
            var from = TruncateString(result.Email.FromAddress ?? "Unknown", 28);
            var subject = TruncateString(result.Email.Subject ?? "(no subject)", 48);

            Console.WriteLine($"{date,-12} {from,-30} {subject,-50}");

            if (!string.IsNullOrWhiteSpace(result.Snippet))
            {
                var snippet = TruncateString(result.Snippet.Replace("\n", " ").Replace("\r", ""), 80);
                Console.WriteLine($"             {snippet}");
            }
        }

        Console.WriteLine();
        Console.WriteLine($"Showing {results.Results.Count} of {results.TotalCount} results");
    }

    private static void OutputJson(SearchResultSet results)
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        Console.WriteLine(JsonSerializer.Serialize(results, options));
    }

    private static void OutputCsv(SearchResultSet results)
    {
        Console.WriteLine("MessageId,From,Subject,Date,Folder,Account,FilePath");
        foreach (var result in results.Results)
        {
            var messageId = EscapeCsvField(result.Email.MessageId ?? "");
            var from = EscapeCsvField(result.Email.FromAddress ?? "");
            var subject = EscapeCsvField(result.Email.Subject ?? "");
            var date = result.Email.DateSent?.ToString("yyyy-MM-dd HH:mm:ss") ?? "";
            var folder = EscapeCsvField(result.Email.Folder ?? "");
            var account = EscapeCsvField(result.Email.Account ?? "");
            var filePath = EscapeCsvField(result.Email.FilePath);

            Console.WriteLine($"{messageId},{from},{subject},\"{date}\",{folder},{account},{filePath}");
        }
    }

    private static string TruncateString(string value, int maxLength)
    {
        if (string.IsNullOrEmpty(value)) return "";
        if (value.Length <= maxLength) return value;
        return value[..(maxLength - 3)] + "...";
    }

    private static string EscapeCsvField(string value)
    {
        if (string.IsNullOrEmpty(value)) return "\"\"";
        var escaped = value.Replace("\"", "\"\"");
        return $"\"{escaped}\"";
    }
}


================================================================================
FILE: MyEmailSearch/Commands/StatusCommand.cs
SIZE: 3.14 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.CommandLine;

using Microsoft.Extensions.DependencyInjection;

using MyEmailSearch.Configuration;
using MyEmailSearch.Data;

namespace MyEmailSearch.Commands;

/// <summary>
/// Handles the 'status' command for displaying index statistics.
/// </summary>
public static class StatusCommand
{
    public static Command Create(
        Option<string?> archiveOption,
        Option<string?> databaseOption,
        Option<bool> verboseOption)
    {
        var command = new Command("status", "Show index status and statistics");

        command.SetAction(async (parseResult, ct) =>
        {
            var archivePath = parseResult.GetValue(archiveOption)
                ?? PathResolver.GetDefaultArchivePath();
            var databasePath = parseResult.GetValue(databaseOption)
                ?? PathResolver.GetDefaultDatabasePath();
            var verbose = parseResult.GetValue(verboseOption);

            await ExecuteAsync(archivePath, databasePath, verbose, ct);
        });

        return command;
    }

    private static async Task ExecuteAsync(
        string archivePath,
        string databasePath,
        bool verbose,
        CancellationToken ct)
    {
        Console.WriteLine("MyEmailSearch - Index Status");
        Console.WriteLine(new string('=', 40));
        Console.WriteLine();

        Console.WriteLine($"Archive path:  {archivePath}");
        Console.WriteLine($"Database path: {databasePath}");
        Console.WriteLine();

        if (!File.Exists(databasePath))
        {
            Console.WriteLine("Status: No index exists yet");
            Console.WriteLine("Run 'myemailsearch index' to create the index");
            return;
        }

        await using var sp = Program.CreateServiceProvider(archivePath, databasePath, verbose);
        var database = sp.GetRequiredService<SearchDatabase>();

        try
        {
            await database.InitializeAsync(ct);

            var emailCount = await database.GetEmailCountAsync(ct);
            var dbSize = database.GetDatabaseSize();
            var lastIndexed = await database.GetMetadataAsync("last_indexed_time", ct);
            var lastIndexedTime = lastIndexed != null
                ? DateTimeOffset.FromUnixTimeSeconds(long.Parse(lastIndexed))
                : (DateTimeOffset?)null;

            Console.WriteLine($"Total emails indexed: {emailCount:N0}");
            Console.WriteLine($"Index size:           {FormatBytes(dbSize)}");
            Console.WriteLine($"Last indexed:         {lastIndexedTime?.ToString("yyyy-MM-dd HH:mm:ss") ?? "Never"}");

            var healthy = await database.IsHealthyAsync(ct);
            Console.WriteLine($"Database health:      {(healthy ? "OK" : "ERROR")}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading database: {ex.Message}");
        }
    }

    private static string FormatBytes(long bytes)
    {
        string[] suffixes = ["B", "KB", "MB", "GB", "TB"];
        var i = 0;
        var size = (double)bytes;
        while (size >= 1024 && i < suffixes.Length - 1)
        {
            size /= 1024;
            i++;
        }
        return $"{size:F2} {suffixes[i]}";
    }
}


================================================================================
FILE: MyEmailSearch/Configuration/PathResolver.cs
SIZE: 4.36 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyEmailSearch.Configuration;

/// <summary>
/// Resolves paths following XDG Base Directory Specification.
/// </summary>
public static class PathResolver
{
    private const string AppName = "myemailsearch";

    /// <summary>
    /// Gets the default archive path, checking environment and common locations.
    /// </summary>
    public static string GetDefaultArchivePath()
    {
        // Check environment variable first
        var envPath = Environment.GetEnvironmentVariable("MYIMAPDOWNLOADER_ARCHIVE");
        if (!string.IsNullOrWhiteSpace(envPath) && Directory.Exists(envPath))
        {
            return envPath;
        }

        // Check XDG_DATA_HOME
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrWhiteSpace(xdgDataHome))
        {
            var xdgPath = Path.Combine(xdgDataHome, "myimapdownloader");
            if (Directory.Exists(xdgPath))
            {
                return xdgPath;
            }
        }

        // Check common locations
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var commonPaths = new[]
        {
            Path.Combine(home, ".local", "share", "myimapdownloader"),
            Path.Combine(home, "Documents", "mail"),
            Path.Combine(home, "mail"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "mail")
        };

        foreach (var path in commonPaths)
        {
            if (Directory.Exists(path))
            {
                return path;
            }
        }

        // Default to XDG location even if it doesn't exist
        return Path.Combine(
            xdgDataHome ?? Path.Combine(home, ".local", "share"),
            "myimapdownloader");
    }

    /// <summary>
    /// Gets the default database path following XDG specification.
    /// </summary>
    public static string GetDefaultDatabasePath()
    {
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        var dataDir = !string.IsNullOrWhiteSpace(xdgDataHome)
            ? Path.Combine(xdgDataHome, AppName)
            : Path.Combine(home, ".local", "share", AppName);

        return Path.Combine(dataDir, "search.db");
    }

    /// <summary>
    /// Gets the telemetry directory following XDG specification.
    /// </summary>
    public static string? GetTelemetryDirectory()
    {
        var candidates = GetCandidateDirectories("telemetry");

        foreach (var dir in candidates)
        {
            try
            {
                if (!Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir);
                }

                // Test write access
                var testFile = Path.Combine(dir, ".write_test");
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);

                return dir;
            }
            catch
            {
                // Try next candidate
            }
        }

        return null; // No writable location found
    }

    private static IEnumerable<string> GetCandidateDirectories(string subdir)
    {
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        // XDG_DATA_HOME
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrWhiteSpace(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, AppName, subdir);
        }

        // LocalApplicationData (works on Windows too)
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrWhiteSpace(localAppData))
        {
            yield return Path.Combine(localAppData, AppName, subdir);
        }

        // XDG_STATE_HOME
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrWhiteSpace(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, AppName, subdir);
        }

        // Fallbacks
        yield return Path.Combine(home, ".local", "state", AppName, subdir);
        yield return Path.Combine(home, ".local", "share", AppName, subdir);

        // Current directory as last resort
        yield return Path.Combine(Directory.GetCurrentDirectory(), subdir);
    }
}


================================================================================
FILE: MyEmailSearch/Data/DatabaseStatistics.cs
SIZE: 0.45 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Statistics about the database.
/// </summary>
public sealed record DatabaseStatistics
{
    public long TotalEmails { get; init; }
    public long HeaderIndexed { get; init; }
    public long ContentIndexed { get; init; }
    public long FtsIndexSize { get; init; }
    public Dictionary<string, long> AccountCounts { get; init; } = new();
    public Dictionary<string, long> FolderCounts { get; init; } = new();
}


================================================================================
FILE: MyEmailSearch/Data/EmailDocument.cs
SIZE: 2.15 KB
MODIFIED: 2026-01-23 07:41:52
================================================================================

using System.Text.Json;

namespace MyEmailSearch.Data;

/// <summary>
/// Represents an indexed email document.
/// </summary>
public sealed class EmailDocument
{
    public long Id { get; set; }
    public required string MessageId { get; init; }
    public required string FilePath { get; init; }
    public string? FromAddress { get; init; }
    public string? FromName { get; init; }
    public string? ToAddressesJson { get; init; }
    public string? CcAddressesJson { get; init; }
    public string? BccAddressesJson { get; init; }
    public string? Subject { get; init; }
    public long? DateSentUnix { get; init; }
    public long? DateReceivedUnix { get; init; }
    public string? Folder { get; init; }
    public string? Account { get; init; }
    public bool HasAttachments { get; init; }
    public string? AttachmentNamesJson { get; init; }
    public string? BodyPreview { get; init; }
    public string? BodyText { get; init; }
    public long IndexedAtUnix { get; init; }
    public long LastModifiedTicks { get; init; }

    // Convenience properties
    public DateTimeOffset? DateSent => DateSentUnix.HasValue
        ? DateTimeOffset.FromUnixTimeSeconds(DateSentUnix.Value)
        : null;

    public DateTimeOffset? DateReceived => DateReceivedUnix.HasValue
        ? DateTimeOffset.FromUnixTimeSeconds(DateReceivedUnix.Value)
        : null;

    public IReadOnlyList<string> ToAddresses => ParseJsonArray(ToAddressesJson);
    public IReadOnlyList<string> CcAddresses => ParseJsonArray(CcAddressesJson);
    public IReadOnlyList<string> BccAddresses => ParseJsonArray(BccAddressesJson);
    public IReadOnlyList<string> AttachmentNames => ParseJsonArray(AttachmentNamesJson);

    private static IReadOnlyList<string> ParseJsonArray(string? json)
    {
        if (string.IsNullOrEmpty(json)) return [];
        try
        {
            return JsonSerializer.Deserialize<List<string>>(json) ?? [];
        }
        catch
        {
            return [];
        }
    }

    public static string ToJsonArray(IEnumerable<string?> items)
    {
        var list = items.Where(i => i != null).ToList();
        return list.Count > 0 ? JsonSerializer.Serialize(list) : "";
    }
}


================================================================================
FILE: MyEmailSearch/Data/IndexStatistics.cs
SIZE: 0.52 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Statistics about the search index.
/// </summary>
public sealed record IndexStatistics
{
    public long TotalEmails { get; init; }
    public long UniqueSenders { get; init; }
    public DateTimeOffset OldestEmail { get; init; }
    public DateTimeOffset NewestEmail { get; init; }
    public long EmailsWithAttachments { get; init; }
    public Dictionary<string, long> AccountCounts { get; init; } = new();
    public Dictionary<string, long> FolderCounts { get; init; } = new();
}


================================================================================
FILE: MyEmailSearch/Data/SearchDatabase.cs
SIZE: 22.95 KB
MODIFIED: 2026-01-23 07:50:51
================================================================================

using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;

namespace MyEmailSearch.Data;

/// <summary>
/// SQLite database for email search with FTS5 full-text search.
/// </summary>
public sealed partial class SearchDatabase(string databasePath, ILogger<SearchDatabase> logger) : IAsyncDisposable
{
    private readonly string _connectionString = $"Data Source={databasePath}";
    private readonly ILogger<SearchDatabase> _logger = logger;
    private SqliteConnection? _connection;
    private bool _disposed;

    private string DatabasePath { get; } = databasePath;

    public async Task InitializeAsync(CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        const string schema = """
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = NORMAL;
            PRAGMA foreign_keys = ON;

            CREATE TABLE IF NOT EXISTS emails (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                message_id TEXT NOT NULL,
                file_path TEXT NOT NULL UNIQUE,
                from_address TEXT,
                from_name TEXT,
                to_addresses TEXT,
                cc_addresses TEXT,
                bcc_addresses TEXT,
                subject TEXT,
                date_sent_unix INTEGER,
                date_received_unix INTEGER,
                folder TEXT,
                account TEXT,
                has_attachments INTEGER DEFAULT 0,
                attachment_names TEXT,
                body_preview TEXT,
                body_text TEXT,
                indexed_at_unix INTEGER NOT NULL,
                last_modified_ticks INTEGER DEFAULT 0
            );

            CREATE INDEX IF NOT EXISTS idx_emails_from ON emails(from_address);
            CREATE INDEX IF NOT EXISTS idx_emails_date ON emails(date_sent_unix);
            CREATE INDEX IF NOT EXISTS idx_emails_folder ON emails(folder);
            CREATE INDEX IF NOT EXISTS idx_emails_account ON emails(account);
            CREATE INDEX IF NOT EXISTS idx_emails_message_id ON emails(message_id);

            CREATE VIRTUAL TABLE IF NOT EXISTS emails_fts USING fts5(
                subject,
                body_text,
                from_address,
                to_addresses,
                content='emails',
                content_rowid='id',
                tokenize='porter unicode61'
            );

            CREATE TRIGGER IF NOT EXISTS emails_ai AFTER INSERT ON emails BEGIN
                INSERT INTO emails_fts(rowid, subject, body_text, from_address, to_addresses)
                VALUES (new.id, new.subject, new.body_text, new.from_address, new.to_addresses);
            END;

            CREATE TRIGGER IF NOT EXISTS emails_ad AFTER DELETE ON emails BEGIN
                INSERT INTO emails_fts(emails_fts, rowid, subject, body_text, from_address, to_addresses)
                VALUES ('delete', old.id, old.subject, old.body_text, old.from_address, old.to_addresses);
            END;

            CREATE TRIGGER IF NOT EXISTS emails_au AFTER UPDATE ON emails BEGIN
                INSERT INTO emails_fts(emails_fts, rowid, subject, body_text, from_address, to_addresses)
                VALUES ('delete', old.id, old.subject, old.body_text, old.from_address, old.to_addresses);
                INSERT INTO emails_fts(rowid, subject, body_text, from_address, to_addresses)
                VALUES (new.id, new.subject, new.body_text, new.from_address, new.to_addresses);
            END;

            CREATE TABLE IF NOT EXISTS index_metadata (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL
            );
            """;

        await ExecuteNonQueryAsync(schema, ct).ConfigureAwait(false);
    }

    public async Task<List<EmailDocument>> QueryAsync(SearchQuery query, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);
        var conditions = new List<string>();
        var parameters = new Dictionary<string, object>();

        AddQueryConditions(query, conditions, parameters);

        string sql;
        var ftsQuery = PrepareFts5MatchQuery(query.ContentTerms);

        if (!string.IsNullOrWhiteSpace(ftsQuery))
        {
            var whereClause = conditions.Count > 0
                ? $"AND {string.Join(" AND ", conditions)}" : "";

            sql = $"""
                SELECT emails.*
                FROM emails
                INNER JOIN emails_fts ON emails.id = emails_fts.rowid
                WHERE emails_fts MATCH @ftsQuery {whereClause}
                ORDER BY bm25(emails_fts)
                LIMIT @limit OFFSET @offset;
                """;
            parameters["@ftsQuery"] = ftsQuery;
        }
        else
        {
            var whereClause = conditions.Count > 0 ? $"WHERE {string.Join(" AND ", conditions)}" : "";

            sql = $"""
                SELECT * FROM emails
                {whereClause}
                ORDER BY date_sent_unix DESC
                LIMIT @limit OFFSET @offset;
                """;
        }

        parameters["@limit"] = query.Take;
        parameters["@offset"] = query.Skip;

        var results = new List<EmailDocument>();
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;

        foreach (var (key, value) in parameters)
        {
            cmd.Parameters.AddWithValue(key, value);
        }

        await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);
        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {
            results.Add(MapToEmailDocument(reader));
        }

        return results;
    }

    /// <summary>
    /// Gets the total count of emails matching the query (without LIMIT).
    /// This is the fix for the TotalCount bug.
    /// </summary>
    public async Task<int> GetTotalCountForQueryAsync(SearchQuery query, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);
        var conditions = new List<string>();
        var parameters = new Dictionary<string, object>();

        AddQueryConditions(query, conditions, parameters);

        string sql;
        var ftsQuery = PrepareFts5MatchQuery(query.ContentTerms);

        if (!string.IsNullOrWhiteSpace(ftsQuery))
        {
            var whereClause = conditions.Count > 0
                ? $"AND {string.Join(" AND ", conditions)}" : "";

            sql = $"""
                SELECT COUNT(*)
                FROM emails
                INNER JOIN emails_fts ON emails.id = emails_fts.rowid
                WHERE emails_fts MATCH @ftsQuery {whereClause};
                """;
            parameters["@ftsQuery"] = ftsQuery;
        }
        else
        {
            var whereClause = conditions.Count > 0 ? $"WHERE {string.Join(" AND ", conditions)}" : "";

            sql = $"""
                SELECT COUNT(*) FROM emails
                {whereClause};
                """;
        }

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;

        foreach (var (key, value) in parameters)
        {
            cmd.Parameters.AddWithValue(key, value);
        }

        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return Convert.ToInt32(result);
    }

    private static void AddQueryConditions(SearchQuery query, List<string> conditions, Dictionary<string, object> parameters)
    {
        if (!string.IsNullOrWhiteSpace(query.FromAddress))
        {
            if (query.FromAddress.Contains('*'))
            {
                conditions.Add("emails.from_address LIKE @fromAddress"); // Fixed: Added 'emails.' prefix
                parameters["@fromAddress"] = query.FromAddress.Replace('*', '%');
            }
            else
            {
                conditions.Add("emails.from_address = @fromAddress"); // Fixed: Added 'emails.' prefix
                parameters["@fromAddress"] = query.FromAddress;
            }
        }

        if (!string.IsNullOrWhiteSpace(query.ToAddress))
        {
            conditions.Add("emails.to_addresses LIKE @toAddress"); // Fixed: Added 'emails.' prefix
            parameters["@toAddress"] = $"%{query.ToAddress}%";
        }

        if (!string.IsNullOrWhiteSpace(query.Subject))
        {
            conditions.Add("emails.subject LIKE @subject"); // Fixed: Added 'emails.' prefix
            parameters["@subject"] = $"%{query.Subject}%";
        }

        if (query.DateFrom.HasValue)
        {
            conditions.Add("emails.date_sent_unix >= @dateFrom"); // Fixed: Added 'emails.' prefix
            parameters["@dateFrom"] = query.DateFrom.Value.ToUnixTimeSeconds();
        }

        if (query.DateTo.HasValue)
        {
            conditions.Add("emails.date_sent_unix <= @dateTo"); // Fixed: Added 'emails.' prefix
            parameters["@dateTo"] = query.DateTo.Value.ToUnixTimeSeconds();
        }

        if (!string.IsNullOrWhiteSpace(query.Account))
        {
            conditions.Add("emails.account = @account"); // Fixed: Added 'emails.' prefix
            parameters["@account"] = query.Account;
        }

        if (!string.IsNullOrWhiteSpace(query.Folder))
        {
            conditions.Add("emails.folder = @folder"); // Fixed: Added 'emails.' prefix
            parameters["@folder"] = query.Folder;
        }
    }

    public static string? PrepareFts5MatchQuery(string? searchTerms)
    {
        if (string.IsNullOrWhiteSpace(searchTerms)) return null;
        var trimmed = searchTerms.Trim();
        var hasWildcard = trimmed.EndsWith('*');
        if (hasWildcard) trimmed = trimmed[..^1];
        var escaped = $"\"{trimmed}\"";
        if (hasWildcard) escaped += "*";
        return escaped;
    }

    public static string? EscapeFts5Query(string? input)
    {
        if (input == null) return null;
        if (string.IsNullOrEmpty(input)) return "";
        var escaped = input.Replace("\"", "\"\"");
        return "\"" + escaped + "\"";
    }

    public async Task<long> GetEmailCountAsync(CancellationToken ct = default)
    {
        return await ExecuteScalarAsync<long>("SELECT COUNT(*) FROM emails;", ct).ConfigureAwait(false);
    }

    public async Task<long> GetTotalCountAsync(CancellationToken ct = default)
    {
        return await GetEmailCountAsync(ct).ConfigureAwait(false);
    }

    public async Task<bool> IsHealthyAsync(CancellationToken ct = default)
    {
        try
        {
            await ExecuteScalarAsync<long>("SELECT 1;", ct).ConfigureAwait(false);
            return true;
        }
        catch
        {
            return false;
        }
    }

    public async Task<string?> GetMetadataAsync(string key, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        const string sql = "SELECT value FROM index_metadata WHERE key = @key;";
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@key", key);

        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return result?.ToString();
    }

    public async Task SetMetadataAsync(string key, string value, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        const string sql = """
            INSERT INTO index_metadata (key, value) VALUES (@key, @value)
            ON CONFLICT(key) DO UPDATE SET value = @value;
            """;
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@key", key);
        cmd.Parameters.AddWithValue("@value", value);
        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public async Task UpsertEmailAsync(EmailDocument email, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        const string sql = """
            INSERT INTO emails (
                message_id, file_path, from_address, from_name, to_addresses, cc_addresses, bcc_addresses,
                subject, date_sent_unix, date_received_unix, folder, account, has_attachments,
                attachment_names, body_preview, body_text, indexed_at_unix, last_modified_ticks
            ) VALUES (
                @messageId, @filePath, @fromAddress, @fromName, @toAddresses, @ccAddresses, @bccAddresses,
                @subject, @dateSentUnix, @dateReceivedUnix, @folder, @account, @hasAttachments,
                @attachmentNames, @bodyPreview, @bodyText, @indexedAtUnix, @lastModifiedTicks
            )
            ON CONFLICT(file_path) DO UPDATE SET
                message_id = @messageId,
                from_address = @fromAddress,
                from_name = @fromName,
                to_addresses = @toAddresses,
                cc_addresses = @ccAddresses,
                bcc_addresses = @bccAddresses,
                subject = @subject,
                date_sent_unix = @dateSentUnix,
                date_received_unix = @dateReceivedUnix,
                folder = @folder,
                account = @account,
                has_attachments = @hasAttachments,
                attachment_names = @attachmentNames,
                body_preview = @bodyPreview,
                body_text = @bodyText,
                indexed_at_unix = @indexedAtUnix,
                last_modified_ticks = @lastModifiedTicks;
            """;

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        cmd.Parameters.AddWithValue("@messageId", email.MessageId);
        cmd.Parameters.AddWithValue("@filePath", email.FilePath);
        cmd.Parameters.AddWithValue("@fromAddress", (object?)email.FromAddress ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@fromName", (object?)email.FromName ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@toAddresses", (object?)email.ToAddressesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@ccAddresses", (object?)email.CcAddressesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@bccAddresses", (object?)email.BccAddressesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@subject", (object?)email.Subject ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@dateSentUnix", (object?)email.DateSent?.ToUnixTimeSeconds() ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@dateReceivedUnix", (object?)email.DateReceived?.ToUnixTimeSeconds() ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@folder", (object?)email.Folder ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@account", (object?)email.Account ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@hasAttachments", email.HasAttachments ? 1 : 0);
        cmd.Parameters.AddWithValue("@attachmentNames", (object?)email.AttachmentNamesJson ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@bodyPreview", (object?)email.BodyPreview ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@bodyText", (object?)email.BodyText ?? DBNull.Value);
        cmd.Parameters.AddWithValue("@indexedAtUnix", email.IndexedAtUnix);
        cmd.Parameters.AddWithValue("@lastModifiedTicks", email.LastModifiedTicks);

        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    public async Task UpsertEmailsAsync(IEnumerable<EmailDocument> emails, CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        await using var transaction = await _connection!.BeginTransactionAsync(ct).ConfigureAwait(false);
        try
        {
            foreach (var email in emails)
            {
                await UpsertEmailAsync(email, ct).ConfigureAwait(false);
            }
            await transaction.CommitAsync(ct).ConfigureAwait(false);
        }
        catch
        {
            await transaction.RollbackAsync(ct).ConfigureAwait(false);
            throw;
        }
    }

    public async Task<DatabaseStatistics> GetStatisticsAsync(CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        var totalCount = await ExecuteScalarAsync<long>("SELECT COUNT(*) FROM emails;", ct).ConfigureAwait(false);
        var headerCount = totalCount;
        var contentCount = await ExecuteScalarAsync<long>(
            "SELECT COUNT(*) FROM emails WHERE body_text IS NOT NULL AND body_text != '';", ct).ConfigureAwait(false);

        long ftsSize = 0;
        try
        {
            var pageCount = await ExecuteScalarAsync<long>(
                "SELECT COUNT(*) FROM emails_fts_data;", ct).ConfigureAwait(false);
            ftsSize = pageCount * 4096;
        }
        catch { /* FTS tables might not have _data table accessible */ }

        var accountCounts = new Dictionary<string, long>();
        await using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT account, COUNT(*) as cnt FROM emails WHERE account IS NOT NULL GROUP BY account;";
            await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);
            while (await reader.ReadAsync(ct).ConfigureAwait(false))
            {
                var account = reader.GetString(0);
                var count = reader.GetInt32(1);
                accountCounts[account] = count;
            }
        }

        var folderCounts = new Dictionary<string, long>();
        await using (var cmd = _connection!.CreateCommand())
        {
            cmd.CommandText = "SELECT folder, COUNT(*) as cnt FROM emails WHERE folder IS NOT NULL GROUP BY folder ORDER BY cnt DESC LIMIT 20;";
            await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);
            while (await reader.ReadAsync(ct).ConfigureAwait(false))
            {
                var folder = reader.GetString(0);
                var count = reader.GetInt32(1);
                folderCounts[folder] = count;
            }
        }

        return new DatabaseStatistics
        {
            TotalEmails = totalCount,
            HeaderIndexed = headerCount,
            ContentIndexed = contentCount,
            FtsIndexSize = ftsSize,
            AccountCounts = accountCounts,
            FolderCounts = folderCounts
        };
    }

    public async Task<Dictionary<string, long>> GetKnownFilesAsync(CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        var result = new Dictionary<string, long>();
        const string sql = "SELECT file_path, last_modified_ticks FROM emails;";

        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;

        await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);
        while (await reader.ReadAsync(ct).ConfigureAwait(false))
        {
            var filePath = reader.GetString(0);
            var ticks = reader.IsDBNull(1) ? 0L : reader.GetInt64(1);
            result[filePath] = ticks;
        }

        return result;
    }

    public async Task ClearAllDataAsync(CancellationToken ct = default)
    {
        await EnsureConnectionAsync(ct).ConfigureAwait(false);

        const string sql = """
            DELETE FROM emails;
            DELETE FROM emails_fts;
            DELETE FROM index_metadata;
            """;

        await ExecuteNonQueryAsync(sql, ct).ConfigureAwait(false);
    }

    private async Task EnsureConnectionAsync(CancellationToken ct)
    {
        if (_connection != null) return;

        var directory = Path.GetDirectoryName(DatabasePath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        _connection = new SqliteConnection(_connectionString);
        await _connection.OpenAsync(ct).ConfigureAwait(false);
    }

    private async Task ExecuteNonQueryAsync(string sql, CancellationToken ct)
    {
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        await cmd.ExecuteNonQueryAsync(ct).ConfigureAwait(false);
    }

    private async Task<T> ExecuteScalarAsync<T>(string sql, CancellationToken ct)
    {
        await using var cmd = _connection!.CreateCommand();
        cmd.CommandText = sql;
        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);
        return (T)Convert.ChangeType(result!, typeof(T));
    }

    private static EmailDocument MapToEmailDocument(SqliteDataReader reader)
    {
        return new EmailDocument
        {
            Id = reader.GetInt64(reader.GetOrdinal("id")),
            MessageId = reader.GetString(reader.GetOrdinal("message_id")),
            FilePath = reader.GetString(reader.GetOrdinal("file_path")),
            FromAddress = reader.IsDBNull(reader.GetOrdinal("from_address")) ? null : reader.GetString(reader.GetOrdinal("from_address")),
            FromName = reader.IsDBNull(reader.GetOrdinal("from_name")) ? null : reader.GetString(reader.GetOrdinal("from_name")),
            ToAddressesJson = reader.IsDBNull(reader.GetOrdinal("to_addresses")) ? null : reader.GetString(reader.GetOrdinal("to_addresses")),
            CcAddressesJson = reader.IsDBNull(reader.GetOrdinal("cc_addresses")) ? null : reader.GetString(reader.GetOrdinal("cc_addresses")),
            BccAddressesJson = reader.IsDBNull(reader.GetOrdinal("bcc_addresses")) ? null : reader.GetString(reader.GetOrdinal("bcc_addresses")),
            Subject = reader.IsDBNull(reader.GetOrdinal("subject")) ? null : reader.GetString(reader.GetOrdinal("subject")),
            DateSentUnix = reader.IsDBNull(reader.GetOrdinal("date_sent_unix")) ? null : reader.GetInt64(reader.GetOrdinal("date_sent_unix")),
            DateReceivedUnix = reader.IsDBNull(reader.GetOrdinal("date_received_unix")) ? null : reader.GetInt64(reader.GetOrdinal("date_received_unix")),
            Folder = reader.IsDBNull(reader.GetOrdinal("folder")) ? null : reader.GetString(reader.GetOrdinal("folder")),
            Account = reader.IsDBNull(reader.GetOrdinal("account")) ? null : reader.GetString(reader.GetOrdinal("account")),
            HasAttachments = !reader.IsDBNull(reader.GetOrdinal("has_attachments")) && reader.GetInt32(reader.GetOrdinal("has_attachments")) == 1,
            AttachmentNamesJson = reader.IsDBNull(reader.GetOrdinal("attachment_names")) ? null : reader.GetString(reader.GetOrdinal("attachment_names")),
            BodyPreview = reader.IsDBNull(reader.GetOrdinal("body_preview")) ? null : reader.GetString(reader.GetOrdinal("body_preview")),
            BodyText = reader.IsDBNull(reader.GetOrdinal("body_text")) ? null : reader.GetString(reader.GetOrdinal("body_text")),
            IndexedAtUnix = reader.GetInt64(reader.GetOrdinal("indexed_at_unix")),
            LastModifiedTicks = reader.IsDBNull(reader.GetOrdinal("last_modified_ticks")) ? 0 : reader.GetInt64(reader.GetOrdinal("last_modified_ticks"))
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        if (_connection != null)
        {
            await _connection.CloseAsync().ConfigureAwait(false);
            await _connection.DisposeAsync().ConfigureAwait(false);
            _connection = null;
        }
    }

    public long GetDatabaseSize()
    {
        if (!File.Exists(DatabasePath)) return 0;
        return new FileInfo(DatabasePath).Length;
    }
}


================================================================================
FILE: MyEmailSearch/Data/SearchQuery.cs
SIZE: 0.73 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Represents parsed search criteria.
/// </summary>
public sealed record SearchQuery
{
    public string? FromAddress { get; init; }
    public string? ToAddress { get; init; }
    public string? Subject { get; init; }
    public string? ContentTerms { get; init; }
    public DateTimeOffset? DateFrom { get; init; }
    public DateTimeOffset? DateTo { get; init; }
    public string? Account { get; init; }
    public string? Folder { get; init; }
    public int Skip { get; init; } = 0;
    public int Take { get; init; } = 100;
    public SearchSortOrder SortOrder { get; init; } = SearchSortOrder.DateDescending;
}

public enum SearchSortOrder
{
    DateDescending,
    DateAscending,
    Relevance
}


================================================================================
FILE: MyEmailSearch/Data/SearchResult.cs
SIZE: 0.76 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyEmailSearch.Data;

/// <summary>
/// Represents a single search result with optional snippet.
/// </summary>
public sealed record SearchResult
{
    public required EmailDocument Email { get; init; }
    public string? Snippet { get; init; }
    public IReadOnlyList<string> MatchedTerms { get; init; } = [];
    public double? Score { get; init; }
}

/// <summary>
/// Represents a set of search results with pagination info.
/// </summary>
public sealed record SearchResultSet
{
    public IReadOnlyList<SearchResult> Results { get; init; } = [];
    public int TotalCount { get; init; }
    public int Skip { get; init; }
    public int Take { get; init; }
    public TimeSpan QueryTime { get; init; }

    public bool HasMore => Skip + Results.Count < TotalCount;
}


================================================================================
FILE: MyEmailSearch/Indexing/ArchiveScanner.cs
SIZE: 1.85 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using Microsoft.Extensions.Logging;

namespace MyEmailSearch.Indexing;

/// <summary>
/// Scans the email archive directory for .eml files.
/// </summary>
public sealed class ArchiveScanner(ILogger<ArchiveScanner> logger)
{

    /// <summary>
    /// Scans the archive path for all .eml files.
    /// </summary>
    public IEnumerable<string> ScanForEmails(string archivePath)
    {
        if (!Directory.Exists(archivePath))
        {
            logger.LogWarning("Archive path does not exist: {Path}", archivePath);
            yield break;
        }

        logger.LogInformation("Scanning for emails in {Path}", archivePath);

        var options = new EnumerationOptions
        {
            RecurseSubdirectories = true,
            IgnoreInaccessible = true,
            MatchCasing = MatchCasing.CaseInsensitive
        };

        foreach (var file in Directory.EnumerateFiles(archivePath, "*.eml", options))
        {
            yield return file;
        }
    }

    /// <summary>
    /// Gets the account name from a file path (assumes account folder structure).
    /// </summary>
    public static string? ExtractAccountName(string filePath, string archivePath)
    {
        var relativePath = Path.GetRelativePath(archivePath, filePath);
        var parts = relativePath.Split(Path.DirectorySeparatorChar);

        // Expected structure: account_name/folder/cur/file.eml
        return parts.Length >= 2 ? parts[0] : null;
    }

    /// <summary>
    /// Gets the folder name from a file path.
    /// </summary>
    public static string? ExtractFolderName(string filePath, string archivePath)
    {
        var relativePath = Path.GetRelativePath(archivePath, filePath);
        var parts = relativePath.Split(Path.DirectorySeparatorChar);

        // Expected structure: account_name/folder/cur/file.eml
        return parts.Length >= 3 ? parts[1] : null;
    }
}


================================================================================
FILE: MyEmailSearch/Indexing/EmailParser.cs
SIZE: 4.98 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.Text.Json;

using Microsoft.Extensions.Logging;

using MimeKit;

using MyEmailSearch.Data;

namespace MyEmailSearch.Indexing;

/// <summary>
/// Parses .eml files and extracts structured data for indexing.
/// </summary>
public sealed class EmailParser(string archivePath, ILogger<EmailParser> logger)
{
    private const int BodyPreviewLength = 500;

    /// <summary>
    /// Parses an .eml file and returns an EmailDocument.
    /// </summary>
    public async Task<EmailDocument?> ParseAsync(
        string filePath,
        bool includeFullBody,
        CancellationToken ct = default)
    {
        try
        {
            var fileInfo = new FileInfo(filePath);
            var message = await MimeMessage.LoadAsync(filePath, ct).ConfigureAwait(false);
            var bodyText = GetBodyText(message);
            var bodyPreview = bodyText != null
                ? Truncate(bodyText, BodyPreviewLength)
                : null;
            var attachmentNames = message.Attachments
                .Select(a => a is MimePart mp ? mp.FileName : null)
                .Where(n => n != null)
                .Cast<string>()
                .ToList();

            return new EmailDocument
            {
                MessageId = message.MessageId ?? Path.GetFileNameWithoutExtension(filePath),
                FilePath = filePath,
                FromAddress = message.From.Mailboxes.FirstOrDefault()?.Address,
                FromName = message.From.Mailboxes.FirstOrDefault()?.Name,
                ToAddressesJson = EmailDocument.ToJsonArray(message.To.Mailboxes.Select(m => m.Address)),
                CcAddressesJson = EmailDocument.ToJsonArray(message.Cc.Mailboxes.Select(m => m.Address)),
                BccAddressesJson = EmailDocument.ToJsonArray(message.Bcc.Mailboxes.Select(m => m.Address)),
                Subject = message.Subject,
                DateSentUnix = message.Date != DateTimeOffset.MinValue
                    ? message.Date.ToUnixTimeSeconds()
                    : null,
                Folder = ArchiveScanner.ExtractFolderName(filePath, archivePath),
                Account = ArchiveScanner.ExtractAccountName(filePath, archivePath),
                HasAttachments = attachmentNames.Count > 0,
                AttachmentNamesJson = attachmentNames.Count > 0
                    ? EmailDocument.ToJsonArray(attachmentNames)
                    : null,
                BodyPreview = bodyPreview,
                BodyText = includeFullBody ? bodyText : null,
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
                LastModifiedTicks = fileInfo.LastWriteTimeUtc.Ticks
            };
        }
        catch (Exception ex)
        {
            logger.LogWarning(ex, "Failed to parse email: {Path}", filePath);
            return null;
        }
    }

    /// <summary>
    /// Attempts to read metadata from sidecar .meta.json file.
    /// </summary>
    public async Task<EmailMetadata?> ReadMetadataAsync(string emlPath, CancellationToken ct)
    {
        var metaPath = emlPath + ".meta.json";
        if (!File.Exists(metaPath))
        {
            return null;
        }

        try
        {
            var json = await File.ReadAllTextAsync(metaPath, ct).ConfigureAwait(false);
            return JsonSerializer.Deserialize<EmailMetadata>(json);
        }
        catch
        {
            return null;
        }
    }

    private static string? GetBodyText(MimeMessage message)
    {
        // Prefer plain text body
        if (!string.IsNullOrWhiteSpace(message.TextBody))
        {
            return NormalizeWhitespace(message.TextBody);
        }

        // Fall back to HTML body stripped of tags
        if (!string.IsNullOrWhiteSpace(message.HtmlBody))
        {
            return NormalizeWhitespace(StripHtml(message.HtmlBody));
        }

        return null;
    }

    private static string StripHtml(string html)
    {
        // Simple HTML tag stripping
        var result = System.Text.RegularExpressions.Regex.Replace(html, "<[^>]+>", " ");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&nbsp;", " ");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&amp;", "&");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&lt;", "<");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&gt;", ">");
        result = System.Text.RegularExpressions.Regex.Replace(result, "&quot;", "\"");
        return result;
    }

    private static string NormalizeWhitespace(string text)
    {
        return System.Text.RegularExpressions.Regex.Replace(text, @"\s+", " ").Trim();
    }

    private static string Truncate(string text, int maxLength)
    {
        if (text.Length <= maxLength) return text;
        return text[..maxLength] + "...";
    }
}

public sealed record EmailMetadata
{
    public string? MessageId { get; init; }
    public string? Subject { get; init; }
    public string? From { get; init; }
    public DateTimeOffset? Date { get; init; }
    public long? Uid { get; init; }
}


================================================================================
FILE: MyEmailSearch/Indexing/IndexManager.cs
SIZE: 4.60 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.Diagnostics;

using Microsoft.Extensions.Logging;

using MyEmailSearch.Data;

namespace MyEmailSearch.Indexing;

/// <summary>
/// Manages the email search index lifecycle.
/// </summary>
public sealed class IndexManager(
    SearchDatabase database,
    ArchiveScanner scanner,
    EmailParser parser,
    ILogger<IndexManager> logger)
{
    /// <summary>
    /// Performs incremental indexing - only indexes new or modified emails.
    /// </summary>
    public async Task<IndexingResult> IndexAsync(
        string archivePath,
        bool includeContent,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();
        var result = new IndexingResult();

        logger.LogInformation("Starting smart incremental index of {Path}", archivePath);

        // Load map of existing files and their timestamps
        var knownFiles = await database.GetKnownFilesAsync(ct).ConfigureAwait(false);
        logger.LogInformation("Loaded {Count} existing file records from database", knownFiles.Count);

        var emailFiles = scanner.ScanForEmails(archivePath).ToList();
        var batch = new List<EmailDocument>();
        var processed = 0;
        var total = emailFiles.Count;

        foreach (var file in emailFiles)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                var fileInfo = new FileInfo(file);

                // Smart Scan Check:
                // If the file path exists in DB AND the last modified time matches exact ticks,
                // we skip it entirely. This prevents parsing.
                if (knownFiles.TryGetValue(file, out var existingTicks) &&
                    existingTicks == fileInfo.LastWriteTimeUtc.Ticks)
                {
                    result.Skipped++;
                    processed++;
                    progress?.Report(new IndexingProgress(processed, total, file));
                    continue;
                }

                // Parse the email
                var doc = await parser.ParseAsync(file, includeContent, ct).ConfigureAwait(false);
                if (doc != null)
                {
                    batch.Add(doc);
                    result.Indexed++;
                }

                // Batch insert
                if (batch.Count >= 100)
                {
                    await database.UpsertEmailsAsync(batch, ct).ConfigureAwait(false);
                    batch.Clear();
                }
            }
            catch (Exception ex)
            {
                logger.LogWarning(ex, "Failed to index {File}", file);
                result.Errors++;
            }

            processed++;
            progress?.Report(new IndexingProgress(processed, total, file));
        }

        // Insert remaining batch
        if (batch.Count > 0)
        {
            await database.UpsertEmailsAsync(batch, ct).ConfigureAwait(false);
        }

        // Update metadata
        await database.SetMetadataAsync("last_indexed_time",
            DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ct).ConfigureAwait(false);

        stopwatch.Stop();
        result.Duration = stopwatch.Elapsed;

        logger.LogInformation(
            "Indexing complete: {Indexed} indexed, {Skipped} skipped, {Errors} errors in {Duration}",
            result.Indexed, result.Skipped, result.Errors, result.Duration);

        return result;
    }

    /// <summary>
    /// Rebuilds the entire index from scratch.
    /// </summary>
    public async Task<IndexingResult> RebuildIndexAsync(
        string archivePath,
        bool includeContent,
        IProgress<IndexingProgress>? progress = null,
        CancellationToken ct = default)
    {
        logger.LogWarning("Starting full index rebuild - this will delete all existing data");

        // Clear existing data and reinitialize
        await database.ClearAllDataAsync(ct).ConfigureAwait(false);
        await database.InitializeAsync(ct).ConfigureAwait(false);

        // Run full index
        return await IndexAsync(archivePath, includeContent, progress, ct).ConfigureAwait(false);
    }
}

/// <summary>
/// Result of an indexing operation.
/// </summary>
public sealed class IndexingResult
{
    public int Indexed { get; set; }
    public int Skipped { get; set; }
    public int Errors { get; set; }
    public TimeSpan Duration { get; set; }
}

/// <summary>
/// Progress report for indexing operations.
/// </summary>
public sealed record IndexingProgress(int Processed, int Total, string? CurrentFile = null)
{
    public double Percentage => Total > 0 ? (double)Processed / Total * 100 : 0;
}


================================================================================
FILE: MyEmailSearch/MyEmailSearch.csproj
SIZE: 0.98 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyEmailSearch - Email Archive Search Utility
    
    Provides search capabilities over archived emails.
    Uses MyImapDownloader.Core for shared infrastructure.
  -->
  
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <RootNamespace>MyEmailSearch</RootNamespace>
    <AssemblyName>MyEmailSearch</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <!-- Core library reference -->
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- CLI Framework -->
    <PackageReference Include="System.CommandLine" />
    
    <!-- Email Parsing -->
    <PackageReference Include="MimeKit" />
    
    <!-- SQLite (additional to Core for FTS5) -->
    <PackageReference Include="SQLitePCLRaw.bundle_e_sqlite3" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: MyEmailSearch/Program.cs
SIZE: 3.53 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.CommandLine;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

using MyEmailSearch.Commands;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;
using MyEmailSearch.Search;

namespace MyEmailSearch;

public static class Program
{
    public static async Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("MyEmailSearch - Search your email archive");
        // {
        //     Name = "myemailsearch"
        // };

        // Define Global options
        var archiveOption = new Option<string?>("--archive", "-a")
        {
            Description = "Path to the email archive directory"
        };

        var databaseOption = new Option<string?>("--database", "-d")
        {
            Description = "Path to the search database file"
        };

        var verboseOption = new Option<bool>("--verbose", "-v")
        {
            Description = "Enable verbose output"
        };

        // Add options to the root command (acting as global options)
        rootCommand.Options.Add(archiveOption);
        rootCommand.Options.Add(databaseOption);
        rootCommand.Options.Add(verboseOption);

        // Add subcommands using the Subcommands collection
        rootCommand.Subcommands.Add(SearchCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(IndexCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(StatusCommand.Create(archiveOption, databaseOption, verboseOption));
        rootCommand.Subcommands.Add(RebuildCommand.Create(archiveOption, databaseOption, verboseOption));

        // Use the modern invocation pattern for System.CommandLine 2.0.x
        return await rootCommand.Parse(args).InvokeAsync().ConfigureAwait(false);
    }

    /// <summary>
    /// Creates a service provider with all required dependencies, manually resolving path-based dependencies.
    /// </summary>
    public static ServiceProvider CreateServiceProvider(
        string archivePath,
        string databasePath,
        bool verbose)
    {
        var services = new ServiceCollection();

        // Logging
        services.AddLogging(builder =>
        {
            builder.AddConsole();
            builder.SetMinimumLevel(verbose ? LogLevel.Debug : LogLevel.Information);
        });

        // Database - manually passing the databasePath
        services.AddSingleton(sp =>
            new SearchDatabase(databasePath, sp.GetRequiredService<ILogger<SearchDatabase>>()));

        // Search components
        services.AddSingleton<QueryParser>();
        services.AddSingleton<SnippetGenerator>();
        services.AddSingleton(sp => new SearchEngine(
            sp.GetRequiredService<SearchDatabase>(),
            sp.GetRequiredService<QueryParser>(),
            sp.GetRequiredService<SnippetGenerator>(),
            sp.GetRequiredService<ILogger<SearchEngine>>()));

        // Indexing components - manually passing the archivePath to EmailParser
        services.AddSingleton(sp =>
            new ArchiveScanner(sp.GetRequiredService<ILogger<ArchiveScanner>>()));

        services.AddSingleton(sp =>
            new EmailParser(archivePath, sp.GetRequiredService<ILogger<EmailParser>>()));

        services.AddSingleton(sp => new IndexManager(
            sp.GetRequiredService<SearchDatabase>(),
            sp.GetRequiredService<ArchiveScanner>(),
            sp.GetRequiredService<EmailParser>(),
            sp.GetRequiredService<ILogger<IndexManager>>()));

        return services.BuildServiceProvider();
    }
}


================================================================================
FILE: MyEmailSearch/Search/QueryParser.cs
SIZE: 5.33 KB
MODIFIED: 2026-01-23 07:34:47
================================================================================

using System.Text.RegularExpressions;

using MyEmailSearch.Data;

namespace MyEmailSearch.Search;

/// <summary>
/// Parses user search queries into structured SearchQuery objects.
/// Supports syntax like: from:alice@example.com subject:"project update" kafka
/// </summary>
public sealed partial class QueryParser
{
    [GeneratedRegex("""from:(?<value>"[^"]+"|\S+)""", RegexOptions.IgnoreCase)]
    private static partial Regex FromPattern();

    [GeneratedRegex("""to:(?<value>"[^"]+"|\S+)""", RegexOptions.IgnoreCase)]
    private static partial Regex ToPattern();

    [GeneratedRegex("""subject:(?<value>"[^"]+"|\S+)""", RegexOptions.IgnoreCase)]
    private static partial Regex SubjectPattern();

    [GeneratedRegex(@"date:(?<from>\d{4}-\d{2}-\d{2})(?:\.\.(?<to>\d{4}-\d{2}-\d{2}))?", RegexOptions.IgnoreCase)]
    private static partial Regex DatePattern();

    [GeneratedRegex(@"account:(?<value>\S+)", RegexOptions.IgnoreCase)]
    private static partial Regex AccountPattern();

    [GeneratedRegex("""folder:(?<value>"[^"]+"|\S+)""", RegexOptions.IgnoreCase)]
    private static partial Regex FolderPattern();

    // Fix: Added regex patterns for 'after:' and 'before:'
    [GeneratedRegex(@"after:(?<value>\d{4}-\d{2}-\d{2})", RegexOptions.IgnoreCase)]
    private static partial Regex AfterPattern();

    [GeneratedRegex(@"before:(?<value>\d{4}-\d{2}-\d{2})", RegexOptions.IgnoreCase)]
    private static partial Regex BeforePattern();

    /// <summary>
    /// Parses a user query string into a SearchQuery object.
    /// </summary>
    public SearchQuery Parse(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return new SearchQuery();
        }

        var remaining = input;
        string? fromAddress = null;
        string? toAddress = null;
        string? subject = null;
        string? account = null;
        string? folder = null;
        DateTimeOffset? dateFrom = null;
        DateTimeOffset? dateTo = null;

        // Extract from: field
        var fromMatch = FromPattern().Match(remaining);
        if (fromMatch.Success)
        {
            fromAddress = ExtractValue(fromMatch.Groups["value"].Value);
            remaining = FromPattern().Replace(remaining, "", 1);
        }

        // Extract to: field
        var toMatch = ToPattern().Match(remaining);
        if (toMatch.Success)
        {
            toAddress = ExtractValue(toMatch.Groups["value"].Value);
            remaining = ToPattern().Replace(remaining, "", 1);
        }

        // Extract subject: field
        var subjectMatch = SubjectPattern().Match(remaining);
        if (subjectMatch.Success)
        {
            subject = ExtractValue(subjectMatch.Groups["value"].Value);
            remaining = SubjectPattern().Replace(remaining, "", 1);
        }

        // Extract date: field
        var dateMatch = DatePattern().Match(remaining);
        if (dateMatch.Success)
        {
            if (DateTimeOffset.TryParse(dateMatch.Groups["from"].Value, out var from))
            {
                dateFrom = from;
            }
            if (dateMatch.Groups["to"].Success &&
                DateTimeOffset.TryParse(dateMatch.Groups["to"].Value, out var to))
            {
                dateTo = to.AddDays(1).AddTicks(-1); // End of day
            }
            remaining = DatePattern().Replace(remaining, "", 1);
        }

        // Extract account: field
        var accountMatch = AccountPattern().Match(remaining);
        if (accountMatch.Success)
        {
            account = accountMatch.Groups["value"].Value;
            remaining = AccountPattern().Replace(remaining, "", 1);
        }

        // Extract folder: field
        var folderMatch = FolderPattern().Match(remaining);
        if (folderMatch.Success)
        {
            folder = ExtractValue(folderMatch.Groups["value"].Value);
            remaining = FolderPattern().Replace(remaining, "", 1);
        }

        // Fix: Added logic to handle 'after:'
        var afterMatch = AfterPattern().Match(remaining);
        if (afterMatch.Success)
        {
            if (DateTimeOffset.TryParse(afterMatch.Groups["value"].Value, out var date))
            {
                dateFrom = date;
            }
            remaining = AfterPattern().Replace(remaining, "", 1);
        }

        // Fix: Added logic to handle 'before:'
        var beforeMatch = BeforePattern().Match(remaining);
        if (beforeMatch.Success)
        {
            if (DateTimeOffset.TryParse(beforeMatch.Groups["value"].Value, out var date))
            {
                dateTo = date;
            }
            remaining = BeforePattern().Replace(remaining, "", 1);
        }

        // Remaining text is full-text content search
        var contentTerms = remaining.Trim();

        return new SearchQuery
        {
            FromAddress = fromAddress,
            ToAddress = toAddress,
            Subject = subject,
            ContentTerms = string.IsNullOrWhiteSpace(contentTerms) ? null : contentTerms,
            DateFrom = dateFrom,
            DateTo = dateTo,
            Account = account,
            Folder = folder
        };
    }

    private static string ExtractValue(string value)
    {
        // Remove surrounding quotes if present
        if (value.StartsWith('"') && value.EndsWith('"') && value.Length > 2)
        {
            return value[1..^1];
        }
        return value;
    }
}


================================================================================
FILE: MyEmailSearch/Search/SearchEngine.cs
SIZE: 4.23 KB
MODIFIED: 2026-01-23 07:37:28
================================================================================

using System.Diagnostics;

using Microsoft.Extensions.Logging;

using MyEmailSearch.Data;

namespace MyEmailSearch.Search;

/// <summary>
/// Main search engine that coordinates queries against the SQLite database.
/// </summary>
public sealed class SearchEngine(
    SearchDatabase database,
    QueryParser queryParser,
    SnippetGenerator snippetGenerator,
    ILogger<SearchEngine> logger)
{
    private readonly SearchDatabase _database = database ?? throw new ArgumentNullException(nameof(database));
    private readonly QueryParser _queryParser = queryParser ?? throw new ArgumentNullException(nameof(queryParser));
    private readonly SnippetGenerator _snippetGenerator = snippetGenerator ?? throw new ArgumentNullException(nameof(snippetGenerator));
    private readonly ILogger<SearchEngine> _logger = logger ?? throw new ArgumentNullException(nameof(logger));

    /// <summary>
    /// Executes a search query string and returns results.
    /// </summary>
    public async Task<SearchResultSet> SearchAsync(
        string queryString,
        int limit = 100,
        int offset = 0,
        CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(queryString))
        {
            return new SearchResultSet
            {
                Results = [],
                TotalCount = 0,
                Skip = offset,
                Take = limit,
                QueryTime = TimeSpan.Zero
            };
        }

        var query = _queryParser.Parse(queryString);
        query = query with { Take = limit, Skip = offset };

        return await SearchAsync(query, ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Executes a parsed search query and returns results.
    /// </summary>
    private async Task<SearchResultSet> SearchAsync(
        SearchQuery query,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();

        _logger.LogInformation("Executing search: {Query}", FormatQueryForLog(query));

        // Execute the search query (with LIMIT)
        var emails = await _database.QueryAsync(query, ct).ConfigureAwait(false);

        // FIX: Get actual total count (without LIMIT) for accurate pagination
        var totalCount = await _database.GetTotalCountForQueryAsync(query, ct).ConfigureAwait(false);

        var results = new List<SearchResult>();
        foreach (var email in emails)
        {
            var snippet = !string.IsNullOrWhiteSpace(query.ContentTerms)
                ? SnippetGenerator.Generate(email.BodyText, query.ContentTerms)
                : email.BodyPreview;

            results.Add(new SearchResult
            {
                Email = email,
                Snippet = snippet,
                MatchedTerms = ExtractMatchedTerms(query)
            });
        }

        stopwatch.Stop();

        _logger.LogInformation(
            "Search completed: {ResultCount} results returned, {TotalCount} total matches in {ElapsedMs}ms",
            results.Count, totalCount, stopwatch.ElapsedMilliseconds);

        return new SearchResultSet
        {
            Results = results,
            TotalCount = totalCount,
            Skip = query.Skip,
            Take = query.Take,
            QueryTime = stopwatch.Elapsed
        };
    }

    private static string FormatQueryForLog(SearchQuery query)
    {
        var parts = new List<string>();
        if (!string.IsNullOrWhiteSpace(query.FromAddress)) parts.Add($"from:{query.FromAddress}");
        if (!string.IsNullOrWhiteSpace(query.ToAddress)) parts.Add($"to:{query.ToAddress}");
        if (!string.IsNullOrWhiteSpace(query.Subject)) parts.Add($"subject:{query.Subject}");
        if (!string.IsNullOrWhiteSpace(query.ContentTerms)) parts.Add(query.ContentTerms);
        if (!string.IsNullOrWhiteSpace(query.Account)) parts.Add($"account:{query.Account}");
        if (!string.IsNullOrWhiteSpace(query.Folder)) parts.Add($"folder:{query.Folder}");
        return string.Join(" ", parts);
    }

    private static IReadOnlyList<string> ExtractMatchedTerms(SearchQuery query)
    {
        var terms = new List<string>();

        if (!string.IsNullOrWhiteSpace(query.ContentTerms))
        {
            terms.AddRange(query.ContentTerms.Split(' ', StringSplitOptions.RemoveEmptyEntries));
        }

        return terms;
    }
}


================================================================================
FILE: MyEmailSearch/Search/SnippetGenerator.cs
SIZE: 2.59 KB
MODIFIED: 2026-01-23 07:37:19
================================================================================

using System.Text;

namespace MyEmailSearch.Search;

/// <summary>
/// Generates contextual snippets from email body text highlighting matched terms.
/// </summary>
public sealed class SnippetGenerator
{
    private const int SnippetLength = 200;
    private const int ContextPadding = 50;

    /// <summary>
    /// Generates a snippet from the body text centered around the search terms.
    /// </summary>
    public static string? Generate(string? bodyText, string? searchTerms)
    {
        if (string.IsNullOrWhiteSpace(bodyText))
        {
            return null;
        }

        if (string.IsNullOrWhiteSpace(searchTerms))
        {
            return Truncate(bodyText, SnippetLength);
        }

        var terms = searchTerms.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var firstMatchIndex = -1;

        // Find the first occurrence of any search term
        foreach (var term in terms)
        {
            var index = bodyText.IndexOf(term, StringComparison.OrdinalIgnoreCase);
            if (index >= 0 && (firstMatchIndex < 0 || index < firstMatchIndex))
            {
                firstMatchIndex = index;
            }
        }

        if (firstMatchIndex < 0)
        {
            return Truncate(bodyText, SnippetLength);
        }

        // Calculate snippet window
        var start = Math.Max(0, firstMatchIndex - ContextPadding);
        var end = Math.Min(bodyText.Length, start + SnippetLength);

        // Adjust start to word boundary
        if (start > 0)
        {
            var wordStart = bodyText.LastIndexOf(' ', start);
            if (wordStart > 0)
            {
                start = wordStart + 1;
            }
        }

        // Adjust end to word boundary
        if (end < bodyText.Length)
        {
            var wordEnd = bodyText.IndexOf(' ', end);
            if (wordEnd > 0)
            {
                end = wordEnd;
            }
        }

        var snippet = new StringBuilder();
        if (start > 0)
        {
            snippet.Append("...");
        }

        snippet.Append(bodyText.AsSpan(start, end - start));

        if (end < bodyText.Length)
        {
            snippet.Append("...");
        }

        return snippet.ToString();
    }

    private static string Truncate(string text, int maxLength)
    {
        if (text.Length <= maxLength)
        {
            return text;
        }

        var truncated = text[..maxLength];
        var lastSpace = truncated.LastIndexOf(' ');
        if (lastSpace > maxLength / 2)
        {
            truncated = truncated[..lastSpace];
        }

        return truncated + "...";
    }
}


================================================================================
FILE: MyEmailSearch/Telemetry/DiagnosticsConfig.cs
SIZE: 1.66 KB
MODIFIED: 2026-01-23 07:38:21
================================================================================

using System.Diagnostics.Metrics;

using MyImapDownloader.Core.Telemetry;

namespace MyEmailSearch.Telemetry;

/// <summary>
/// Application-specific diagnostics configuration for MyEmailSearch.
/// </summary>
public static class DiagnosticsConfig
{
    private const string ServiceName = "MyEmailSearch";
    private const string ServiceVersion = "1.0.0";

    private static readonly DiagnosticsConfigBase Base = new(ServiceName, ServiceVersion);

    public static System.Diagnostics.ActivitySource ActivitySource => Base.ActivitySource;
    public static Meter Meter => Base.Meter;

    // Search metrics
    public static readonly Counter<long> SearchesExecuted = Base.CreateCounter<long>(
        "searches.executed", "queries", "Total search queries executed");

    public static readonly Counter<long> SearchErrors = Base.CreateCounter<long>(
        "searches.errors", "errors", "Search query errors");

    public static readonly Histogram<double> SearchDuration = Base.CreateHistogram<double>(
        "search.duration", "ms", "Search query execution time");

    public static readonly Histogram<long> SearchResultCount = Base.CreateHistogram<long>(
        "search.results", "emails", "Number of results per search");

    // Indexing metrics
    public static readonly Counter<long> EmailsIndexed = Base.CreateCounter<long>(
        "indexing.emails", "emails", "Emails indexed");

    public static readonly Counter<long> IndexingErrors = Base.CreateCounter<long>(
        "indexing.errors", "errors", "Indexing errors");

    public static readonly Histogram<double> IndexingDuration = Base.CreateHistogram<double>(
        "indexing.duration", "ms", "Indexing operation duration");
}


================================================================================
FILE: MyEmailSearch.Tests/Configuration/PathResolverTests.cs
SIZE: 1.08 KB
MODIFIED: 2026-02-18 20:00:41
================================================================================

using MyEmailSearch.Configuration;

namespace MyEmailSearch.Tests.Configuration;

/// <summary>
/// Tests for MyEmailSearch.Configuration.PathResolver.
/// </summary>
public class PathResolverTests
{
    [Test]
    public async Task GetDefaultDatabasePath_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetDefaultDatabasePath();

        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task GetDefaultDatabasePath_EndsWithDbExtension()
    {
        var path = PathResolver.GetDefaultDatabasePath();

        await Assert.That(path).EndsWith(".db");
    }

    [Test]
    public async Task GetDefaultArchivePath_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetDefaultArchivePath();

        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task GetDefaultDatabasePath_ContainsMyEmailSearch()
    {
        var path = PathResolver.GetDefaultDatabasePath();

        await Assert.That(path.ToLowerInvariant()).Contains("myemailsearch");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/Fts5HelperTests.cs
SIZE: 1.68 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using MyEmailSearch.Data;

namespace MyEmailSearch.Tests.Data;

public class Fts5HelperTests
{
    [Test]
    public async Task PrepareFts5MatchQuery_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery(null);

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithEmptyString_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("");

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWhitespace_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("   ");

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWildcard_PreservesWildcard()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("test*");

        await Assert.That(result).IsEqualTo("\"test\"*");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithoutWildcard_WrapsInQuotes()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("test query");

        await Assert.That(result).IsEqualTo("\"test query\"");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithFts5Operators_EscapesThem()
    {
        // Users shouldn't be able to inject FTS5 operators like OR, AND, NOT
        var result = SearchDatabase.PrepareFts5MatchQuery("test OR hack");

        await Assert.That(result).IsEqualTo("\"test OR hack\"");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithParentheses_EscapesThem()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("(test)");

        await Assert.That(result).IsEqualTo("\"(test)\"");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseBatchTests.cs
SIZE: 2.79 KB
MODIFIED: 2026-02-18 20:00:58
================================================================================

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Data;

/// <summary>
/// Tests for SearchDatabase batch operations.
/// </summary>
public class SearchDatabaseBatchTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("db_batch_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<SearchDatabase> CreateDatabaseAsync()
    {
        var dbPath = Path.Combine(_temp.Path, $"test_{Guid.NewGuid():N}.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task BatchUpsertEmailsAsync_InsertsMultipleEmails()
    {
        var db = await CreateDatabaseAsync();

        var docs = Enumerable.Range(0, 50).Select(i => new EmailDocument
        {
            MessageId = $"batch{i}@example.com",
            FilePath = $"/test/batch{i}.eml",
            Subject = $"Batch Email {i}",
            FromAddress = "sender@example.com",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        }).ToList();

        await db.BatchUpsertEmailsAsync(docs);

        var count = await db.GetEmailCountAsync();
        await Assert.That(count).IsEqualTo(50);
    }

    [Test]
    public async Task BatchUpsertEmailsAsync_EmptyList_DoesNotThrow()
    {
        var db = await CreateDatabaseAsync();

        await db.BatchUpsertEmailsAsync(new List<EmailDocument>());

        var count = await db.GetEmailCountAsync();
        await Assert.That(count).IsEqualTo(0);
    }

    [Test]
    public async Task BatchUpsertEmailsAsync_AllSearchable_AfterInsert()
    {
        var db = await CreateDatabaseAsync();

        var docs = Enumerable.Range(0, 10).Select(i => new EmailDocument
        {
            MessageId = $"searchable{i}@example.com",
            FilePath = $"/test/searchable{i}.eml",
            Subject = $"Searchable BatchItem {i}",
            FromAddress = "batchsender@example.com",
            BodyText = $"Unique content for batch item number {i} with keyword xylophone",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        }).ToList();

        await db.BatchUpsertEmailsAsync(docs);

        var results = await db.QueryAsync(new SearchQuery { ContentTerms = "xylophone" });
        await Assert.That(results.Count).IsEqualTo(10);

        var fromResults = await db.QueryAsync(new SearchQuery { FromAddress = "batchsender@example.com" });
        await Assert.That(fromResults.Count).IsEqualTo(10);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseCountTests.cs
SIZE: 6.95 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;

namespace MyEmailSearch.Tests.Data;

/// <summary>
/// Tests for SearchDatabase total count functionality.
/// </summary>
public class SearchDatabaseCountTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private SearchDatabase? _database;

    public SearchDatabaseCountTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"count_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private async Task<SearchDatabase> CreateDatabaseAsync()
    {
        var dbPath = Path.Combine(_testDirectory, "test.db");
        var logger = new NullLogger<SearchDatabase>();
        var db = new SearchDatabase(dbPath, logger);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task GetTotalCountForQueryAsync_ReturnsAllMatchingEmails_NotJustLimit()
    {
        // Arrange
        var db = await CreateDatabaseAsync();

        // Insert 150 emails to the same recipient
        for (var i = 0; i < 150; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"test{i}@example.com",
                FilePath = $"/test/email{i}.eml",
                Subject = $"Test Email {i}",
                FromAddress = "sender@example.com",
                ToAddressesJson = "[\"recipient@tilde.team\"]",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        var query = new SearchQuery
        {
            ToAddress = "recipient@tilde.team",
            Take = 100,  // Limit to 100
            Skip = 0
        };

        // Act
        var totalCount = await db.GetTotalCountForQueryAsync(query);

        // Assert - should be 150, not 100
        totalCount.Should().Be(150);
    }

    [Test]
    public async Task GetTotalCountForQueryAsync_WithFromFilter_ReturnsCorrectCount()
    {
        // Arrange
        var db = await CreateDatabaseAsync();

        // Insert 50 emails from alice
        for (var i = 0; i < 50; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"alice{i}@example.com",
                FilePath = $"/test/alice{i}.eml",
                Subject = $"From Alice {i}",
                FromAddress = "alice@example.com",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        // Insert 30 emails from bob
        for (var i = 0; i < 30; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"bob{i}@example.com",
                FilePath = $"/test/bob{i}.eml",
                Subject = $"From Bob {i}",
                FromAddress = "bob@example.com",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        var query = new SearchQuery
        {
            FromAddress = "alice@example.com",
            Take = 10,
            Skip = 0
        };

        // Act
        var totalCount = await db.GetTotalCountForQueryAsync(query);

        // Assert
        totalCount.Should().Be(50);
    }

    [Test]
    public async Task GetTotalCountForQueryAsync_WithDateRange_ReturnsCorrectCount()
    {
        // Arrange
        var db = await CreateDatabaseAsync();
        var baseDate = DateTimeOffset.UtcNow;

        // Insert 20 emails from this week
        for (var i = 0; i < 20; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"recent{i}@example.com",
                FilePath = $"/test/recent{i}.eml",
                Subject = $"Recent Email {i}",
                FromAddress = "sender@example.com",
                DateSentUnix = baseDate.AddDays(-i).ToUnixTimeSeconds(),
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        // Insert 30 emails from last month
        for (var i = 0; i < 30; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"old{i}@example.com",
                FilePath = $"/test/old{i}.eml",
                Subject = $"Old Email {i}",
                FromAddress = "sender@example.com",
                DateSentUnix = baseDate.AddDays(-30 - i).ToUnixTimeSeconds(),
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        var query = new SearchQuery
        {
            DateFrom = baseDate.AddDays(-7),  // Last 7 days
            Take = 5,
            Skip = 0
        };

        // Act
        var totalCount = await db.GetTotalCountForQueryAsync(query);

        // Assert - should be 8 (days 0-7 inclusive)
        totalCount.Should().Be(8);
    }

    [Test]
    public async Task GetTotalCountForQueryAsync_NoMatches_ReturnsZero()
    {
        // Arrange
        var db = await CreateDatabaseAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "test@example.com",
            FilePath = "/test/email.eml",
            Subject = "Test Email",
            FromAddress = "sender@example.com",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        var query = new SearchQuery
        {
            FromAddress = "nonexistent@example.com",
            Take = 100,
            Skip = 0
        };

        // Act
        var totalCount = await db.GetTotalCountForQueryAsync(query);

        // Assert
        totalCount.Should().Be(0);
    }

    [Test]
    public async Task QueryAsync_ReturnsLimitedResults_WhileCountReturnsAll()
    {
        // Arrange
        var db = await CreateDatabaseAsync();

        // Insert 200 emails
        for (var i = 0; i < 200; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"test{i}@example.com",
                FilePath = $"/test/email{i}.eml",
                Subject = $"Test Email {i}",
                FromAddress = "sender@example.com",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        var query = new SearchQuery
        {
            FromAddress = "sender@example.com",
            Take = 50,
            Skip = 0
        };

        // Act
        var results = await db.QueryAsync(query);
        var totalCount = await db.GetTotalCountForQueryAsync(query);

        // Assert
        results.Should().HaveCount(50);      // Limited results
        totalCount.Should().Be(200);         // Actual total
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseEscapingTests.cs
SIZE: 2.00 KB
MODIFIED: 2026-01-22 07:04:25
================================================================================

namespace MyEmailSearch.Tests.Data;

using MyEmailSearch.Data;

/// <summary>
/// Tests for FTS5 query escaping methods.
/// </summary>
public class SearchDatabaseEscapingTests
{
    [Test]
    public async Task EscapeFts5Query_WithSpecialCharacters_EscapesCorrectly()
    {
        // Input: test"query -> Output: "test""query"
        var result = SearchDatabase.EscapeFts5Query("test\"query");

        await Assert.That(result).IsEqualTo("\"test\"\"query\"");
    }

    [Test]
    public async Task EscapeFts5Query_WithNormalText_WrapsInQuotes()
    {
        var result = SearchDatabase.EscapeFts5Query("hello world");

        await Assert.That(result).IsEqualTo("\"hello world\"");
    }

    [Test]
    public async Task EscapeFts5Query_WithEmptyString_ReturnsEmpty()
    {
        // Implementation returns "" for empty input (not wrapped in quotes)
        var result = SearchDatabase.EscapeFts5Query("");

        await Assert.That(result).IsEqualTo("");
    }

    [Test]
    public async Task EscapeFts5Query_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.EscapeFts5Query(null);

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery(null);

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWhitespace_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("   ");

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithSimpleText_WrapsInQuotes()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("search term");

        await Assert.That(result).IsEqualTo("\"search term\"");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWildcard_PreservesWildcard()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("search*");

        await Assert.That(result).IsEqualTo("\"search\"*");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseFtsTests.cs
SIZE: 4.98 KB
MODIFIED: 2026-01-22 06:59:17
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;

namespace MyEmailSearch.Tests.Data;

/// <summary>
/// Tests for FTS5 full-text search functionality.
/// </summary>
public class SearchDatabaseFtsTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private SearchDatabase? _database;

    public SearchDatabaseFtsTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"fts_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private async Task<SearchDatabase> CreateDatabaseAsync()
    {
        var dbPath = Path.Combine(_testDirectory, "test.db");
        var logger = NullLogger<SearchDatabase>.Instance;
        var db = new SearchDatabase(dbPath, logger);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery(null);
        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithEmptyString_ReturnsNull()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("");
        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithWildcard_PreservesWildcard()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("test*");
        await Assert.That(result).IsEqualTo("\"test\"*");
    }

    [Test]
    public async Task PrepareFts5MatchQuery_WithoutWildcard_WrapsInQuotes()
    {
        var result = SearchDatabase.PrepareFts5MatchQuery("test query");
        await Assert.That(result).IsEqualTo("\"test query\"");
    }

    [Test]
    public async Task EscapeFts5Query_WithNull_ReturnsNull()
    {
        var result = SearchDatabase.EscapeFts5Query(null);
        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task EscapeFts5Query_WithQuotes_EscapesThem()
    {
        var result = SearchDatabase.EscapeFts5Query("test \"with\" quotes");
        // Should escape internal quotes by doubling them
        result.Should().Contain("\"\"");
    }

    [Test]
    public async Task EscapeFts5Query_WithNormalText_WrapsInQuotes()
    {
        var result = SearchDatabase.EscapeFts5Query("hello world");
        await Assert.That(result).IsEqualTo("\"hello world\"");
    }

    [Test]
    public async Task QueryAsync_SubjectSearch_FindsMatchingEmail()
    {
        // Arrange
        var db = await CreateDatabaseAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "test1@example.com",
            FilePath = "/test/email1.eml",
            Subject = "Important Meeting Tomorrow",
            FromAddress = "sender@example.com",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "test2@example.com",
            FilePath = "/test/email2.eml",
            Subject = "Casual Chat",
            FromAddress = "sender@example.com",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        // Act - search for "important" in subject
        var results = await db.QueryAsync(new SearchQuery { Subject = "Important" });

        // Assert
        await Assert.That(results.Count).IsEqualTo(1);
        results[0].Subject.Should().Contain("Important");
    }

    [Test]
    public async Task QueryAsync_FtsSearch_FindsMatchingEmailByBodyText()
    {
        // Arrange
        var db = await CreateDatabaseAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "body1@example.com",
            FilePath = "/test/body1.eml",
            Subject = "Regular Email",
            FromAddress = "sender@example.com",
            BodyText = "This email contains the word kafka which is unique",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "body2@example.com",
            FilePath = "/test/body2.eml",
            Subject = "Another Email",
            FromAddress = "sender@example.com",
            BodyText = "This is just a normal email about nothing special",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        // Act - search for "kafka" in body
        var results = await db.QueryAsync(new SearchQuery { ContentTerms = "kafka" });

        // Assert
        await Assert.That(results.Count).IsEqualTo(1);
        results[0].MessageId.Should().Be("body1@example.com");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseMetadataTests.cs
SIZE: 6.40 KB
MODIFIED: 2026-02-18 20:00:41
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Data;

/// <summary>
/// Tests for SearchDatabase metadata, size, health, and lifecycle operations.
/// </summary>
public class SearchDatabaseMetadataTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("db_meta_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<SearchDatabase> CreateDatabaseAsync()
    {
        var dbPath = Path.Combine(_temp.Path, $"test_{Guid.NewGuid():N}.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task SetMetadataAsync_And_GetMetadataAsync_RoundTrips()
    {
        var db = await CreateDatabaseAsync();

        await db.SetMetadataAsync("test_key", "test_value");
        var result = await db.GetMetadataAsync("test_key");

        await Assert.That(result).IsEqualTo("test_value");
    }

    [Test]
    public async Task GetMetadataAsync_NonExistentKey_ReturnsNull()
    {
        var db = await CreateDatabaseAsync();

        var result = await db.GetMetadataAsync("nonexistent_key");

        await Assert.That(result).IsNull();
    }

    [Test]
    public async Task SetMetadataAsync_OverwritesExistingKey()
    {
        var db = await CreateDatabaseAsync();

        await db.SetMetadataAsync("version", "1.0");
        await db.SetMetadataAsync("version", "2.0");
        var result = await db.GetMetadataAsync("version");

        await Assert.That(result).IsEqualTo("2.0");
    }

    [Test]
    public async Task GetDatabaseSize_ReturnsPositiveValue()
    {
        var db = await CreateDatabaseAsync();

        // Insert some data to ensure the file has content
        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "size@example.com",
            FilePath = "/test/size.eml",
            Subject = "Size Test",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        var size = db.GetDatabaseSize();

        await Assert.That(size).IsGreaterThan(0);
    }

    [Test]
    public async Task IsHealthyAsync_OnGoodDatabase_ReturnsTrue()
    {
        var db = await CreateDatabaseAsync();

        var healthy = await db.IsHealthyAsync();

        await Assert.That(healthy).IsTrue();
    }

    [Test]
    public async Task GetEmailCountAsync_EmptyDatabase_ReturnsZero()
    {
        var db = await CreateDatabaseAsync();

        var count = await db.GetEmailCountAsync();

        await Assert.That(count).IsEqualTo(0);
    }

    [Test]
    public async Task GetEmailCountAsync_AfterInserts_ReturnsCorrectCount()
    {
        var db = await CreateDatabaseAsync();

        for (var i = 0; i < 5; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"count{i}@example.com",
                FilePath = $"/test/count{i}.eml",
                Subject = $"Count Test {i}",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        var count = await db.GetEmailCountAsync();

        await Assert.That(count).IsEqualTo(5);
    }

    [Test]
    public async Task GetKnownFilesAsync_ReturnsInsertedFiles()
    {
        var db = await CreateDatabaseAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "known@example.com",
            FilePath = "/test/known.eml",
            Subject = "Known File",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            LastModifiedTicks = 12345
        });

        var knownFiles = await db.GetKnownFilesAsync();

        knownFiles.Should().ContainKey("/test/known.eml");
        await Assert.That(knownFiles["/test/known.eml"]).IsEqualTo(12345);
    }

    [Test]
    public async Task UpsertEmailAsync_UpdatesExistingByFilePath()
    {
        var db = await CreateDatabaseAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "upsert@example.com",
            FilePath = "/test/upsert.eml",
            Subject = "Original Subject",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "upsert@example.com",
            FilePath = "/test/upsert.eml",
            Subject = "Updated Subject",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        var count = await db.GetEmailCountAsync();
        await Assert.That(count).IsEqualTo(1);

        // Verify the FTS index still works after the update
        var results = await db.QueryAsync(new SearchQuery { Subject = "Updated" });
        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task FtsTrigger_AfterUpdate_ReflectsNewContent()
    {
        var db = await CreateDatabaseAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "trigger@example.com",
            FilePath = "/test/trigger.eml",
            Subject = "Alpha",
            BodyText = "Original body text about apples",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        // Search for original content
        var beforeResults = await db.QueryAsync(new SearchQuery { ContentTerms = "apples" });
        await Assert.That(beforeResults.Count).IsEqualTo(1);

        // Update with new content
        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "trigger@example.com",
            FilePath = "/test/trigger.eml",
            Subject = "Beta",
            BodyText = "Updated body text about oranges",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        // Old content should no longer match
        var oldResults = await db.QueryAsync(new SearchQuery { ContentTerms = "apples" });
        await Assert.That(oldResults.Count).IsEqualTo(0);

        // New content should match
        var newResults = await db.QueryAsync(new SearchQuery { ContentTerms = "oranges" });
        await Assert.That(newResults.Count).IsEqualTo(1);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Data/SearchDatabaseTests.cs
SIZE: 6.24 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Data;

public class SearchDatabaseTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("search_db_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<SearchDatabase> CreateDatabaseAsync()
    {
        var dbPath = Path.Combine(_temp.Path, "search.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task InitializeAsync_CreatesDatabase()
    {
        await CreateDatabaseAsync();
        var dbPath = Path.Combine(_temp.Path, "search.db");
        await Assert.That(File.Exists(dbPath)).IsTrue();
    }

    [Test]
    public async Task UpsertEmailAsync_InsertsNewEmail()
    {
        var db = await CreateDatabaseAsync();
        var doc = CreateEmailDocument("test1@example.com");

        await db.UpsertEmailAsync(doc);
        var count = await db.GetEmailCountAsync();

        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task UpsertEmailAsync_UpdatesExistingEmail()
    {
        var db = await CreateDatabaseAsync();
        var doc1 = CreateEmailDocument("update@example.com", subject: "Original");
        var doc2 = CreateEmailDocument("update@example.com", subject: "Updated");

        await db.UpsertEmailAsync(doc1);
        await db.UpsertEmailAsync(doc2);
        var count = await db.GetEmailCountAsync();

        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_FindsByFullText()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("find1@example.com", subject: "Important Meeting"));
        await db.UpsertEmailAsync(CreateEmailDocument("find2@example.com", subject: "Casual Chat"));

        var results = await db.QueryAsync(new SearchQuery { ContentTerms = "important" });

        await Assert.That(results.Count).IsEqualTo(1);
        results[0].Subject.Should().Contain("Important");
    }

    [Test]
    public async Task SearchAsync_FiltersByFromAddress()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("from1@example.com", from: "alice@example.com"));
        await db.UpsertEmailAsync(CreateEmailDocument("from2@example.com", from: "bob@example.com"));

        var results = await db.QueryAsync(new SearchQuery { FromAddress = "alice@example.com" });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_FiltersByToAddress()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("to1@example.com", to: "recipient1@example.com"));
        await db.UpsertEmailAsync(CreateEmailDocument("to2@example.com", to: "recipient2@example.com"));

        var results = await db.QueryAsync(new SearchQuery { ToAddress = "recipient1@example.com" });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_FiltersByDateRange()
    {
        var db = await CreateDatabaseAsync();
        var jan = new DateTimeOffset(2024, 1, 15, 0, 0, 0, TimeSpan.Zero);
        var mar = new DateTimeOffset(2024, 3, 15, 0, 0, 0, TimeSpan.Zero);

        await db.UpsertEmailAsync(CreateEmailDocument("jan@example.com", date: jan));
        await db.UpsertEmailAsync(CreateEmailDocument("mar@example.com", date: mar));

        var results = await db.QueryAsync(new SearchQuery
        {
            DateFrom = new DateTimeOffset(2024, 2, 1, 0, 0, 0, TimeSpan.Zero),
            DateTo = new DateTimeOffset(2024, 4, 1, 0, 0, 0, TimeSpan.Zero)
        });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_CombinesMultipleFilters()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("combo1@example.com",
            from: "alice@example.com", subject: "Project Update"));
        await db.UpsertEmailAsync(CreateEmailDocument("combo2@example.com",
            from: "alice@example.com", subject: "Meeting Notes"));
        await db.UpsertEmailAsync(CreateEmailDocument("combo3@example.com",
            from: "bob@example.com", subject: "Project Update"));

        var results = await db.QueryAsync(new SearchQuery
        {
            FromAddress = "alice@example.com",
            ContentTerms = "project"
        });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task GetKnownFilesAsync_ReturnsAllFiles()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("file1@example.com", filePath: "/path/to/file1.eml"));
        await db.UpsertEmailAsync(CreateEmailDocument("file2@example.com", filePath: "/path/to/file2.eml"));

        var files = await db.GetKnownFilesAsync();

        await Assert.That(files.Count).IsEqualTo(2);
    }

    [Test]
    public async Task IsHealthyAsync_ReturnsTrue_ForValidDatabase()
    {
        var db = await CreateDatabaseAsync();
        var healthy = await db.IsHealthyAsync();
        await Assert.That(healthy).IsTrue();
    }

    private static EmailDocument CreateEmailDocument(
        string messageId,
        string? subject = null,
        string? from = null,
        string? to = null,
        string? filePath = null,
        DateTimeOffset? date = null)
    {
        return new EmailDocument
        {
            MessageId = messageId,
            FilePath = filePath ?? $"/test/{messageId}.eml",
            Subject = subject ?? "Test Subject",
            FromAddress = from ?? "sender@example.com",
            ToAddressesJson = to ?? "[\"recipient@example.com\"]",
            DateSentUnix = (date ?? DateTimeOffset.UtcNow).ToUnixTimeSeconds(),
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            LastModifiedTicks = DateTime.UtcNow.Ticks
        };
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Indexing/ArchiveScannerExtractionTests.cs
SIZE: 1.95 KB
MODIFIED: 2026-02-18 19:56:12
================================================================================

using MyEmailSearch.Indexing;

namespace MyEmailSearch.Tests.Indexing;

/// <summary>
/// Tests for ArchiveScanner's account/folder extraction from file paths.
/// </summary>
public class ArchiveScannerExtractionTests
{
    [Test]
    public async Task ExtractAccountName_StandardPath_ReturnsAccountFolder()
    {
        var archivePath = "/home/user/mail";
        var filePath = Path.Combine(archivePath, "work_account", "INBOX", "cur", "email.eml");

        var account = ArchiveScanner.ExtractAccountName(filePath, archivePath);

        await Assert.That(account).IsEqualTo("work_account");
    }

    [Test]
    public async Task ExtractAccountName_ShortPath_ReturnsNull()
    {
        var archivePath = "/home/user/mail";
        var filePath = Path.Combine(archivePath, "email.eml");

        var account = ArchiveScanner.ExtractAccountName(filePath, archivePath);

        await Assert.That(account).IsNull();
    }

    [Test]
    public async Task ExtractFolderName_StandardPath_ReturnsFolderName()
    {
        var archivePath = "/home/user/mail";
        var filePath = Path.Combine(archivePath, "account", "INBOX", "cur", "email.eml");

        var folder = ArchiveScanner.ExtractFolderName(filePath, archivePath);

        await Assert.That(folder).IsEqualTo("INBOX");
    }

    [Test]
    public async Task ExtractFolderName_ShortPath_ReturnsNull()
    {
        var archivePath = "/home/user/mail";
        var filePath = Path.Combine(archivePath, "account", "email.eml");

        var folder = ArchiveScanner.ExtractFolderName(filePath, archivePath);

        await Assert.That(folder).IsNull();
    }

    [Test]
    public async Task ExtractAccountName_SentFolder_ReturnsAccount()
    {
        var archivePath = "/home/user/mail";
        var filePath = Path.Combine(archivePath, "personal", "Sent", "cur", "msg.eml");

        var account = ArchiveScanner.ExtractAccountName(filePath, archivePath);

        await Assert.That(account).IsEqualTo("personal");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Indexing/ArchiveScannerTests.cs
SIZE: 2.56 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Indexing;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

public class ArchiveScannerTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("scanner_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    [Test]
    public async Task ScanForEmails_FindsEmlFiles()
    {
        // Create test .eml files
        var curDir = Path.Combine(_temp.Path, "INBOX", "cur");
        Directory.CreateDirectory(curDir);
        await File.WriteAllTextAsync(Path.Combine(curDir, "test1.eml"), "Content 1");
        await File.WriteAllTextAsync(Path.Combine(curDir, "test2.eml"), "Content 2");

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(2);
    }

    [Test]
    public async Task ScanForEmails_RecursivelySearchesSubfolders()
    {
        var inbox = Path.Combine(_temp.Path, "INBOX", "cur");
        var sent = Path.Combine(_temp.Path, "Sent", "cur");
        Directory.CreateDirectory(inbox);
        Directory.CreateDirectory(sent);
        await File.WriteAllTextAsync(Path.Combine(inbox, "inbox.eml"), "Inbox");
        await File.WriteAllTextAsync(Path.Combine(sent, "sent.eml"), "Sent");

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(2);
    }

    [Test]
    public async Task ScanForEmails_IgnoresNonEmlFiles()
    {
        var curDir = Path.Combine(_temp.Path, "INBOX", "cur");
        Directory.CreateDirectory(curDir);
        await File.WriteAllTextAsync(Path.Combine(curDir, "test.eml"), "Email");
        await File.WriteAllTextAsync(Path.Combine(curDir, "test.meta.json"), "Metadata");
        await File.WriteAllTextAsync(Path.Combine(curDir, "test.txt"), "Text");

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(1);
        await Assert.That(files[0]).EndsWith(".eml");
    }

    [Test]
    public async Task ScanForEmails_ReturnsEmptyForEmptyDirectory()
    {
        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(0);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Indexing/EmailParserEdgeCaseTests.cs
SIZE: 7.66 KB
MODIFIED: 2026-02-18 19:56:12
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Indexing;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

/// <summary>
/// Tests for EmailParser edge cases: multipart, HTML-only, attachments, malformed.
/// </summary>
public class EmailParserEdgeCaseTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("parser_edge_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<string> CreateEmlFileAsync(string content)
    {
        var path = Path.Combine(_temp.Path, $"{Guid.NewGuid()}.eml");
        await File.WriteAllTextAsync(path, content);
        return path;
    }

    [Test]
    public async Task ParseAsync_MultipartAlternative_ExtractsPlainText()
    {
        var emlContent = "Message-ID: <multi@example.com>\r\n" +
            "Subject: Multipart Test\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "MIME-Version: 1.0\r\n" +
            "Content-Type: multipart/alternative; boundary=\"boundary123\"\r\n" +
            "\r\n" +
            "--boundary123\r\n" +
            "Content-Type: text/plain; charset=utf-8\r\n" +
            "\r\n" +
            "This is the plain text version.\r\n" +
            "--boundary123\r\n" +
            "Content-Type: text/html; charset=utf-8\r\n" +
            "\r\n" +
            "<html><body><p>This is HTML</p></body></html>\r\n" +
            "--boundary123--\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: true);

        doc.Should().NotBeNull();
        doc!.BodyText.Should().Contain("plain text version");
    }

    [Test]
    public async Task ParseAsync_HtmlOnlyEmail_ExtractsText()
    {
        var emlContent = "Message-ID: <html@example.com>\r\n" +
            "Subject: HTML Only\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "Content-Type: text/html; charset=utf-8\r\n" +
            "\r\n" +
            "<html><body><p>HTML only content here</p></body></html>\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: true);

        doc.Should().NotBeNull();
        // Should get something from the HTML even if it's the raw HTML
        doc!.BodyText.Should().NotBeNullOrEmpty();
    }

    [Test]
    public async Task ParseAsync_EmailWithAttachment_SetsHasAttachments()
    {
        var emlContent = "Message-ID: <attach@example.com>\r\n" +
            "Subject: Attachment Test\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "MIME-Version: 1.0\r\n" +
            "Content-Type: multipart/mixed; boundary=\"mixedboundary\"\r\n" +
            "\r\n" +
            "--mixedboundary\r\n" +
            "Content-Type: text/plain\r\n" +
            "\r\n" +
            "See attached.\r\n" +
            "--mixedboundary\r\n" +
            "Content-Type: application/pdf; name=\"report.pdf\"\r\n" +
            "Content-Disposition: attachment; filename=\"report.pdf\"\r\n" +
            "Content-Transfer-Encoding: base64\r\n" +
            "\r\n" +
            "JVBERi0xLjQKMSAwIG9iago=\r\n" +
            "--mixedboundary--\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc.Should().NotBeNull();
        await Assert.That(doc!.HasAttachments).IsTrue();
        doc.AttachmentNamesJson.Should().Contain("report.pdf");
    }

    [Test]
    public async Task ParseAsync_MissingMessageId_StillParses()
    {
        var emlContent = "Subject: No Message ID\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "Content-Type: text/plain\r\n" +
            "\r\n" +
            "Body content\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        // Should still parse, possibly with null or generated message ID
        doc.Should().NotBeNull();
    }

    [Test]
    public async Task ParseAsync_EmptyFile_ReturnsNull()
    {
        var path = await CreateEmlFileAsync("");
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc).IsNull();
    }

    [Test]
    public async Task ParseAsync_MultipleRecipients_ExtractsAll()
    {
        var emlContent = "Message-ID: <multi-to@example.com>\r\n" +
            "Subject: Multiple Recipients\r\n" +
            "From: sender@example.com\r\n" +
            "To: alice@example.com, bob@example.com\r\n" +
            "Cc: charlie@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "Content-Type: text/plain\r\n" +
            "\r\n" +
            "Group email\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc.Should().NotBeNull();
        doc!.ToAddressesJson.Should().Contain("alice@example.com");
        doc.ToAddressesJson.Should().Contain("bob@example.com");
        doc.CcAddressesJson.Should().Contain("charlie@example.com");
    }

    [Test]
    public async Task ParseAsync_IncludeFullBody_False_LimitsBodyLength()
    {
        var longBody = new string('A', 2000);
        var emlContent = "Message-ID: <preview@example.com>\r\n" +
            "Subject: Long Body\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "Content-Type: text/plain\r\n" +
            "\r\n" +
            longBody + "\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc.Should().NotBeNull();
        // Body preview should be truncated (500 chars per BodyPreviewLength constant)
        doc!.BodyPreview.Should().NotBeNull();
        await Assert.That(doc.BodyPreview!.Length).IsLessThanOrEqualTo(510);
    }

    [Test]
    public async Task ParseAsync_SetsLastModifiedTicks()
    {
        var emlContent = "Message-ID: <ticks@example.com>\r\n" +
            "Subject: Ticks Test\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "Content-Type: text/plain\r\n" +
            "\r\n" +
            "Body\r\n";

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc!.LastModifiedTicks).IsGreaterThan(0);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Indexing/EmailParserTests.cs
SIZE: 4.29 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Indexing;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

public class EmailParserTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("parser_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<string> CreateEmlFileAsync(string content)
    {
        var path = Path.Combine(_temp.Path, $"{Guid.NewGuid()}.eml");
        await File.WriteAllTextAsync(path, content);
        return path;
    }

    [Test]
    public async Task ParseAsync_ExtractsMessageId()
    {
        var emlContent = """
            Message-ID: <test123@example.com>
            Subject: Test
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Hello world
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc.Should().NotBeNull();
        await Assert.That(doc!.MessageId).IsEqualTo("test123@example.com");
    }

    [Test]
    public async Task ParseAsync_ExtractsSubject()
    {
        var emlContent = """
            Message-ID: <subject@example.com>
            Subject: Important Meeting Tomorrow
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Body
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc!.Subject).IsEqualTo("Important Meeting Tomorrow");
    }

    [Test]
    public async Task ParseAsync_ExtractsFromAddress()
    {
        var emlContent = """
            Message-ID: <from@example.com>
            Subject: Test
            From: Alice Smith <alice@example.com>
            To: bob@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Body
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc!.FromAddress.Should().Contain("alice@example.com");
    }

    [Test]
    public async Task ParseAsync_ExtractsBodyText_WhenRequested()
    {
        var emlContent = """
            Message-ID: <body@example.com>
            Subject: Test
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            This is the email body content.
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: true);

        doc!.BodyText.Should().Contain("email body content");
    }

    [Test]
    public async Task ParseAsync_SetsIndexedAtUnix()
    {
        var emlContent = """
            Message-ID: <indexed@example.com>
            Subject: Test
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Body
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc!.IndexedAtUnix).IsGreaterThan(0);
    }

    [Test]
    public async Task ParseAsync_ReturnsNullForInvalidFile()
    {
        var path = Path.Combine(_temp.Path, "nonexistent.eml");
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc).IsNull();
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Indexing/IndexManagerCancellationTests.cs
SIZE: 3.36 KB
MODIFIED: 2026-02-18 20:00:41
================================================================================

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

/// <summary>
/// Tests for IndexManager cancellation and progress reporting.
/// </summary>
public class IndexManagerCancellationTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("index_cancel_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task CreateEmlFileAsync(string folder, string messageId)
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dir = Path.Combine(archivePath, folder, "cur");
        Directory.CreateDirectory(dir);

        var content = $"Message-ID: <{messageId}>\r\n" +
            $"Subject: Test {messageId}\r\n" +
            "From: sender@example.com\r\n" +
            "To: recipient@example.com\r\n" +
            "Date: Mon, 01 Jan 2024 12:00:00 +0000\r\n" +
            "Content-Type: text/plain\r\n" +
            "\r\n" +
            "Body\r\n";

        await File.WriteAllTextAsync(Path.Combine(dir, $"{messageId}.eml"), content);
    }

    [Test]
    public async Task IndexAsync_CancellationToken_StopsProcessing()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");

        for (var i = 0; i < 20; i++)
        {
            await CreateEmlFileAsync("INBOX", $"cancel{i}@example.com");
        }

        var dbPath = Path.Combine(_temp.Path, "search.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        using var cts = new CancellationTokenSource();
        cts.Cancel();

        var act = async () => await manager.IndexAsync(archivePath, includeContent: false, ct: cts.Token);

        await Assert.ThrowsAsync<OperationCanceledException>(act);
    }

    [Test]
    public async Task IndexAsync_ReportsProgress()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        await CreateEmlFileAsync("INBOX", "progress1@example.com");
        await CreateEmlFileAsync("INBOX", "progress2@example.com");

        var dbPath = Path.Combine(_temp.Path, "search.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        var progressReports = new List<IndexingProgress>();
        var progress = new Progress<IndexingProgress>(p => progressReports.Add(p));

        await manager.IndexAsync(archivePath, includeContent: false, progress: progress);

        await Task.Delay(200);

        await Assert.That(progressReports.Count).IsGreaterThanOrEqualTo(1);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Indexing/IndexManagerTests.cs
SIZE: 4.11 KB
MODIFIED: 2026-01-21 19:44:14
================================================================================

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;
using MyEmailSearch.Indexing;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

public class IndexManagerTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("index_mgr_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<string> CreateEmlFileAsync(string folder, string messageId, string subject)
    {
        var curDir = Path.Combine(_temp.Path, "archive", folder, "cur");
        Directory.CreateDirectory(curDir);

        var content = $"""
            Message-ID: <{messageId}>
            Subject: {subject}
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Email body for {subject}
            """;

        var path = Path.Combine(curDir, $"{messageId.Replace("@", "_")}.eml");
        await File.WriteAllTextAsync(path, content);
        return path;
    }

    [Test]
    public async Task IndexAsync_IndexesNewEmails()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dbPath = Path.Combine(_temp.Path, "search.db");

        await CreateEmlFileAsync("INBOX", "test1@example.com", "First Email");
        await CreateEmlFileAsync("INBOX", "test2@example.com", "Second Email");

        var db = await CreateSearchDatabase(dbPath);

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        var result = await manager.IndexAsync(archivePath, includeContent: true);

        await Assert.That(result.Indexed).IsEqualTo(2);
        await Assert.That(result.Errors).IsEqualTo(0);
    }

    [Test]
    public async Task IndexAsync_SkipsAlreadyIndexedFiles()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dbPath = Path.Combine(_temp.Path, "search.db");

        await CreateEmlFileAsync("INBOX", "existing@example.com", "Existing Email");

        var db = await CreateSearchDatabase(dbPath);

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        // Index twice
        var result1 = await manager.IndexAsync(archivePath, includeContent: true);
        var result2 = await manager.IndexAsync(archivePath, includeContent: true);

        await Assert.That(result1.Indexed).IsEqualTo(1);
        await Assert.That(result2.Indexed).IsEqualTo(0);
        await Assert.That(result2.Skipped).IsEqualTo(1);
    }

    private async Task<SearchDatabase> CreateSearchDatabase(string dbPath)
    {
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task RebuildIndexAsync_ReindexesAllEmails()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dbPath = Path.Combine(_temp.Path, "search.db");

        await CreateEmlFileAsync("INBOX", "rebuild@example.com", "Rebuild Test");

        var db = await CreateSearchDatabase(dbPath);

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        // Index first
        await manager.IndexAsync(archivePath, includeContent: true);

        // Rebuild
        var result = await manager.RebuildIndexAsync(archivePath, includeContent: true);

        await Assert.That(result.Indexed).IsEqualTo(1);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/MyEmailSearch.Tests.csproj
SIZE: 0.89 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="AwesomeAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyEmailSearch\MyEmailSearch.csproj" />
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Update="TestFixtures\SampleEmails\**\*">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: MyEmailSearch.Tests/Search/QueryParserEdgeCaseTests.cs
SIZE: 3.60 KB
MODIFIED: 2026-02-18 20:00:58
================================================================================

using AwesomeAssertions;

using MyEmailSearch.Data;
using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

/// <summary>
/// Tests for QueryParser edge cases and combined filter scenarios.
/// </summary>
public class QueryParserEdgeCaseTests
{
    private readonly QueryParser _parser = new();

    [Test]
    public async Task Parse_CombinedFilters_ExtractsAllFields()
    {
        var result = _parser.Parse("from:alice@example.com subject:meeting quarterly report");

        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(result.Subject).IsEqualTo("meeting");
        result.ContentTerms.Should().Contain("quarterly");
        result.ContentTerms.Should().Contain("report");
    }

    [Test]
    public async Task Parse_AccountFilter_SetsAccount()
    {
        var result = _parser.Parse("account:work");

        await Assert.That(result.Account).IsEqualTo("work");
    }

    [Test]
    public async Task Parse_FolderFilter_SetsFolder()
    {
        var result = _parser.Parse("folder:INBOX");

        await Assert.That(result.Folder).IsEqualTo("INBOX");
    }

    [Test]
    public async Task Parse_AllFiltersAtOnce_ExtractsEverything()
    {
        var query = "from:alice@x.com to:bob@x.com subject:hello account:work folder:Sent after:2024-01-01 before:2024-12-31 free text";
        var result = _parser.Parse(query);

        await Assert.That(result.FromAddress).IsEqualTo("alice@x.com");
        await Assert.That(result.ToAddress).IsEqualTo("bob@x.com");
        await Assert.That(result.Subject).IsEqualTo("hello");
        await Assert.That(result.Account).IsEqualTo("work");
        await Assert.That(result.Folder).IsEqualTo("Sent");
        await Assert.That(result.DateFrom).IsNotNull();
        await Assert.That(result.DateTo).IsNotNull();
        result.ContentTerms.Should().Contain("free text");
    }

    [Test]
    public async Task Parse_EmptyString_ReturnsEmptyQuery()
    {
        var result = _parser.Parse("");

        await Assert.That(result.FromAddress).IsNull();
        await Assert.That(result.ToAddress).IsNull();
        await Assert.That(result.Subject).IsNull();
        await Assert.That(result.ContentTerms).IsNull();
    }

    [Test]
    public async Task Parse_WhitespaceOnly_ReturnsEmptyQuery()
    {
        var result = _parser.Parse("   ");

        await Assert.That(result.ContentTerms).IsNull();
    }

    [Test]
    public async Task Parse_QuotedFromAddress_PreservesQuotedValue()
    {
        var result = _parser.Parse("from:\"alice smith@example.com\"");

        await Assert.That(result.FromAddress).IsEqualTo("alice smith@example.com");
    }

    [Test]
    public async Task Parse_SingleDateWithoutRange_SetsDateFrom()
    {
        var result = _parser.Parse("date:2024-06-15");

        await Assert.That(result.DateFrom).IsNotNull();
        await Assert.That(result.DateFrom!.Value.Year).IsEqualTo(2024);
        await Assert.That(result.DateFrom!.Value.Month).IsEqualTo(6);
        await Assert.That(result.DateFrom!.Value.Day).IsEqualTo(15);
    }

    [Test]
    public async Task Parse_DefaultPagination_HasCorrectValues()
    {
        var result = _parser.Parse("test");

        await Assert.That(result.Skip).IsEqualTo(0);
        await Assert.That(result.Take).IsEqualTo(100);
        await Assert.That(result.SortOrder).IsEqualTo(SearchSortOrder.DateDescending);
    }

    [Test]
    public async Task Parse_InvalidDate_IgnoresDateFilter()
    {
        var result = _parser.Parse("after:not-a-date some text");

        await Assert.That(result.DateFrom).IsNull();
        result.ContentTerms.Should().Contain("some text");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/QueryParserTests.cs
SIZE: 3.55 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

public class QueryParserTests
{
    private readonly QueryParser _parser = new();

    [Test]
    public async Task Parse_SimpleText_SetsContentTerms()
    {
        var result = _parser.Parse("hello world");

        await Assert.That(result.ContentTerms).IsEqualTo("hello world");
    }

    [Test]
    public async Task Parse_FromFilter_SetsFromAddress()
    {
        var result = _parser.Parse("from:alice@example.com");

        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
    }

    [Test]
    public async Task Parse_ToFilter_SetsToAddress()
    {
        var result = _parser.Parse("to:bob@example.com");

        await Assert.That(result.ToAddress).IsEqualTo("bob@example.com");
    }

    [Test]
    public async Task Parse_SubjectFilter_SetsSubject()
    {
        var result = _parser.Parse("subject:meeting");

        await Assert.That(result.Subject).IsEqualTo("meeting");
    }

    [Test]
    public async Task Parse_QuotedSubject_PreservesSpaces()
    {
        var result = _parser.Parse("subject:\"project update\"");

        await Assert.That(result.Subject).IsEqualTo("project update");
    }

    [Test]
    public async Task Parse_DateRange_SetsDateFromAndTo()
    {
        var result = _parser.Parse("date:2024-01-01..2024-12-31");

        await Assert.That(result.DateFrom?.Year).IsEqualTo(2024);
        await Assert.That(result.DateFrom?.Month).IsEqualTo(1);
        await Assert.That(result.DateTo?.Year).IsEqualTo(2024);
        await Assert.That(result.DateTo?.Month).IsEqualTo(12);
    }

    [Test]
    public async Task Parse_AfterDate_SetsDateFrom()
    {
        var result = _parser.Parse("after:2024-06-01");

        await Assert.That(result.DateFrom?.Year).IsEqualTo(2024);
        await Assert.That(result.DateFrom?.Month).IsEqualTo(6);
    }

    [Test]
    public async Task Parse_BeforeDate_SetsDateTo()
    {
        var result = _parser.Parse("before:2024-06-30");

        await Assert.That(result.DateTo?.Year).IsEqualTo(2024);
        await Assert.That(result.DateTo?.Month).IsEqualTo(6);
    }

    [Test]
    public async Task Parse_FolderFilter_SetsFolder()
    {
        var result = _parser.Parse("folder:INBOX");

        await Assert.That(result.Folder).IsEqualTo("INBOX");
    }

    [Test]
    public async Task Parse_AccountFilter_SetsAccount()
    {
        var result = _parser.Parse("account:user@example.com");

        await Assert.That(result.Account).IsEqualTo("user@example.com");
    }

    [Test]
    public async Task Parse_CombinedFilters_SetsAllFields()
    {
        var result = _parser.Parse("from:alice@example.com to:bob@example.com subject:meeting kafka");

        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(result.ToAddress).IsEqualTo("bob@example.com");
        await Assert.That(result.Subject).IsEqualTo("meeting");
        result.ContentTerms.Should().Contain("kafka");
    }

    [Test]
    public async Task Parse_EmptyQuery_ReturnsEmptySearchQuery()
    {
        var result = _parser.Parse("");

        await Assert.That(result.FromAddress).IsNull();
        await Assert.That(result.ToAddress).IsNull();
        await Assert.That(result.ContentTerms).IsNull();
    }

    [Test]
    public async Task Parse_CaseInsensitiveFilters_Works()
    {
        var result = _parser.Parse("FROM:alice@example.com SUBJECT:test");

        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(result.Subject).IsEqualTo("test");
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/SearchEngineCountTests.cs
SIZE: 4.90 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;
using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

/// <summary>
/// Tests for SearchEngine total count behavior.
/// </summary>
public class SearchEngineCountTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private SearchDatabase? _database;

    public SearchEngineCountTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"engine_count_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private async Task<(SearchDatabase db, SearchEngine engine)> CreateServicesAsync()
    {
        var dbPath = Path.Combine(_testDirectory, "test.db");
        var dbLogger = new NullLogger<SearchDatabase>();
        var db = new SearchDatabase(dbPath, dbLogger);
        await db.InitializeAsync();
        _database = db;

        var queryParser = new QueryParser();
        var snippetGenerator = new SnippetGenerator();
        var engineLogger = new NullLogger<SearchEngine>();
        var engine = new SearchEngine(db, queryParser, snippetGenerator, engineLogger);

        return (db, engine);
    }

    [Test]
    public async Task SearchAsync_WithLimit_ReturnsTotalCountOfAllMatches()
    {
        // Arrange
        var (db, engine) = await CreateServicesAsync();

        // Insert 150 emails to "recipient@tilde.team"
        for (var i = 0; i < 150; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"test{i}@example.com",
                FilePath = $"/test/email{i}.eml",
                Subject = $"Test Email {i}",
                FromAddress = "sender@example.com",
                ToAddressesJson = "[\"recipient@tilde.team\"]",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        // Act
        var results = await engine.SearchAsync("to:recipient@tilde.team", limit: 100, offset: 0);

        // Assert
        results.Results.Should().HaveCount(100);  // Limited to 100
        results.TotalCount.Should().Be(150);       // But total is 150
        results.HasMore.Should().BeTrue();         // Indicates more results exist
    }

    [Test]
    public async Task SearchAsync_WhenAllResultsFitInLimit_TotalCountMatchesResultsCount()
    {
        // Arrange
        var (db, engine) = await CreateServicesAsync();

        // Insert 50 emails
        for (var i = 0; i < 50; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"test{i}@example.com",
                FilePath = $"/test/email{i}.eml",
                Subject = $"Test Email {i}",
                FromAddress = "sender@example.com",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        // Act
        var results = await engine.SearchAsync("from:sender@example.com", limit: 100, offset: 0);

        // Assert
        results.Results.Should().HaveCount(50);   // All 50 returned
        results.TotalCount.Should().Be(50);        // Total matches results
        results.HasMore.Should().BeFalse();        // No more results
    }

    [Test]
    public async Task SearchAsync_WithPagination_TotalCountRemainsConsistent()
    {
        // Arrange
        var (db, engine) = await CreateServicesAsync();

        // Insert 100 emails
        for (var i = 0; i < 100; i++)
        {
            await db.UpsertEmailAsync(new EmailDocument
            {
                MessageId = $"test{i}@example.com",
                FilePath = $"/test/email{i}.eml",
                Subject = $"Test Email {i}",
                FromAddress = "alice@example.com",
                IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
            });
        }

        // Act - Get first page
        var page1 = await engine.SearchAsync("from:alice@example.com", limit: 20, offset: 0);
        // Act - Get second page
        var page2 = await engine.SearchAsync("from:alice@example.com", limit: 20, offset: 20);
        // Act - Get third page
        var page3 = await engine.SearchAsync("from:alice@example.com", limit: 20, offset: 40);

        // Assert - Total count should be consistent across pages
        page1.TotalCount.Should().Be(100);
        page2.TotalCount.Should().Be(100);
        page3.TotalCount.Should().Be(100);

        // Results should be paginated correctly
        page1.Results.Should().HaveCount(20);
        page2.Results.Should().HaveCount(20);
        page3.Results.Should().HaveCount(20);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/SearchEngineEdgeCaseTests.cs
SIZE: 3.41 KB
MODIFIED: 2026-02-18 19:56:12
================================================================================

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;
using MyEmailSearch.Search;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Search;

/// <summary>
/// Edge case tests for SearchEngine: sort order, large offset, empty results.
/// </summary>
public class SearchEngineEdgeCaseTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("engine_edge_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<(SearchDatabase db, SearchEngine engine)> CreateServicesAsync()
    {
        var dbPath = Path.Combine(_temp.Path, "test.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var engine = new SearchEngine(db, new QueryParser(), new SnippetGenerator(),
            NullLogger<SearchEngine>.Instance);
        return (db, engine);
    }

    [Test]
    public async Task SearchAsync_OffsetBeyondResults_ReturnsEmpty()
    {
        var (db, engine) = await CreateServicesAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "only@example.com",
            FilePath = "/test/only.eml",
            Subject = "Only Result",
            FromAddress = "sender@example.com",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        var results = await engine.SearchAsync("only", limit: 10, offset: 100);

        await Assert.That(results.Results.Count).IsEqualTo(0);
        await Assert.That(results.TotalCount).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_NoMatchingResults_ReturnsTotalCountZero()
    {
        var (db, engine) = await CreateServicesAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "existing@example.com",
            FilePath = "/test/existing.eml",
            Subject = "Existing Email",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        var results = await engine.SearchAsync("nonexistentquerythatmatchesnothing");

        await Assert.That(results.TotalCount).IsEqualTo(0);
        await Assert.That(results.Results.Count).IsEqualTo(0);
        await Assert.That(results.HasMore).IsFalse();
    }

    [Test]
    public async Task SearchAsync_WithSnippets_GeneratesSnippetsForContentSearch()
    {
        var (db, engine) = await CreateServicesAsync();

        await db.UpsertEmailAsync(new EmailDocument
        {
            MessageId = "snippet@example.com",
            FilePath = "/test/snippet.eml",
            Subject = "Snippet Test",
            BodyText = "This email contains a very specific keyword called xylophone in the body.",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        });

        var results = await engine.SearchAsync("xylophone");

        await Assert.That(results.Results.Count).IsEqualTo(1);
        // Snippet should be generated for content-based searches
    }

    [Test]
    public async Task SearchAsync_NullQuery_ReturnsEmpty()
    {
        var (_, engine) = await CreateServicesAsync();

        var results = await engine.SearchAsync((string)null!);

        await Assert.That(results.TotalCount).IsEqualTo(0);
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/SearchEngineTests.cs
SIZE: 3.19 KB
MODIFIED: 2026-01-21 19:42:29
================================================================================

using Microsoft.Extensions.Logging.Abstractions;

using MyEmailSearch.Data;
using MyEmailSearch.Search;

using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Search;

public class SearchEngineTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("search_engine_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<(SearchDatabase db, SearchEngine engine)> CreateServicesAsync()
    {
        var dbPath = Path.Combine(_temp.Path, "test.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var queryParser = new QueryParser();
        var snippetGenerator = new SnippetGenerator();
        var engine = new SearchEngine(db, queryParser, snippetGenerator,
            NullLogger<SearchEngine>.Instance);

        return (db, engine);
    }

    [Test]
    public async Task SearchAsync_ReturnsResults()
    {
        var (db, engine) = await CreateServicesAsync();
        await db.UpsertEmailAsync(CreateDocument("search@example.com", "Test Subject"));

        var results = await engine.SearchAsync("test");

        await Assert.That(results.TotalCount).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_AppliesPagination()
    {
        var (db, engine) = await CreateServicesAsync();
        for (int i = 0; i < 15; i++)
        {
            await db.UpsertEmailAsync(CreateDocument($"page{i}@example.com", $"Page Test {i}"));
        }

        var results = await engine.SearchAsync("page", limit: 5, offset: 0);

        await Assert.That(results.Results.Count).IsEqualTo(5);
        await Assert.That(results.TotalCount).IsEqualTo(15);
        await Assert.That(results.HasMore).IsTrue();
    }

    [Test]
    public async Task SearchAsync_EmptyQuery_ReturnsEmptyResults()
    {
        var (db, engine) = await CreateServicesAsync();
        await db.UpsertEmailAsync(CreateDocument("empty@example.com", "Subject"));

        var results = await engine.SearchAsync("");

        await Assert.That(results.TotalCount).IsEqualTo(0);
    }

    [Test]
    public async Task SearchAsync_ReturnsQueryTime()
    {
        var (db, engine) = await CreateServicesAsync();
        await db.UpsertEmailAsync(CreateDocument("time@example.com", "Subject"));

        var results = await engine.SearchAsync("subject");

        await Assert.That(results.QueryTime.TotalMilliseconds).IsGreaterThanOrEqualTo(0);
    }

    private static EmailDocument CreateDocument(string messageId, string subject)
    {
        return new EmailDocument
        {
            MessageId = messageId,
            FilePath = $"/test/{messageId}.eml",
            Subject = subject,
            FromAddress = "sender@example.com",
            ToAddressesJson = "[\"recipient@example.com\"]",
            DateSentUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            LastModifiedTicks = DateTime.UtcNow.Ticks
        };
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/SnippetGeneratorEdgeCaseTests.cs
SIZE: 1.82 KB
MODIFIED: 2026-02-18 19:56:12
================================================================================

using AwesomeAssertions;

using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

/// <summary>
/// Edge case tests for SnippetGenerator.
/// </summary>
public class SnippetGeneratorEdgeCaseTests
{
    [Test]
    public async Task Generate_TermAtStartOfText_ReturnsSnippet()
    {
        var text = "Important meeting scheduled for next Monday at 3pm.";
        var snippet = SnippetGenerator.Generate(text, "important");

        snippet.Should().NotBeNullOrEmpty();
    }

    [Test]
    public async Task Generate_TermAtEndOfText_ReturnsSnippet()
    {
        var text = "Please review the attached document which is very important";
        var snippet = SnippetGenerator.Generate(text, "important");

        snippet.Should().NotBeNullOrEmpty();
    }

    [Test]
    public async Task Generate_CaseInsensitiveMatch_FindsTerm()
    {
        var text = "The CRITICAL update was applied successfully.";
        var snippet = SnippetGenerator.Generate(text, "critical");

        snippet.Should().NotBeNullOrEmpty();
    }

    [Test]
    public async Task Generate_VeryShortText_ReturnsEntireText()
    {
        var text = "Hi";
        var snippet = SnippetGenerator.Generate(text, "hi");

        snippet.Should().NotBeNullOrEmpty();
    }

    [Test]
    public async Task Generate_NoMatchingTerm_ReturnsTextPrefix()
    {
        var text = "This email is about project planning and scheduling.";
        var snippet = SnippetGenerator.Generate(text, "nonexistentword");

        // Should return something (beginning of text) even without a match
        snippet.Should().NotBeNull();
    }

    [Test]
    public async Task Generate_NullTerms_ReturnsTextPrefix()
    {
        var text = "Some email content here.";
        var snippet = SnippetGenerator.Generate(text, null!);

        await Assert.That(snippet).IsNotNull();
    }
}


================================================================================
FILE: MyEmailSearch.Tests/Search/SnippetGeneratorTests.cs
SIZE: 1.45 KB
MODIFIED: 2026-01-23 07:37:28
================================================================================

using AwesomeAssertions;

using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

public class SnippetGeneratorTests
{
    private readonly SnippetGenerator _generator = new();

    [Test]
    public void Generate_FindsMatchingTerm()
    {
        const string text = "This is a test document with some important content.";
        var snippet = SnippetGenerator.Generate(text, "important");

        snippet.Should().Contain("important");
    }

    [Test]
    public async Task Generate_ReturnsEmptyForNullText()
    {
        var snippet = SnippetGenerator.Generate(null, "test");

        await Assert.That(snippet).IsNull();
    }

    [Test]
    public async Task Generate_ReturnsEmptyForNoTerms()
    {
        var text = "Some text here";
        var snippet = SnippetGenerator.Generate(text, "");

        await Assert.That(snippet).IsNotNull();
    }

    [Test]
    public async Task Generate_TruncatesLongText()
    {
        var text = new string('a', 1000) + " important " + new string('b', 1000);
        var snippet = SnippetGenerator.Generate(text, "important");

        snippet.Should().NotBeNullOrWhiteSpace();
        await Assert.That(snippet.Length).IsLessThanOrEqualTo(210); // Allow some margin
    }

    [Test]
    public void Generate_HandlesMultipleTerms()
    {
        var text = "The quick brown fox jumps over the lazy dog.";
        var snippet = SnippetGenerator.Generate(text, "quick lazy");

        snippet.Should().NotBeEmpty();
    }
}


================================================================================
FILE: MyEmailSearch.Tests/SmokeTests.cs
SIZE: 1.69 KB
MODIFIED: 2026-01-25 12:18:39
================================================================================

using MyEmailSearch.Data;
using MyEmailSearch.Search;

namespace MyEmailSearch.Tests;

/// <summary>
/// Basic smoke tests to verify core types compile and are accessible.
/// </summary>
public class SmokeTests
{
    [Test]
    public async Task CoreTypes_AreAccessible()
    {
        // Verify core types can be instantiated
        var parser = new QueryParser();
        var generator = new SnippetGenerator();

        await Assert.That(parser).IsNotNull();
        await Assert.That(generator).IsNotNull();
    }

    [Test]
    public async Task QueryParser_CanBeInstantiated()
    {
        var parser = new QueryParser();
        await Assert.That(parser).IsNotNull();
    }

    [Test]
    public async Task SnippetGenerator_CanBeInstantiated()
    {
        var generator = new SnippetGenerator();
        await Assert.That(generator).IsNotNull();
    }

    [Test]
    public async Task SearchQuery_HasDefaultValues()
    {
        var query = new SearchQuery();
        await Assert.That(query.Take).IsEqualTo(100);
        await Assert.That(query.Skip).IsEqualTo(0);
    }

    [Test]
    public async Task EmailDocument_CanBeCreated()
    {
        var doc = new EmailDocument
        {
            MessageId = "test@example.com",
            FilePath = "/test/path.eml",
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds()
        };

        await Assert.That(doc.MessageId).IsEqualTo("test@example.com");
    }

    [Test]
    public async Task QueryParser_Parse_ReturnsSearchQuery()
    {
        var parser = new QueryParser();
        var query = parser.Parse("test");
        await Assert.That(query).IsNotNull();
        await Assert.That(query.ContentTerms).IsEqualTo("test");
    }
}


================================================================================
FILE: MyImapDownloader/appsettings.json
SIZE: 0.43 KB
MODIFIED: 2025-12-18 18:29:53
================================================================================

{
  "Telemetry": {
    "ServiceName": "MyImapDownloader",
    "ServiceVersion": "1.0.0",
    "OutputDirectory": "telemetry",
    "MaxFileSizeMB": 25,
    "EnableTracing": true,
    "EnableMetrics": true,
    "EnableLogging": true,
    "FlushIntervalSeconds": 5,
    "MetricsExportIntervalSeconds": 15
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}


================================================================================
FILE: MyImapDownloader.Core/Configuration/PathResolver.cs
SIZE: 3.34 KB
MODIFIED: 2026-01-21 19:23:31
================================================================================

namespace MyImapDownloader.Core.Configuration;

/// <summary>
/// Resolves paths following XDG Base Directory Specification.
/// Provides consistent cross-platform path resolution for all applications.
/// </summary>
public static class PathResolver
{
    /// <summary>
    /// Gets the XDG data home directory.
    /// </summary>
    public static string GetDataHome(string appName)
    {
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrWhiteSpace(xdgDataHome))
        {
            return Path.Combine(xdgDataHome, appName.ToLowerInvariant());
        }

        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        if (OperatingSystem.IsWindows())
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                appName);
        }

        return Path.Combine(home, ".local", "share", appName.ToLowerInvariant());
    }

    /// <summary>
    /// Gets the XDG config home directory.
    /// </summary>
    public static string GetConfigHome(string appName)
    {
        var xdgConfigHome = Environment.GetEnvironmentVariable("XDG_CONFIG_HOME");
        if (!string.IsNullOrWhiteSpace(xdgConfigHome))
        {
            return Path.Combine(xdgConfigHome, appName.ToLowerInvariant());
        }

        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        if (OperatingSystem.IsWindows())
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                appName);
        }

        return Path.Combine(home, ".config", appName.ToLowerInvariant());
    }

    /// <summary>
    /// Gets the XDG state home directory (for logs, telemetry, etc.).
    /// </summary>
    public static string GetStateHome(string appName)
    {
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrWhiteSpace(xdgStateHome))
        {
            return Path.Combine(xdgStateHome, appName.ToLowerInvariant());
        }

        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        if (OperatingSystem.IsWindows())
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                appName,
                "State");
        }

        return Path.Combine(home, ".local", "state", appName.ToLowerInvariant());
    }

    /// <summary>
    /// Finds the first existing path from a list of candidates.
    /// </summary>
    public static string? FindFirstExisting(params string[] candidates)
    {
        foreach (var path in candidates)
        {
            if (Directory.Exists(path))
            {
                return path;
            }
        }
        return null;
    }

    /// <summary>
    /// Ensures a directory exists and is writable.
    /// </summary>
    public static bool EnsureWritableDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: MyImapDownloader.Core/Data/EmailMetadata.cs
SIZE: 1.52 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

namespace MyImapDownloader.Core.Data;

/// <summary>
/// Represents metadata for an archived email.
/// This is the common model used by both the downloader and search systems.
/// </summary>
public record EmailMetadata
{
    /// <summary>
    /// The unique message ID from the email headers.
    /// </summary>
    public required string MessageId { get; init; }

    /// <summary>
    /// The email subject line.
    /// </summary>
    public string? Subject { get; init; }

    /// <summary>
    /// The sender address (From header).
    /// </summary>
    public string? From { get; init; }

    /// <summary>
    /// The recipient addresses (To header).
    /// </summary>
    public string? To { get; init; }

    /// <summary>
    /// The CC addresses.
    /// </summary>
    public string? Cc { get; init; }

    /// <summary>
    /// The date the email was sent.
    /// </summary>
    public DateTimeOffset? Date { get; init; }

    /// <summary>
    /// The folder/mailbox where the email is stored.
    /// </summary>
    public string? Folder { get; init; }

    /// <summary>
    /// When this email was archived.
    /// </summary>
    public DateTimeOffset ArchivedAt { get; init; }

    /// <summary>
    /// Whether the email has attachments.
    /// </summary>
    public bool HasAttachments { get; init; }

    /// <summary>
    /// File size in bytes.
    /// </summary>
    public long? SizeBytes { get; init; }

    /// <summary>
    /// The account this email belongs to.
    /// </summary>
    public string? Account { get; init; }
}


================================================================================
FILE: MyImapDownloader.Core/Infrastructure/SqliteHelper.cs
SIZE: 2.64 KB
MODIFIED: 2026-01-21 19:23:31
================================================================================

using Microsoft.Data.Sqlite;

namespace MyImapDownloader.Core.Infrastructure;

/// <summary>
/// Helper class for common SQLite operations.
/// </summary>
public static class SqliteHelper
{
    /// <summary>
    /// Creates a connection string with recommended settings.
    /// </summary>
    public static string CreateConnectionString(string dbPath, bool readOnly = false)
    {
        var builder = new SqliteConnectionStringBuilder
        {
            DataSource = dbPath,
            Mode = readOnly ? SqliteOpenMode.ReadOnly : SqliteOpenMode.ReadWriteCreate,
            Cache = SqliteCacheMode.Shared
        };
        return builder.ConnectionString;
    }

    /// <summary>
    /// Applies recommended pragmas for performance and safety.
    /// </summary>
    public static async Task ApplyRecommendedPragmasAsync(
        SqliteConnection connection,
        CancellationToken ct = default)
    {
        using var cmd = connection.CreateCommand();
        cmd.CommandText = """
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = NORMAL;
            PRAGMA temp_store = MEMORY;
            PRAGMA mmap_size = 268435456;
            PRAGMA cache_size = -64000;
            """;
        await cmd.ExecuteNonQueryAsync(ct);
    }

    /// <summary>
    /// Executes a non-query command.
    /// </summary>
    public static async Task<int> ExecuteNonQueryAsync(
        SqliteConnection connection,
        string sql,
        Dictionary<string, object?>? parameters = null,
        CancellationToken ct = default)
    {
        using var cmd = connection.CreateCommand();
        cmd.CommandText = sql;

        if (parameters != null)
        {
            foreach (var (key, value) in parameters)
            {
                cmd.Parameters.AddWithValue(key, value ?? DBNull.Value);
            }
        }

        return await cmd.ExecuteNonQueryAsync(ct);
    }

    /// <summary>
    /// Executes a scalar query.
    /// </summary>
    public static async Task<T?> ExecuteScalarAsync<T>(
        SqliteConnection connection,
        string sql,
        Dictionary<string, object?>? parameters = null,
        CancellationToken ct = default)
    {
        using var cmd = connection.CreateCommand();
        cmd.CommandText = sql;

        if (parameters != null)
        {
            foreach (var (key, value) in parameters)
            {
                cmd.Parameters.AddWithValue(key, value ?? DBNull.Value);
            }
        }

        var result = await cmd.ExecuteScalarAsync(ct);
        if (result == null || result == DBNull.Value)
        {
            return default;
        }
        return (T)Convert.ChangeType(result, typeof(T));
    }
}


================================================================================
FILE: MyImapDownloader.Core/Infrastructure/TempDirectory.cs
SIZE: 0.80 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

namespace MyImapDownloader.Core.Infrastructure;

/// <summary>
/// Creates a temporary directory that is automatically cleaned up on disposal.
/// Useful for tests and temporary file operations.
/// </summary>
public sealed class TempDirectory : IDisposable
{
    public string Path { get; }

    public TempDirectory(string? prefix = null)
    {
        var name = prefix ?? "temp";
        Path = System.IO.Path.Combine(
            System.IO.Path.GetTempPath(),
            $"{name}_{Guid.NewGuid():N}");
        Directory.CreateDirectory(Path);
    }

    public void Dispose()
    {
        try
        {
            if (Directory.Exists(Path))
            {
                Directory.Delete(Path, recursive: true);
            }
        }
        catch
        {
            // Best-effort cleanup
        }
    }
}


================================================================================
FILE: MyImapDownloader.Core/Infrastructure/TestLogger.cs
SIZE: 0.76 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

using Microsoft.Extensions.Logging;

namespace MyImapDownloader.Core.Infrastructure;

/// <summary>
/// Factory for creating test loggers.
/// </summary>
public static class TestLogger
{
    /// <summary>
    /// Creates a logger that writes to the console.
    /// </summary>
    public static ILogger<T> Create<T>()
    {
        using var factory = LoggerFactory.Create(builder =>
        {
            builder.AddConsole();
            builder.SetMinimumLevel(LogLevel.Debug);
        });
        return factory.CreateLogger<T>();
    }

    /// <summary>
    /// Creates a null logger that discards all output.
    /// </summary>
    public static ILogger<T> CreateNull<T>()
    {
        return Microsoft.Extensions.Logging.Abstractions.NullLogger<T>.Instance;
    }
}


================================================================================
FILE: MyImapDownloader.Core/MyImapDownloader.Core.csproj
SIZE: 1.42 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyImapDownloader.Core - Shared Infrastructure Library
    
    This library contains common components shared between:
      - MyImapDownloader (email archiving)
      - MyEmailSearch (email search)
    
    Components:
      - Telemetry: OpenTelemetry with JSONL file exporters
      - Configuration: XDG-compliant path resolution
      - Data: Common email metadata models
      - Infrastructure: SQLite helpers, test utilities
  -->
  
  <PropertyGroup>
    <RootNamespace>MyImapDownloader.Core</RootNamespace>
    <AssemblyName>MyImapDownloader.Core</AssemblyName>
    <Description>Shared infrastructure for MyImapDownloader and MyEmailSearch</Description>
  </PropertyGroup>

  <ItemGroup>
    <!-- Database -->
    <PackageReference Include="Microsoft.Data.Sqlite" />
    
    <!-- Telemetry -->
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    
    <!-- Configuration & DI -->
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
  </ItemGroup>
</Project>


================================================================================
FILE: MyImapDownloader.Core/Telemetry/DiagnosticsConfig.cs
SIZE: 1.99 KB
MODIFIED: 2026-01-23 07:50:50
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Base diagnostics configuration for shared telemetry infrastructure.
/// Applications should create their own derived config with application-specific metrics.
/// </summary>
public class DiagnosticsConfigBase(string serviceName, string serviceVersion)
{
    private readonly ActivitySource _activitySource = new(serviceName, serviceVersion);
    private readonly Meter _meter = new(serviceName, serviceVersion);

    public string ServiceName { get; } = serviceName;
    public string ServiceVersion { get; } = serviceVersion;
    public ActivitySource ActivitySource => _activitySource;
    public Meter Meter => _meter;

    /// <summary>
    /// Creates a counter metric.
    /// </summary>
    public Counter<T> CreateCounter<T>(string name, string? unit = null, string? description = null)
        where T : struct
        => _meter.CreateCounter<T>(name, unit, description);

    /// <summary>
    /// Creates a histogram metric.
    /// </summary>
    public Histogram<T> CreateHistogram<T>(string name, string? unit = null, string? description = null)
        where T : struct
        => _meter.CreateHistogram<T>(name, unit, description);

    /// <summary>
    /// Creates an observable gauge metric.
    /// </summary>
    public ObservableGauge<T> CreateObservableGauge<T>(
        string name,
        Func<T> observeValue,
        string? unit = null,
        string? description = null)
        where T : struct
        => _meter.CreateObservableGauge(name, observeValue, unit, description);
}

/// <summary>
/// Static helper for creating activity spans.
/// </summary>
public static class ActivityHelper
{
    /// <summary>
    /// Starts an activity with the given source and name.
    /// </summary>
    public static Activity? StartActivity(
        ActivitySource source,
        string name,
        ActivityKind kind = ActivityKind.Internal)
        => source.StartActivity(name, kind);
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/JsonFileLogExporter.cs
SIZE: 2.89 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter(JsonTelemetryFileWriter? writer) : BaseExporter<LogRecord>
{
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/JsonFileMetricsExporter.cs
SIZE: 3.42 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter(JsonTelemetryFileWriter? writer) : BaseExporter<Metric>
{
    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?>? ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags.Count > 0 ? tags : null;
    }

    private static object? ExtractValue(Metric metric, MetricPoint point)
    {
        return metric.MetricType switch
        {
            MetricType.LongSum => point.GetSumLong(),
            MetricType.DoubleSum => point.GetSumDouble(),
            MetricType.LongGauge => point.GetGaugeLastValueLong(),
            MetricType.DoubleGauge => point.GetGaugeLastValueDouble(),
            MetricType.Histogram => new
            {
                Count = point.GetHistogramCount(),
                Sum = point.GetHistogramSum(),
                Min = GetHistogramMin(point),
                Max = GetHistogramMax(point)
            },
            _ => null
        };
    }

    private static double? GetHistogramMin(MetricPoint point)
    {
        try
        {
            var prop = point.GetType().GetProperty("HistogramMin");
            return prop?.GetValue(point) as double?;
        }
        catch { return null; }
    }

    private static double? GetHistogramMax(MetricPoint point)
    {
        try
        {
            var prop = point.GetType().GetProperty("HistogramMax");
            return prop?.GetValue(point) as double?;
        }
        catch { return null; }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public object? Value { get; init; }
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/JsonFileTraceExporter.cs
SIZE: 2.94 KB
MODIFIED: 2026-01-21 19:23:31
================================================================================

using System.Diagnostics;

using OpenTelemetry;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter(JsonTelemetryFileWriter? writer) : BaseExporter<Activity>
{
    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList()
                };

                writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/JsonTelemetryFileWriter.cs
SIZE: 5.26 KB
MODIFIED: 2026-01-22 07:47:09
================================================================================

using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Thread-safe JSON Lines file writer with size-based rotation and periodic flushing.
/// Each telemetry record is written as a separate JSON line (JSONL format).
/// Gracefully handles write failures without crashing the application.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _directory;
    private readonly string _prefix;
    private readonly long _maxFileSize;
    private readonly ConcurrentQueue<object> _queue = new();
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly Timer _flushTimer;
    private readonly CancellationTokenSource _cts = new();

    private string _currentFilePath;
    private long _currentFileSize;
    private int _fileSequence;
    private bool _disposed;
    private bool _writeEnabled = true;

    public JsonTelemetryFileWriter(
        string directory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _directory = directory;
        _prefix = prefix;
        _maxFileSize = maxFileSizeBytes;

        try
        {
            Directory.CreateDirectory(directory);
        }
        catch
        {
            _writeEnabled = false;
        }

        _currentFilePath = GenerateFilePath();
        InitializeFileSize();

        // Timer callback with proper exception handling
        _flushTimer = new Timer(
            _ => FlushTimerCallback(),
            null,
            flushInterval,
            flushInterval);
    }

    private void FlushTimerCallback()
    {
        if (_disposed || !_writeEnabled || _queue.IsEmpty) return;

        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Degrade gracefully - disable writes after buffer grows too large
            if (_queue.Count > 10000)
            {
                _writeEnabled = false;
                while (_queue.TryDequeue(out _)) { }
            }
        }
    }

    public void Enqueue(object record)
    {
        if (_disposed || !_writeEnabled) return;
        _queue.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        // Note: We check _queue.IsEmpty but NOT _disposed here
        // This allows final flush during disposal
        if (!_writeEnabled || _queue.IsEmpty) return;

        if (!await _writeLock.WaitAsync(TimeSpan.FromSeconds(5)).ConfigureAwait(false))
            return;

        try
        {
            var records = new List<object>();
            while (_queue.TryDequeue(out var record))
            {
                records.Add(record);
            }

            if (records.Count > 0)
            {
                await WriteRecordsAsync(records).ConfigureAwait(false);
            }
        }
        catch
        {
            if (_queue.Count > 10000)
            {
                _writeEnabled = false;
                while (_queue.TryDequeue(out _)) { }
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordsAsync(List<object> records)
    {
        if (!_writeEnabled) return;

        var sb = new StringBuilder();
        foreach (var record in records)
        {
            var json = JsonSerializer.Serialize(record, new JsonSerializerOptions
            {
                WriteIndented = false,
                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
            });
            sb.AppendLine(json);
        }

        var content = sb.ToString();
        var bytes = Encoding.UTF8.GetBytes(content);

        if (_currentFileSize + bytes.Length > _maxFileSize && _currentFileSize > 0)
        {
            RotateFile();
        }

        try
        {
            await File.AppendAllTextAsync(_currentFilePath, content).ConfigureAwait(false);
            _currentFileSize += bytes.Length;
        }
        catch
        {
            // Individual write failures are silently ignored
        }
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = GenerateFilePath();
        _currentFileSize = 0;
    }

    private string GenerateFilePath()
    {
        var date = DateTime.UtcNow.ToString("yyyyMMdd");
        return Path.Combine(_directory, $"{_prefix}_{date}_{_fileSequence:D4}.jsonl");
    }

    private void InitializeFileSize()
    {
        try
        {
            _currentFileSize = File.Exists(_currentFilePath)
                ? new FileInfo(_currentFilePath).Length
                : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;

        // Stop the timer first to prevent new flushes
        _flushTimer.Dispose();

        // CRITICAL: Flush BEFORE setting _disposed = true
        // This ensures FlushAsync() doesn't return early
        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }

        // NOW mark as disposed
        _disposed = true;

        _cts.Cancel();
        _writeLock.Dispose();
        _cts.Dispose();
    }
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/TelemetryConfiguration.cs
SIZE: 0.77 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/TelemetryDirectoryResolver.cs
SIZE: 2.62 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName)
    {
        var candidates = GetCandidateDirectories(appName);

        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }

        return null;
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        var lowerAppName = appName.ToLowerInvariant();

        // 1. XDG_STATE_HOME (preferred for telemetry/logs)
        var xdgState = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgState))
        {
            yield return Path.Combine(xdgState, lowerAppName, "telemetry");
        }

        // 2. XDG_DATA_HOME
        var xdgData = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgData))
        {
            yield return Path.Combine(xdgData, lowerAppName, "telemetry");
        }

        // 3. Platform-specific defaults
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (OperatingSystem.IsLinux() || OperatingSystem.IsMacOS())
        {
            yield return Path.Combine(home, ".local", "state", lowerAppName, "telemetry");
            yield return Path.Combine(home, ".local", "share", lowerAppName, "telemetry");
        }
        else if (OperatingSystem.IsWindows())
        {
            var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            yield return Path.Combine(localAppData, appName, "telemetry");
        }

        // 4. Fallback to current directory
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: MyImapDownloader.Core/Telemetry/TelemetryExtensions.cs
SIZE: 5.07 KB
MODIFIED: 2026-01-21 20:20:49
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Extension methods for configuring OpenTelemetry with JSON file exporters.
/// </summary>
public static class TelemetryExtensions
{
    public static IServiceCollection AddCoreTelemetry(
        this IServiceCollection services,
        IConfiguration configuration,
        string serviceName,
        string serviceVersion)
    {
        var config = new TelemetryConfiguration
        {
            ServiceName = serviceName,
            ServiceVersion = serviceVersion
        };
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);
        services.AddSingleton(config);

        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);

        if (telemetryBaseDir == null)
        {
            services.AddSingleton<ITelemetryWriterProvider>(new NullTelemetryWriterProvider());
            return services;
        }

        config.OutputDirectory = telemetryBaseDir;

        var tracesDir = Path.Combine(telemetryBaseDir, "traces");
        var metricsDir = Path.Combine(telemetryBaseDir, "metrics");

        TryCreateDirectory(tracesDir);
        TryCreateDirectory(metricsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        JsonTelemetryFileWriter? traceWriter = null;
        JsonTelemetryFileWriter? metricsWriter = null;

        if (config.EnableTracing)
        {
            try
            {
                traceWriter = new JsonTelemetryFileWriter(
                    tracesDir, "traces", config.MaxFileSizeBytes, flushInterval);
            }
            catch { }
        }

        if (config.EnableMetrics)
        {
            try
            {
                metricsWriter = new JsonTelemetryFileWriter(
                    metricsDir, "metrics", config.MaxFileSizeBytes, flushInterval);
            }
            catch { }
        }

        services.AddSingleton<ITelemetryWriterProvider>(
            new TelemetryWriterProvider(traceWriter, metricsWriter, null));

        if (traceWriter != null)
        {
            services.AddSingleton(traceWriter);
        }

        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(serviceName: config.ServiceName, serviceVersion: config.ServiceVersion);

        services.AddOpenTelemetry()
            .WithTracing(builder =>
            {
                if (config.EnableTracing && traceWriter != null)
                {
                    builder
                        .SetResourceBuilder(resourceBuilder)
                        .AddSource(config.ServiceName)
                        .AddProcessor(new BatchActivityExportProcessor(
                            new JsonFileTraceExporter(traceWriter),
                            maxQueueSize: 2048,
                            scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds));
                }
            })
            .WithMetrics(builder =>
            {
                if (config.EnableMetrics && metricsWriter != null)
                {
                    builder
                        .SetResourceBuilder(resourceBuilder)
                        .AddMeter(config.ServiceName)
                        .AddRuntimeInstrumentation()
                        .AddReader(new PeriodicExportingMetricReader(
                            new JsonFileMetricsExporter(metricsWriter),
                            exportIntervalMilliseconds: config.MetricsExportIntervalSeconds * 1000));
                }
            });

        return services;
    }

    private static bool TryCreateDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

/// <summary>
/// Interface for accessing telemetry file writers.
/// </summary>
public interface ITelemetryWriterProvider
{
    JsonTelemetryFileWriter? TraceWriter { get; }
    JsonTelemetryFileWriter? MetricsWriter { get; }
    JsonTelemetryFileWriter? LogsWriter { get; }
}

/// <summary>
/// Provides access to telemetry file writers.
/// </summary>
public sealed class TelemetryWriterProvider(
    JsonTelemetryFileWriter? traceWriter,
    JsonTelemetryFileWriter? metricsWriter,
    JsonTelemetryFileWriter? logsWriter) : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => traceWriter;
    public JsonTelemetryFileWriter? MetricsWriter => metricsWriter;
    public JsonTelemetryFileWriter? LogsWriter => logsWriter;
}

/// <summary>
/// Null implementation when telemetry is disabled.
/// </summary>
public sealed class NullTelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => null;
    public JsonTelemetryFileWriter? MetricsWriter => null;
    public JsonTelemetryFileWriter? LogsWriter => null;
}


================================================================================
FILE: MyImapDownloader.Core.Tests/Configuration/PathResolverTests.cs
SIZE: 1.58 KB
MODIFIED: 2026-01-22 07:32:08
================================================================================

using MyImapDownloader.Core.Configuration;

namespace MyImapDownloader.Core.Tests.Configuration;

public class PathResolverTests
{
    [Test]
    public async Task GetDataHome_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetDataHome("TestApp");

        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task GetConfigHome_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetConfigHome("TestApp");

        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task GetStateHome_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetStateHome("TestApp");

        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task EnsureWritableDirectory_CreatesDirectory()
    {
        using var temp = new MyImapDownloader.Core.Infrastructure.TempDirectory("path_test");
        var subDir = Path.Combine(temp.Path, "subdir");

        var result = PathResolver.EnsureWritableDirectory(subDir);

        await Assert.That(result).IsTrue();
        await Assert.That(Directory.Exists(subDir)).IsTrue();
    }

    [Test]
    public async Task FindFirstExisting_ReturnsFirstMatch()
    {
        using var temp = new MyImapDownloader.Core.Infrastructure.TempDirectory("find_test");

        var result = PathResolver.FindFirstExisting(
            "/nonexistent/path",
            temp.Path,
            "/another/nonexistent");

        await Assert.That(result).IsEqualTo(temp.Path);
    }
}


================================================================================
FILE: MyImapDownloader.Core.Tests/Data/EmailMetadataTests.cs
SIZE: 2.56 KB
MODIFIED: 2026-02-18 20:00:41
================================================================================

using MyImapDownloader.Core.Data;

namespace MyImapDownloader.Core.Tests.Data;

/// <summary>
/// Tests for the shared EmailMetadata record.
/// </summary>
public class EmailMetadataTests
{
    [Test]
    public async Task EmailMetadata_CanBeCreated_WithRequiredFields()
    {
        var metadata = new EmailMetadata
        {
            MessageId = "test@example.com"
        };

        await Assert.That(metadata.MessageId).IsEqualTo("test@example.com");
    }

    [Test]
    public async Task EmailMetadata_OptionalFields_DefaultToNull()
    {
        var metadata = new EmailMetadata
        {
            MessageId = "test@example.com"
        };

        await Assert.That(metadata.Subject).IsNull();
        await Assert.That(metadata.From).IsNull();
        await Assert.That(metadata.To).IsNull();
        await Assert.That(metadata.Cc).IsNull();
        await Assert.That(metadata.Date).IsNull();
        await Assert.That(metadata.Folder).IsNull();
        await Assert.That(metadata.SizeBytes).IsNull();
        await Assert.That(metadata.Account).IsNull();
    }

    [Test]
    public async Task EmailMetadata_HasAttachments_DefaultsFalse()
    {
        var metadata = new EmailMetadata
        {
            MessageId = "test@example.com"
        };

        await Assert.That(metadata.HasAttachments).IsFalse();
    }

    [Test]
    public async Task EmailMetadata_AllFields_RoundTrip()
    {
        var now = DateTimeOffset.UtcNow;
        var metadata = new EmailMetadata
        {
            MessageId = "full@example.com",
            Subject = "Test Subject",
            From = "sender@example.com",
            To = "recipient@example.com",
            Cc = "cc@example.com",
            Date = now,
            Folder = "INBOX",
            ArchivedAt = now,
            HasAttachments = true,
            SizeBytes = 1024,
            Account = "work"
        };

        await Assert.That(metadata.Subject).IsEqualTo("Test Subject");
        await Assert.That(metadata.From).IsEqualTo("sender@example.com");
        await Assert.That(metadata.HasAttachments).IsTrue();
        await Assert.That(metadata.SizeBytes).IsEqualTo(1024);
    }

    [Test]
    public async Task EmailMetadata_IsRecord_SupportsEquality()
    {
        var a = new EmailMetadata { MessageId = "same@example.com", Subject = "Same" };
        var b = new EmailMetadata { MessageId = "same@example.com", Subject = "Same" };
        var c = new EmailMetadata { MessageId = "different@example.com", Subject = "Same" };

        await Assert.That(a).IsEqualTo(b);
        await Assert.That(a).IsNotEqualTo(c);
    }
}


================================================================================
FILE: MyImapDownloader.Core.Tests/Infrastructure/SqliteHelperTests.cs
SIZE: 2.70 KB
MODIFIED: 2026-01-22 07:32:08
================================================================================

using Microsoft.Data.Sqlite;

using MyImapDownloader.Core.Infrastructure;

namespace MyImapDownloader.Core.Tests.Infrastructure;

public class SqliteHelperTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("sqlite_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    [Test]
    public async Task CreateConnectionString_IncludesDataSource()
    {
        var dbPath = Path.Combine(_temp.Path, "test.db");
        var connStr = SqliteHelper.CreateConnectionString(dbPath);

        await Assert.That(connStr).Contains(dbPath);
    }

    [Test]
    public async Task ApplyRecommendedPragmas_DoesNotThrow()
    {
        var dbPath = Path.Combine(_temp.Path, "pragmas.db");
        await using var conn = new SqliteConnection($"Data Source={dbPath}");
        await conn.OpenAsync();

        await SqliteHelper.ApplyRecommendedPragmasAsync(conn);

        // Verify WAL mode is set
        using var cmd = conn.CreateCommand();
        cmd.CommandText = "PRAGMA journal_mode;";
        var mode = await cmd.ExecuteScalarAsync();
        await Assert.That(mode?.ToString()?.ToLower()).IsEqualTo("wal");
    }

    [Test]
    public async Task ExecuteNonQueryAsync_CreatesTable()
    {
        var dbPath = Path.Combine(_temp.Path, "nonquery.db");
        await using var conn = new SqliteConnection($"Data Source={dbPath}");
        await conn.OpenAsync();

        var result = await SqliteHelper.ExecuteNonQueryAsync(
            conn,
            "CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)");

        await Assert.That(result).IsEqualTo(0); // DDL returns 0

        // Verify table exists
        var count = await SqliteHelper.ExecuteScalarAsync<long>(
            conn,
            "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='test'");
        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task ExecuteScalarAsync_WithParameters_ReturnsValue()
    {
        var dbPath = Path.Combine(_temp.Path, "scalar.db");
        await using var conn = new SqliteConnection($"Data Source={dbPath}");
        await conn.OpenAsync();

        await SqliteHelper.ExecuteNonQueryAsync(conn,
            "CREATE TABLE kv (key TEXT PRIMARY KEY, value TEXT)");
        await SqliteHelper.ExecuteNonQueryAsync(conn,
            "INSERT INTO kv (key, value) VALUES (@k, @v)",
            new Dictionary<string, object?> { ["@k"] = "test", ["@v"] = "hello" });

        var result = await SqliteHelper.ExecuteScalarAsync<string>(
            conn,
            "SELECT value FROM kv WHERE key = @k",
            new Dictionary<string, object?> { ["@k"] = "test" });

        await Assert.That(result).IsEqualTo("hello");
    }
}


================================================================================
FILE: MyImapDownloader.Core.Tests/Infrastructure/TempDirectoryTests.cs
SIZE: 0.88 KB
MODIFIED: 2026-01-22 07:32:08
================================================================================

using MyImapDownloader.Core.Infrastructure;

namespace MyImapDownloader.Core.Tests.Infrastructure;

public class TempDirectoryTests
{
    [Test]
    public async Task Constructor_CreatesDirectory()
    {
        using var temp = new TempDirectory("test");
        await Assert.That(Directory.Exists(temp.Path)).IsTrue();
    }

    [Test]
    public async Task Dispose_DeletesDirectory()
    {
        string path;
        using (var temp = new TempDirectory("dispose_test"))
        {
            path = temp.Path;
            await Assert.That(Directory.Exists(path)).IsTrue();
        }

        await Task.Delay(100); // Give filesystem time
        await Assert.That(Directory.Exists(path)).IsFalse();
    }

    [Test]
    public async Task Path_ContainsPrefix()
    {
        using var temp = new TempDirectory("myprefix");
        await Assert.That(temp.Path).Contains("myprefix");
    }
}


================================================================================
FILE: MyImapDownloader.Core.Tests/MyImapDownloader.Core.Tests.csproj
SIZE: 0.66 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="AwesomeAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: MyImapDownloader.Core.Tests/Telemetry/JsonTelemetryFileWriterTests.cs
SIZE: 6.39 KB
MODIFIED: 2026-01-22 07:47:09
================================================================================

using System.Text.Json;

using MyImapDownloader.Core.Infrastructure;
using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Core.Tests.Telemetry;

public class JsonTelemetryFileWriterTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("writer_test");
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private JsonTelemetryFileWriter CreateWriter(
        string? subDir = null,
        string prefix = "test",
        long maxSize = 1024 * 1024)
    {
        var dir = subDir != null
            ? Path.Combine(_temp.Path, subDir)
            : _temp.Path;
        Directory.CreateDirectory(dir);

        var writer = new JsonTelemetryFileWriter(
            dir, prefix, maxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_CreatesDirectory_WhenItDoesNotExist()
    {
        var newDir = Path.Combine(_temp.Path, "new_subdir");

        var writer = new JsonTelemetryFileWriter(newDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        await Assert.That(Directory.Exists(newDir)).IsTrue();
    }

    [Test]
    public async Task Enqueue_DoesNotThrow_WhenCalled()
    {
        var writer = CreateWriter();
        var record = new { Message = "Test", Timestamp = DateTime.UtcNow };

        // Should not throw
        writer.Enqueue(record);

        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task Enqueue_CreatesFile_AfterFlush()
    {
        var writer = CreateWriter("enqueue_test");

        writer.Enqueue(new { Message = "test" });
        await writer.FlushAsync();

        var files = Directory.GetFiles(_temp.Path, "*.jsonl", SearchOption.AllDirectories);
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }

    [Test]
    public async Task Enqueue_WritesJsonLines()
    {
        var writer = CreateWriter("jsonl_test");

        writer.Enqueue(new TestRecord { Id = 1, Name = "First" });
        writer.Enqueue(new TestRecord { Id = 2, Name = "Second" });
        await writer.FlushAsync();

        var files = Directory.GetFiles(Path.Combine(_temp.Path, "jsonl_test"), "*.jsonl");
        await Assert.That(files.Length).IsEqualTo(1);

        var lines = await File.ReadAllLinesAsync(files[0]);
        await Assert.That(lines.Length).IsEqualTo(2);
        await Assert.That(lines[0]).Contains("\"Id\":1");
        await Assert.That(lines[1]).Contains("\"Id\":2");
    }

    [Test]
    public async Task FlushAsync_WritesEnqueuedRecords_ToFile()
    {
        var writer = CreateWriter("flush_test");

        var record = new TestRecord { Id = 1, Name = "Hello" };
        writer.Enqueue(record);

        await writer.FlushAsync();

        var files = Directory.GetFiles(Path.Combine(_temp.Path, "flush_test"), "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        await Assert.That(content).Contains("Hello");
        await Assert.That(content).Contains("\"Id\":1");
    }

    [Test]
    public async Task FlushAsync_WritesMultipleRecords_InJsonlFormat()
    {
        var writer = CreateWriter("multi_test");

        writer.Enqueue(new TestRecord { Id = 1, Name = "First" });
        writer.Enqueue(new TestRecord { Id = 2, Name = "Second" });
        writer.Enqueue(new TestRecord { Id = 3, Name = "Third" });

        await writer.FlushAsync();

        var files = Directory.GetFiles(Path.Combine(_temp.Path, "multi_test"), "*.jsonl");
        var lines = await File.ReadAllLinesAsync(files[0]);

        // Each record should be on its own line (JSONL format)
        await Assert.That(lines.Length).IsEqualTo(3);

        // Each line should be valid JSON
        foreach (var line in lines)
        {
            var parsed = JsonSerializer.Deserialize<TestRecord>(line);
            await Assert.That(parsed).IsNotNull();
        }
    }

    [Test]
    public async Task Writer_RotatesFile_WhenSizeExceeded()
    {
        var writer = CreateWriter("rotate_test", maxSize: 100);

        // Write enough data to trigger rotation
        for (int i = 0; i < 10; i++)
        {
            writer.Enqueue(new { Index = i, Data = new string('x', 50) });
            await writer.FlushAsync();
        }

        var files = Directory.GetFiles(Path.Combine(_temp.Path, "rotate_test"), "*.jsonl");
        await Assert.That(files.Length).IsGreaterThan(1);
    }

    [Test]
    public async Task Dispose_CanBeCalledMultipleTimes()
    {
        var writer = new JsonTelemetryFileWriter(
            Path.Combine(_temp.Path, "dispose_multi"),
            "test",
            1024 * 1024,
            TimeSpan.FromSeconds(30));

        // Should not throw when called multiple times
        writer.Dispose();
        writer.Dispose();
        writer.Dispose();

        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task Dispose_FlushesRemainingRecords()
    {
        var subDir = Path.Combine(_temp.Path, "dispose_flush");
        Directory.CreateDirectory(subDir);

        // Create writer - NOT tracked by _writers to control disposal manually
        var writer = new JsonTelemetryFileWriter(subDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));

        // Enqueue a record
        writer.Enqueue(new { FinalRecord = true, Message = "This should be flushed on dispose" });

        // Dispose should flush the remaining records
        writer.Dispose();

        // Small delay for any file system operations
        await Task.Delay(50);

        var files = Directory.GetFiles(subDir, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        // Verify the content was actually written
        var content = await File.ReadAllTextAsync(files[0]);
        await Assert.That(content).Contains("FinalRecord");
    }

    [Test]
    public async Task FlushAsync_WithEmptyBuffer_DoesNotThrow()
    {
        var writer = CreateWriter("empty_flush");

        // Flush with nothing enqueued should not throw
        await writer.FlushAsync();

        await Assert.That(writer).IsNotNull();
    }

    private record TestRecord
    {
        public int Id { get; init; }
        public string? Name { get; init; }
    }
}


================================================================================
FILE: MyImapDownloader.Core.Tests/Telemetry/TelemetryConfigurationTests.cs
SIZE: 1.28 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Core.Tests.Telemetry;

public class TelemetryConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreReasonable()
    {
        var config = new TelemetryConfiguration();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.ServiceVersion).IsEqualTo("1.0.0");
        await Assert.That(config.EnableTracing).IsTrue();
        await Assert.That(config.EnableMetrics).IsTrue();
        await Assert.That(config.EnableLogging).IsTrue();
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(25);
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(5);
    }

    [Test]
    public async Task MaxFileSizeBytes_CalculatesCorrectly()
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = 10 };
        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(10L * 1024L * 1024L);
    }

    [Test]
    [Arguments(1)]
    [Arguments(25)]
    [Arguments(100)]
    public async Task MaxFileSizeBytes_ScalesWithMB(int megabytes)
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = megabytes };
        var expected = (long)megabytes * 1024L * 1024L;
        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(expected);
    }
}


================================================================================
FILE: MyImapDownloader/DownloadOptions.cs
SIZE: 1.25 KB
MODIFIED: 2026-01-25 12:56:54
================================================================================

ï»¿using CommandLine;

namespace MyImapDownloader;

public class DownloadOptions
{
    [Option('s', "server", Required = true, HelpText = "IMAP server address")]
    public required string Server { get; set; }

    [Option('u', "username", Required = true, HelpText = "Email username")]
    public required string Username { get; set; }

    [Option('p', "password", Required = true, HelpText = "Email password")]
    public required string Password { get; set; }

    [Option('r', "port", Default = 993, HelpText = "IMAP port (default: 993)")]
    public int Port { get; set; } = 993;

    [Option('o', "output", Default = "EmailArchive", HelpText = "Output directory for archived emails")]
    public required string OutputDirectory { get; set; }

    [Option("start-date", HelpText = "Download emails from this date (yyyy-MM-dd)")]
    public DateTime? StartDate { get; set; }

    [Option("end-date", HelpText = "Download emails until this date (yyyy-MM-dd)")]
    public DateTime? EndDate { get; set; }

    [Option('a', "all-folders", Default = false, HelpText = "Download from all folders, not just INBOX")]
    public bool AllFolders { get; set; }

    [Option('v', "verbose", Default = false, HelpText = "Enable verbose logging")]
    public bool Verbose { get; set; }
}


================================================================================
FILE: MyImapDownloader/EmailDownloadException.cs
SIZE: 0.24 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

ï»¿namespace MyImapDownloader;

// Custom Exceptions
public class EmailDownloadException(string message, int messageIndex, Exception innerException)
    : Exception(message, innerException)
{
    public int MessageIndex { get; } = messageIndex;
}


================================================================================
FILE: MyImapDownloader/EmailDownloadService.cs
SIZE: 8.96 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using MailKit;
using MailKit.Net.Imap;
using MailKit.Search;
using MailKit.Security;

using Microsoft.Extensions.Logging;

using MyImapDownloader.Telemetry;

using Polly;
using Polly.CircuitBreaker;
using Polly.Retry;

namespace MyImapDownloader;

public class EmailDownloadService
{
    private readonly ILogger<EmailDownloadService> _logger;
    private readonly ImapConfiguration _config;
    private readonly EmailStorageService _storage;
    private readonly AsyncRetryPolicy _retryPolicy;
    private readonly AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    public EmailDownloadService(
        ILogger<EmailDownloadService> logger,
        ImapConfiguration config,
        EmailStorageService storage)
    {
        _logger = logger;
        _config = config;
        _storage = storage;

        _retryPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .WaitAndRetryForeverAsync(
                retryAttempt => TimeSpan.FromSeconds(Math.Min(Math.Pow(2, retryAttempt), 300)),
                (exception, retryCount, timeSpan) =>
                {
                    _logger.LogWarning("Retry {Count} in {Delay}: {Message}", retryCount, timeSpan, exception.Message);
                });

        _circuitBreakerPolicy = Policy
            .Handle<Exception>(ex => ex is not AuthenticationException)
            .CircuitBreakerAsync(5, TimeSpan.FromMinutes(2));
    }

    public async Task DownloadEmailsAsync(DownloadOptions options, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("DownloadEmails");

        await _storage.InitializeAsync(ct);

        var policy = Policy.WrapAsync(_retryPolicy, _circuitBreakerPolicy);

        await policy.ExecuteAsync(async () =>
        {
            using var client = new ImapClient { Timeout = 180_000 };
            try
            {
                await ConnectAndAuthenticateAsync(client, ct);

                var folders = options.AllFolders
                    ? await GetAllFoldersAsync(client, ct)
                    : [client.Inbox];

                foreach (var folder in folders)
                {
                    await ProcessFolderAsync(folder, options, ct);
                }
            }
            finally
            {
                if (client.IsConnected) await client.DisconnectAsync(true, ct);
            }
        });
    }

    private async Task ProcessFolderAsync(IMailFolder folder, DownloadOptions options, CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("ProcessFolder");
        activity?.SetTag("folder", folder.FullName);

        try
        {
            await folder.OpenAsync(FolderAccess.ReadOnly, ct);

            long lastUidVal = await _storage.GetLastUidAsync(folder.FullName, folder.UidValidity, ct);
            UniqueId? startUid = lastUidVal > 0 ? new UniqueId((uint)lastUidVal) : null;

            _logger.LogInformation("Syncing {Folder}. Last UID: {Uid}", folder.FullName, startUid);

            var query = SearchQuery.All;
            if (startUid.HasValue)
            {
                var range = new UniqueIdRange(new UniqueId(startUid.Value.Id + 1), UniqueId.MaxValue);
                query = SearchQuery.Uids(range);
            }
            if (options.StartDate.HasValue) query = query.And(SearchQuery.DeliveredAfter(options.StartDate.Value));
            if (options.EndDate.HasValue) query = query.And(SearchQuery.DeliveredBefore(options.EndDate.Value));

            var uids = await folder.SearchAsync(query, ct);
            _logger.LogInformation("Found {Count} new messages in {Folder}", uids.Count, folder.FullName);

            int batchSize = 50;
            for (int i = 0; i < uids.Count; i += batchSize)
            {
                if (ct.IsCancellationRequested) break;

                var batch = uids.Skip(i).Take(batchSize).ToList();
                var result = await DownloadBatchAsync(folder, batch, ct);

                // FIX: Only update checkpoint to the SAFE point
                // If there were failures, don't advance past the lowest failed UID
                if (result.SafeCheckpointUid > 0)
                {
                    await _storage.UpdateLastUidAsync(folder.FullName, result.SafeCheckpointUid, folder.UidValidity, ct);
                }

                // FIX: Log failed UIDs for manual intervention if needed
                if (result.FailedUids.Count > 0)
                {
                    _logger.LogWarning("Failed to download {Count} emails in {Folder}: UIDs {Uids}",
                        result.FailedUids.Count, folder.FullName, string.Join(", ", result.FailedUids));
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing folder {Folder}", folder.FullName);
            throw;
        }
    }

    /// <summary>
    /// FIX: New result type to track both successful and failed UIDs.
    /// </summary>
    private sealed record BatchResult(long SafeCheckpointUid, List<uint> FailedUids);

    private async Task<BatchResult> DownloadBatchAsync(IMailFolder folder, IList<UniqueId> uids, CancellationToken ct)
    {
        long safeCheckpointUid = 0;
        var failedUids = new List<uint>();
        long? lowestFailedUid = null;

        var items = await folder.FetchAsync(uids, MessageSummaryItems.Envelope | MessageSummaryItems.UniqueId | MessageSummaryItems.InternalDate, ct);

        foreach (var item in items)
        {
            using var activity = DiagnosticsConfig.ActivitySource.StartActivity("ProcessEmail");

            string normalizedMessageIdentifier = string.IsNullOrWhiteSpace(item.Envelope.MessageId)
                ? $"NO-ID-{item.InternalDate?.Ticks ?? DateTime.UtcNow.Ticks}-{Guid.NewGuid()}"
                : EmailStorageService.NormalizeMessageId(item.Envelope.MessageId);

            if (await _storage.ExistsAsyncNormalized(normalizedMessageIdentifier, ct))
            {
                _logger.LogDebug("Skipping duplicate {Id}", normalizedMessageIdentifier);
                // FIX: Even duplicates count as successfully processed for checkpoint
                if (lowestFailedUid == null || item.UniqueId.Id < lowestFailedUid)
                {
                    safeCheckpointUid = Math.Max(safeCheckpointUid, (long)item.UniqueId.Id);
                }
                continue;
            }

            try
            {
                using var stream = await folder.GetStreamAsync(item.UniqueId, ct);
                bool isNew = await _storage.SaveStreamAsync(
                    stream,
                    item.Envelope.MessageId ?? string.Empty,
                    item.InternalDate ?? DateTimeOffset.UtcNow,
                    folder.FullName,
                    ct);

                if (isNew) _logger.LogInformation("Downloaded: {Subject}", item.Envelope.Subject);

                // FIX: Only update safe checkpoint if no failures before this UID
                if (lowestFailedUid == null || item.UniqueId.Id < lowestFailedUid)
                {
                    safeCheckpointUid = Math.Max(safeCheckpointUid, (long)item.UniqueId.Id);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to download UID {Uid}", item.UniqueId);
                failedUids.Add(item.UniqueId.Id);

                // FIX: Track the lowest failed UID
                if (lowestFailedUid == null || item.UniqueId.Id < lowestFailedUid)
                {
                    lowestFailedUid = item.UniqueId.Id;
                }

                // FIX: Adjust safe checkpoint to be just before the first failure
                if (lowestFailedUid.HasValue && safeCheckpointUid >= lowestFailedUid.Value)
                {
                    safeCheckpointUid = lowestFailedUid.Value - 1;
                }
            }
        }

        return new BatchResult(safeCheckpointUid, failedUids);
    }

    private async Task ConnectAndAuthenticateAsync(ImapClient client, CancellationToken ct)
    {
        _logger.LogInformation("Connecting to {Server}:{Port}", _config.Server, _config.Port);
        await client.ConnectAsync(_config.Server, _config.Port, SecureSocketOptions.SslOnConnect, ct);
        await client.AuthenticateAsync(_config.Username, _config.Password, ct);
    }

    private async Task<List<IMailFolder>> GetAllFoldersAsync(ImapClient client, CancellationToken ct)
    {
        var folders = new List<IMailFolder>();
        var personal = client.GetFolder(client.PersonalNamespaces[0]);
        await CollectFoldersRecursiveAsync(personal, folders, ct);
        if (!folders.Contains(client.Inbox)) folders.Insert(0, client.Inbox);
        return folders;
    }

    private async Task CollectFoldersRecursiveAsync(IMailFolder parent, List<IMailFolder> folders, CancellationToken ct)
    {
        foreach (var folder in await parent.GetSubfoldersAsync(false, ct))
        {
            folders.Add(folder);
            await CollectFoldersRecursiveAsync(folder, folders, ct);
        }
    }
}


================================================================================
FILE: MyImapDownloader/EmailMetadata.cs
SIZE: 0.39 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyImapDownloader;

public class EmailMetadata
{
    public required string MessageId { get; set; }
    public string? Subject { get; set; }
    public string? From { get; set; }
    public string? To { get; set; }
    public DateTime Date { get; set; }
    public required string Folder { get; set; }
    public DateTime ArchivedAt { get; set; }
    public bool HasAttachments { get; set; }
}


================================================================================
FILE: MyImapDownloader/EmailStorageService.cs
SIZE: 11.80 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Logging;

using MimeKit;

using MyImapDownloader.Telemetry;

namespace MyImapDownloader;

public class EmailStorageService(ILogger<EmailStorageService> logger, string baseDirectory) : IAsyncDisposable
{
    private readonly string _dbPath = Path.Combine(baseDirectory, "index.v1.db");
    private SqliteConnection? _connection;

    // Metrics
    private static readonly Counter<long> FilesWritten =
        DiagnosticsConfig.Meter.CreateCounter<long>("storage.files.written");
    private static readonly Counter<long> BytesWritten =
        DiagnosticsConfig.Meter.CreateCounter<long>("storage.bytes.written");
    private static readonly Histogram<double> WriteLatency =
        DiagnosticsConfig.Meter.CreateHistogram<double>("storage.write.latency");

    public async Task InitializeAsync(CancellationToken ct)
    {
        Directory.CreateDirectory(baseDirectory);

        try
        {
            await OpenAndMigrateAsync(ct);
        }
        catch (SqliteException ex)
        {
            logger.LogError(ex, "Database corruption detected. Initiating recovery...");
            await RecoverDatabaseAsync(ct);
        }
    }

    private async Task OpenAndMigrateAsync(CancellationToken ct)
    {
        _connection = new SqliteConnection($"Data Source={_dbPath}");
        await _connection.OpenAsync(ct);

        using var cmd = _connection.CreateCommand();
        cmd.CommandText = """
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = NORMAL;

            CREATE TABLE IF NOT EXISTS Messages (
                MessageId TEXT PRIMARY KEY,
                Folder TEXT NOT NULL,
                ImportedAt TEXT NOT NULL
            );

            CREATE TABLE IF NOT EXISTS SyncState (
                Folder TEXT PRIMARY KEY,
                LastUid INTEGER NOT NULL,
                UidValidity INTEGER NOT NULL
            );

            CREATE INDEX IF NOT EXISTS IX_Messages_Folder ON Messages(Folder);
            """;

        await cmd.ExecuteNonQueryAsync(ct);
    }

    private async Task RecoverDatabaseAsync(CancellationToken ct)
    {
        if (File.Exists(_dbPath))
        {
            var backupPath = _dbPath + $".corrupt.{DateTime.UtcNow.Ticks}";
            File.Move(_dbPath, backupPath);
            logger.LogWarning("Moved corrupt database to {Path}", backupPath);
        }

        await OpenAndMigrateAsync(ct);

        logger.LogInformation("Rebuilding index from disk...");
        int count = 0;

        foreach (var metaFile in Directory.EnumerateFiles(baseDirectory, "*.meta.json", SearchOption.AllDirectories))
        {
            try
            {
                var json = await File.ReadAllTextAsync(metaFile, ct);
                var meta = JsonSerializer.Deserialize<EmailMetadata>(json);
                if (!string.IsNullOrWhiteSpace(meta?.MessageId) &&
                    !string.IsNullOrWhiteSpace(meta.Folder))
                {
                    await InsertMessageRecordAsync(meta.MessageId, meta.Folder, ct);
                    count++;
                }
            }
            catch (Exception ex)
            {
                logger.LogWarning("Skipping malformed meta file {File}: {Error}", metaFile, ex.Message);
            }
        }

        logger.LogInformation("Recovery complete. Re-indexed {Count} emails.", count);
    }

    public async Task<long> GetLastUidAsync(string folderName, long currentValidity, CancellationToken ct)
    {
        if (_connection == null) await InitializeAsync(ct);

        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT LastUid, UidValidity FROM SyncState WHERE Folder = @folder";
        cmd.Parameters.AddWithValue("@folder", folderName);

        using var reader = await cmd.ExecuteReaderAsync(ct);
        if (await reader.ReadAsync(ct))
        {
            long storedValidity = reader.GetInt64(1);
            if (storedValidity == currentValidity)
                return reader.GetInt64(0);

            logger.LogWarning("UIDVALIDITY changed for {Folder}. Resetting cursor.", folderName);
        }

        return 0;
    }

    public async Task UpdateLastUidAsync(string folderName, long lastUid, long validity, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = """
            INSERT INTO SyncState (Folder, LastUid, UidValidity)
            VALUES (@folder, @uid, @validity)
            ON CONFLICT(Folder) DO UPDATE SET
                LastUid = @uid,
                UidValidity = @validity
            WHERE LastUid < @uid OR UidValidity != @validity;
            """;

        cmd.Parameters.AddWithValue("@folder", folderName);
        cmd.Parameters.AddWithValue("@uid", lastUid);
        cmd.Parameters.AddWithValue("@validity", validity);
        await cmd.ExecuteNonQueryAsync(ct);
    }

    /// <summary>
    /// Streams an email to disk. Returns true if saved, false if duplicate.
    /// </summary>
    public async Task<bool> SaveStreamAsync(
        Stream networkStream,
        string messageId,
        DateTimeOffset internalDate,
        string folderName,
        CancellationToken ct)
    {
        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("SaveStream");
        var sw = Stopwatch.StartNew();

        string normalizedId = string.IsNullOrWhiteSpace(messageId)
            ? ComputeHash(internalDate.ToString())
            : NormalizeMessageId(messageId);

        if (await ExistsAsyncNormalized(normalizedId, ct))
            return false;

        string folderPath = GetFolderPath(folderName);
        EnsureMaildirStructure(folderPath);

        string tempPath = Path.Combine(
            folderPath,
            "tmp",
            $"{internalDate.ToUnixTimeSeconds()}.{Guid.NewGuid()}.tmp");

        long bytesWritten;
        EmailMetadata metadata;

        try
        {
            using (var fs = File.Create(tempPath))
            {
                await networkStream.CopyToAsync(fs, ct);
                bytesWritten = fs.Length;
            }

            using (var fs = File.OpenRead(tempPath))
            {
                var parser = new MimeParser(fs, MimeFormat.Entity);
                var headers = await parser.ParseHeadersAsync(ct);

                var parsedId = headers[HeaderId.MessageId];
                if (string.IsNullOrWhiteSpace(messageId) && !string.IsNullOrWhiteSpace(parsedId))
                {
                    normalizedId = NormalizeMessageId(parsedId);
                    if (await ExistsAsyncNormalized(normalizedId, ct))
                    {
                        File.Delete(tempPath);
                        return false;
                    }
                }

                metadata = new EmailMetadata
                {
                    MessageId = normalizedId,
                    Subject = headers[HeaderId.Subject],
                    From = headers[HeaderId.From],
                    To = headers[HeaderId.To],
                    Date = DateTimeOffset.TryParse(headers[HeaderId.Date], out var d)
                        ? d.UtcDateTime
                        : internalDate.UtcDateTime,
                    Folder = folderName,
                    ArchivedAt = DateTime.UtcNow,
                    HasAttachments = false
                };
            }

            string safeFileId = SanitizeFilename(normalizedId);
            string finalName = GenerateFilename(internalDate, safeFileId);
            string finalPath = Path.Combine(folderPath, "cur", finalName);

            int attempt = 0;
            while (File.Exists(finalPath) && attempt < 10)
            {
                attempt++;
                finalName = GenerateFilename(internalDate, $"{safeFileId}_{attempt}");
                finalPath = Path.Combine(folderPath, "cur", finalName);
            }

            if (File.Exists(finalPath))
            {
                File.Delete(tempPath);
                await InsertMessageRecordAsync(normalizedId, folderName, ct);
                return false;
            }

            Directory.CreateDirectory(Path.GetDirectoryName(finalPath)!);
            File.Move(tempPath, finalPath);

            await File.WriteAllTextAsync(
                finalPath + ".meta.json",
                JsonSerializer.Serialize(metadata, new JsonSerializerOptions { WriteIndented = true }),
                ct);

            await InsertMessageRecordAsync(normalizedId, folderName, ct);

            FilesWritten.Add(1);
            BytesWritten.Add(bytesWritten);
            WriteLatency.Record(sw.Elapsed.TotalMilliseconds);

            return true;
        }
        catch
        {
            try { if (File.Exists(tempPath)) File.Delete(tempPath); } catch { }
            throw;
        }
    }

    private async Task InsertMessageRecordAsync(string messageId, string folder, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText =
            "INSERT OR IGNORE INTO Messages (MessageId, Folder, ImportedAt) VALUES (@id, @folder, @date)";
        cmd.Parameters.AddWithValue("@id", messageId);
        cmd.Parameters.AddWithValue("@folder", folder);
        cmd.Parameters.AddWithValue("@date", DateTime.UtcNow.ToString("O"));
        await cmd.ExecuteNonQueryAsync(ct);
    }

    private string GetFolderPath(string folderName) =>
        Path.Combine(baseDirectory, SanitizeForFilename(folderName, 100));

    private static void EnsureMaildirStructure(string folderPath)
    {
        Directory.CreateDirectory(Path.Combine(folderPath, "cur"));
        Directory.CreateDirectory(Path.Combine(folderPath, "new"));
        Directory.CreateDirectory(Path.Combine(folderPath, "tmp"));
    }

    public static string GenerateFilename(DateTimeOffset date, string safeId)
    {
        string host = SanitizeForFilename(Environment.MachineName, 20);
        return $"{date.ToUnixTimeSeconds()}.{safeId}.{host}.eml";
    }

    public static string NormalizeMessageId(string messageId)
    {
        string cleaned = Regex.Replace(messageId, @"[<>:""/\\|?*\x00-\x1F]", "_")
            .Trim('<', '>')
            .ToLowerInvariant();

        if (cleaned.Length > 100)
        {
            string hash = ComputeHash(cleaned)[..8];
            cleaned = cleaned[..91] + "_" + hash;
        }

        return cleaned.Length == 0 ? "unknown" : cleaned;
    }

    private static string SanitizeFilename(string input)
    {
        var invalid = Path.GetInvalidFileNameChars();
        var sb = new StringBuilder(input.Length);

        foreach (char c in input)
            sb.Append(invalid.Contains(c) ? '_' : c);

        return sb.ToString().TrimEnd('.', ' ');
    }

    public async Task<bool> ExistsAsyncNormalized(string id, CancellationToken ct)
    {
        using var cmd = _connection!.CreateCommand();
        cmd.CommandText = "SELECT 1 FROM Messages WHERE MessageId = @id LIMIT 1";
        cmd.Parameters.AddWithValue("@id", id);
        return (await cmd.ExecuteScalarAsync(ct)) != null;
    }

    public static string SanitizeForFilename(string input, int maxLength)
    {
        var sb = new StringBuilder(maxLength);
        foreach (char c in input)
        {
            if (char.IsLetterOrDigit(c) || c is '-' or '_' or '.')
                sb.Append(c);
            else if (sb.Length > 0 && sb[^1] != '_')
                sb.Append('_');

            if (sb.Length >= maxLength) break;
        }
        return sb.ToString().Trim('_');
    }

    public static string ComputeHash(string input)
    {
        var bytes = SHA256.HashData(Encoding.UTF8.GetBytes(input));
        return Convert.ToHexString(bytes).ToLowerInvariant();
    }

    public async ValueTask DisposeAsync()
    {
        if (_connection != null)
            await _connection.DisposeAsync();
    }
}


================================================================================
FILE: MyImapDownloader/ImapConfiguration.cs
SIZE: 0.31 KB
MODIFIED: 2025-12-18 18:29:53
================================================================================

ï»¿namespace MyImapDownloader;

// Configuration Model
public class ImapConfiguration
{
    public required string Server { get; set; }
    public int Port { get; set; }
    public required string Username { get; set; }
    public required string Password { get; set; }
    public bool UseSsl { get; set; } = true;
}


================================================================================
FILE: MyImapDownloader/MyImapDownloader.csproj
SIZE: 1.03 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyImapDownloader - Email Archive Downloader
    
    Downloads emails from IMAP servers and archives them locally.
    Uses MyImapDownloader.Core for shared infrastructure.
  -->
  
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <RootNamespace>MyImapDownloader</RootNamespace>
    <AssemblyName>MyImapDownloader</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <!-- Core library reference -->
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- CLI -->
    <PackageReference Include="CommandLineParser" />
    
    <!-- IMAP -->
    <PackageReference Include="MailKit" />
    
    <!-- Resilience -->
    <PackageReference Include="Polly" />
    
    <!-- Configuration & Hosting -->
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>


================================================================================
FILE: MyImapDownloader/Program.cs
SIZE: 4.33 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

ï»¿using System.Diagnostics;

using CommandLine;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

using MyImapDownloader;
using MyImapDownloader.Telemetry;

var parseResult = Parser.Default.ParseArguments<DownloadOptions>(args);

await parseResult.WithParsedAsync(async options =>
{
    var host = Host.CreateDefaultBuilder(args)
        .ConfigureAppConfiguration((context, config) =>
        {
            config.SetBasePath(AppContext.BaseDirectory);
            config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true);
            config.AddEnvironmentVariables();
        })
        .ConfigureLogging((context, logging) =>
        {
            logging.ClearProviders();
            logging.AddConsole();
            logging.SetMinimumLevel(options.Verbose ? LogLevel.Debug : LogLevel.Information);
            logging.AddTelemetryLogging(context.Configuration);
        })
        .ConfigureServices((context, services) =>
        {
            // Add telemetry
            services.AddTelemetry(context.Configuration);

            services.AddSingleton(options);
            services.AddSingleton(new ImapConfiguration
            {
                Server = options.Server,
                Username = options.Username,
                Password = options.Password,
                Port = options.Port
            });
            services.AddSingleton(sp =>
            {
                var logger = sp.GetRequiredService<ILogger<EmailStorageService>>();
                return new EmailStorageService(logger, options.OutputDirectory);
            });
            services.AddTransient<EmailDownloadService>();
        })
        .Build();

    var downloadService = host.Services.GetRequiredService<EmailDownloadService>();
    var logger = host.Services.GetRequiredService<ILogger<Program>>();
    var telemetryConfig = host.Services.GetRequiredService<TelemetryConfiguration>();

    // Create root activity for the entire session
    using var rootActivity = DiagnosticsConfig.ActivitySource.StartActivity(
        "EmailArchiveSession", ActivityKind.Server);

    rootActivity?.SetTag("service.name", telemetryConfig.ServiceName);
    rootActivity?.SetTag("service.version", telemetryConfig.ServiceVersion);
    rootActivity?.SetTag("host.name", Environment.MachineName);
    rootActivity?.SetTag("process.pid", Environment.ProcessId);
    rootActivity?.SetTag("telemetry.directory", telemetryConfig.OutputDirectory);

    var sessionStopwatch = Stopwatch.StartNew();

    try
    {
        logger.LogInformation("Starting email archive download...");
        logger.LogInformation("Output: {Output}", Path.GetFullPath(options.OutputDirectory));
        logger.LogInformation("Telemetry output: {TelemetryOutput}",
            Path.GetFullPath(telemetryConfig.OutputDirectory));

        rootActivity?.AddEvent(new ActivityEvent("DownloadStarted"));

        await downloadService.DownloadEmailsAsync(options, CancellationToken.None);

        sessionStopwatch.Stop();

        rootActivity?.SetTag("session_duration_ms", sessionStopwatch.ElapsedMilliseconds);
        rootActivity?.SetStatus(ActivityStatusCode.Ok);
        rootActivity?.AddEvent(new ActivityEvent("DownloadCompleted"));

        logger.LogInformation("Archive complete! Session duration: {Duration}ms",
            sessionStopwatch.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        rootActivity?.SetStatus(ActivityStatusCode.Error, ex.Message);
        rootActivity?.RecordException(ex);
        rootActivity?.AddEvent(new ActivityEvent("DownloadFailed", tags: new ActivityTagsCollection
        {
            ["exception.type"] = ex.GetType().FullName,
            ["exception.message"] = ex.Message
        }));

        logger.LogCritical(ex, "Fatal error during download");
        Environment.ExitCode = 1;
    }
    finally
    {
        // Ensure all telemetry is flushed before exit
        logger.LogInformation("Flushing telemetry data...");

        // Give time for async exporters to flush
        await Task.Delay(TimeSpan.FromSeconds(2));

        // Dispose file writers to flush remaining data
        var traceWriter = host.Services.GetService<JsonTelemetryFileWriter>();
        traceWriter?.Dispose();
    }
});

parseResult.WithNotParsed(errors =>
{
    Environment.ExitCode = 1;
});


================================================================================
FILE: MyImapDownloader.slnx
SIZE: 2.57 KB
MODIFIED: 2026-01-22 07:31:10
================================================================================

ï»¿<?xml version="1.0" encoding="utf-8"?>
<!--
  MyImapDownloader Solution File (Modern .slnx format)
  
  This solution contains:
    - MyImapDownloader: Email archive downloader (IMAP to local .eml files)
    - MyEmailSearch: Full-text search over archived emails
    - MyImapDownloader.Core: Shared infrastructure library
  
  Folder Structure:
    /Solution Items/     - Loose files (build props, readme, license)
    /Core/               - Shared library used by all applications
    /MyImapDownloader/   - Downloader app + tests
    /MyEmailSearch/      - Search app + tests
-->
<Solution>
  <!-- 
    Solution Items Folder
    ====================
    Virtual folder for files that belong to the solution but aren't part of any project.
    These appear at the solution root in IDE Solution Explorer.
  -->
  <Folder Name="/Solution Items/">
    <File Path="Directory.Build.props" />
    <File Path="Directory.Build.targets" />
    <File Path="Directory.Packages.props" />
    <File Path="global.json" />
    <File Path="README.md" />
    <File Path=".gitignore" />
    <File Path="LICENSE" />
  </Folder>
  
  <!--
    Core Library Folder
    ===================
    Shared infrastructure used by both MyImapDownloader and MyEmailSearch.
    Contains: Telemetry, Configuration, Data models, SQLite helpers.
    
    NOTE: This was MISSING from the original solution file!
    Both apps reference Core via ProjectReference, so it built transitively,
    but it wasn't visible in the IDE Solution Explorer.
  -->
  <Folder Name="/Core/">
    <Project Path="MyImapDownloader.Core/MyImapDownloader.Core.csproj" />
    <Project Path="MyImapDownloader.Core.Tests/MyImapDownloader.Core.Tests.csproj" />
  </Folder>
  
  <!--
    MyImapDownloader Folder
    =======================
    Email archive downloader application.
    Downloads emails from IMAP servers and stores them as .eml files.
    
    Why nest Tests here? 
    - Visual organization in IDE
    - Groups related code together
    - Physical folders remain at repo root (MyImapDownloader/, MyImapDownloader.Tests/)
  -->
  <Folder Name="/MyImapDownloader/">
    <Project Path="MyImapDownloader/MyImapDownloader.csproj" />
    <Project Path="MyImapDownloader.Tests/MyImapDownloader.Tests.csproj" />
  </Folder>
  
  <!--
    MyEmailSearch Folder
    ====================
    Full-text search application for archived emails.
    Uses SQLite FTS5 for efficient text search.
  -->
  <Folder Name="/MyEmailSearch/">
    <Project Path="MyEmailSearch/MyEmailSearch.csproj" />
    <Project Path="MyEmailSearch.Tests/MyEmailSearch.Tests.csproj" />
  </Folder>
</Solution>


================================================================================
FILE: MyImapDownloader/Telemetry/ActivityExtension.cs
SIZE: 1.29 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using System.Diagnostics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for Activity to provide RecordException functionality
/// that works across OpenTelemetry versions.
/// </summary>
public static class ActivityExtensions
{
    /// <summary>
    /// Records an exception as an event on the activity with standard attributes.
    /// </summary>
    public static void RecordException(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        var tags = new ActivityTagsCollection
        {
            ["exception.type"] = exception.GetType().FullName,
            ["exception.message"] = exception.Message,
        };

        if (!string.IsNullOrEmpty(exception.StackTrace))
        {
            tags["exception.stacktrace"] = exception.StackTrace;
        }

        activity.AddEvent(new ActivityEvent("exception", tags: tags));
    }

    /// <summary>
    /// Sets the activity status to error with the exception message.
    /// </summary>
    public static void SetErrorStatus(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
        activity.RecordException(exception);
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/DiagnosticsConfig.cs
SIZE: 2.96 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using System.Diagnostics.Metrics;

using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Application-specific diagnostics configuration for MyImapDownloader.
/// Extends the core telemetry infrastructure with email-specific metrics.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyImapDownloader";
    public const string ServiceVersion = "1.0.0";

    private static readonly DiagnosticsConfigBase _base = new(ServiceName, ServiceVersion);

    public static System.Diagnostics.ActivitySource ActivitySource => _base.ActivitySource;
    public static Meter Meter => _base.Meter;

    // Email download metrics
    public static readonly Counter<long> EmailsDownloaded = _base.CreateCounter<long>(
        "emails.downloaded", "emails", "Total emails downloaded");

    public static readonly Counter<long> BytesDownloaded = _base.CreateCounter<long>(
        "bytes.downloaded", "bytes", "Total bytes downloaded");

    public static readonly Histogram<double> DownloadLatency = _base.CreateHistogram<double>(
        "download.latency", "ms", "Email download latency");

    public static readonly Counter<long> RetryAttempts = _base.CreateCounter<long>(
        "retry.attempts", "attempts", "Number of retry attempts");

    // Storage metrics
    public static readonly Counter<long> FilesWritten = _base.CreateCounter<long>(
        "storage.files.written", "files", "Number of email files written");

    public static readonly Counter<long> BytesWritten = _base.CreateCounter<long>(
        "storage.bytes.written", "bytes", "Total bytes written to disk");

    public static readonly Histogram<double> WriteLatency = _base.CreateHistogram<double>(
        "storage.write.latency", "ms", "Disk write latency");

    // Connection metrics
    private static int _activeConnections;
    private static int _queuedEmails;
    private static long _totalEmailsInSession;

    public static readonly ObservableGauge<int> ActiveConnections = _base.Meter.CreateObservableGauge(
        "connections.active", () => _activeConnections, "connections", "Active IMAP connections");

    public static readonly ObservableGauge<int> QueuedEmails = _base.Meter.CreateObservableGauge(
        "emails.queued", () => _queuedEmails, "emails", "Emails queued for processing");

    public static readonly ObservableGauge<long> TotalEmailsInSession = _base.Meter.CreateObservableGauge(
        "emails.total.session", () => _totalEmailsInSession, "emails", "Total emails in session");

    public static void SetActiveConnections(int count) => _activeConnections = count;
    public static void IncrementActiveConnections() => Interlocked.Increment(ref _activeConnections);
    public static void DecrementActiveConnections() => Interlocked.Decrement(ref _activeConnections);
    public static void SetQueuedEmails(int count) => _queuedEmails = count;
    public static void IncrementTotalEmails() => Interlocked.Increment(ref _totalEmailsInSession);
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileLogExporter.cs
SIZE: 2.92 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter(JsonTelemetryFileWriter? writer) : BaseExporter<LogRecord>
{
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs
SIZE: 6.42 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter(JsonTelemetryFileWriter? writer) : BaseExporter<Metric>
{
    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        MeterVersion = metric.MeterVersion,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?> ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags;
    }

    private static MetricValue ExtractValue(Metric metric, MetricPoint point)
    {
        var value = new MetricValue();

        try
        {
            switch (metric.MetricType)
            {
                case MetricType.LongSum:
                    value.LongValue = point.GetSumLong();
                    break;
                case MetricType.DoubleSum:
                    value.DoubleValue = point.GetSumDouble();
                    break;
                case MetricType.LongGauge:
                    value.LongValue = point.GetGaugeLastValueLong();
                    break;
                case MetricType.DoubleGauge:
                    value.DoubleValue = point.GetGaugeLastValueDouble();
                    break;
                case MetricType.Histogram:
                    value.DoubleValue = point.GetHistogramSum();
                    value.Count = (long)point.GetHistogramCount();
                    value.Buckets = ExtractHistogramBuckets(point);
                    break;
                case MetricType.ExponentialHistogram:
                    // ExponentialHistogramData in OpenTelemetry 1.14.0 uses different API
                    // Access count and sum through the MetricPoint directly
                    var expHistData = point.GetExponentialHistogramData();
                    value.Count = GetExponentialHistogramCount(expHistData);
                    value.DoubleValue = GetExponentialHistogramSum(expHistData);
                    break;
            }
        }
        catch
        {
            // If extraction fails, return partial data
        }

        return value;
    }

    private static long GetExponentialHistogramCount(ExponentialHistogramData data)
    {
        try
        {
            // Try accessing via reflection for API compatibility
            var countProperty = typeof(ExponentialHistogramData).GetProperty("Count");
            if (countProperty != null)
            {
                var val = countProperty.GetValue(data);
                if (val is long l) return l;
                if (val is ulong ul) return (long)ul;
                if (val is int i) return i;
            }

            // Try ZeroCount + positive/negative bucket counts as fallback
            var zeroCountProp = typeof(ExponentialHistogramData).GetProperty("ZeroCount");
            if (zeroCountProp != null)
            {
                var zeroCount = Convert.ToInt64(zeroCountProp.GetValue(data) ?? 0);
                return zeroCount; // This is a partial count but better than nothing
            }
        }
        catch
        {
            // Ignore reflection errors
        }

        return 0;
    }

    private static double GetExponentialHistogramSum(ExponentialHistogramData data)
    {
        try
        {
            // Try to access Sum via reflection for API compatibility
            var sumProperty = typeof(ExponentialHistogramData).GetProperty("Sum");
            if (sumProperty != null)
            {
                var val = sumProperty.GetValue(data);
                if (val is double d) return d;
            }
        }
        catch
        {
            // Ignore reflection errors
        }

        return 0.0;
    }

    private static List<HistogramBucket>? ExtractHistogramBuckets(MetricPoint point)
    {
        try
        {
            var buckets = new List<HistogramBucket>();
            foreach (var bucket in point.GetHistogramBuckets())
            {
                buckets.Add(new HistogramBucket
                {
                    ExplicitBound = bucket.ExplicitBound,
                    BucketCount = bucket.BucketCount
                });
            }
            return buckets.Count > 0 ? buckets : null;
        }
        catch
        {
            return null;
        }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public string? MeterVersion { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public MetricValue? Value { get; init; }
}

public record MetricValue
{
    public long? LongValue { get; set; }
    public double? DoubleValue { get; set; }
    public long? Count { get; set; }
    public List<HistogramBucket>? Buckets { get; set; }
}

public record HistogramBucket
{
    public double ExplicitBound { get; init; }
    public long BucketCount { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonFileTraceExporter.cs
SIZE: 3.81 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using System.Diagnostics;

using OpenTelemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter(JsonTelemetryFileWriter? writer) : BaseExporter<Activity>
{
    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList(),
                    Links = activity.Links.Select(l => new SpanLink
                    {
                        TraceId = l.Context.TraceId.ToString(),
                        SpanId = l.Context.SpanId.ToString()
                    }).ToList(),
                    Resource = new ResourceInfo
                    {
                        ServiceName = activity.GetTagItem("service.name")?.ToString(),
                        ServiceVersion = activity.GetTagItem("service.version")?.ToString()
                    }
                };

                writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures - telemetry should never crash the app
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
    public List<SpanLink>? Links { get; init; }
    public ResourceInfo? Resource { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}

public record SpanLink
{
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
}

public record ResourceInfo
{
    public string? ServiceName { get; init; }
    public string? ServiceVersion { get; init; }
}


================================================================================
FILE: MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs
SIZE: 5.48 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using System.Collections.Concurrent;
using System.Text.Json;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Thread-safe, async file writer for telemetry data in JSONL format.
/// Each telemetry record is written as a separate JSON line (JSONL format).
/// Gracefully handles write failures without crashing the application.
/// FIX: Uses async-safe timer pattern to prevent swallowed exceptions.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _baseDirectory;
    private readonly string _prefix;
    private readonly long _maxFileSizeBytes;
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly ConcurrentQueue<object> _buffer = new();
    private readonly Timer _flushTimer;
    private readonly JsonSerializerOptions _jsonOptions;
    private readonly CancellationTokenSource _cts = new();

    private string _currentDate = "";
    private string _currentFilePath = "";
    private int _fileSequence;
    private long _currentFileSize;
    private bool _disposed;
    private bool _writeEnabled = true;

    public JsonTelemetryFileWriter(
        string baseDirectory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _baseDirectory = baseDirectory;
        _prefix = prefix;
        _maxFileSizeBytes = maxFileSizeBytes;

        _jsonOptions = new JsonSerializerOptions
        {
            WriteIndented = false,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
        };

        try
        {
            Directory.CreateDirectory(_baseDirectory);
        }
        catch
        {
            _writeEnabled = false;
        }

        // FIX: Wrap the async call in a synchronous wrapper that handles exceptions
        _flushTimer = new Timer(
            _ => FlushTimerCallback(),
            null,
            flushInterval,
            flushInterval);
    }

    /// <summary>
    /// FIX: Synchronous wrapper that properly handles async FlushAsync exceptions.
    /// </summary>
    private void FlushTimerCallback()
    {
        if (_disposed || !_writeEnabled || _buffer.IsEmpty) return;

        try
        {
            // Use GetAwaiter().GetResult() in a try-catch to surface exceptions
            FlushAsync().GetAwaiter().GetResult();
        }
        catch (Exception)
        {
            // FIX: Log or count errors instead of silently swallowing
            // For telemetry writer, we degrade gracefully - disable writes after too many failures
            if (_buffer.Count > 10000)
            {
                _writeEnabled = false;
                while (_buffer.TryDequeue(out _)) { }
            }
        }
    }

    public void Enqueue(object record)
    {
        if (_disposed || !_writeEnabled) return;
        _buffer.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        if (_disposed || !_writeEnabled || _buffer.IsEmpty) return;

        if (!await _writeLock.WaitAsync(TimeSpan.FromSeconds(5)))
            return;

        try
        {
            var records = new List<object>();
            while (_buffer.TryDequeue(out var record))
            {
                records.Add(record);
            }

            foreach (var record in records)
            {
                await WriteRecordAsync(record);
            }
        }
        catch
        {
            if (_buffer.Count > 10000)
            {
                _writeEnabled = false;
                while (_buffer.TryDequeue(out _)) { }
            }
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordAsync(object record)
    {
        if (!_writeEnabled) return;

        try
        {
            string today = DateTime.UtcNow.ToString("yyyy-MM-dd");

            if (today != _currentDate || _currentFileSize >= _maxFileSizeBytes)
            {
                if (today != _currentDate)
                {
                    _currentDate = today;
                    _fileSequence = 0;
                }
                RotateFile();
            }

            string json = JsonSerializer.Serialize(record, record.GetType(), _jsonOptions);
            string line = json + Environment.NewLine;
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(line);

            if (_currentFileSize + bytes.Length > _maxFileSizeBytes && _currentFileSize > 0)
            {
                RotateFile();
            }

            await File.AppendAllTextAsync(_currentFilePath, line);
            _currentFileSize += bytes.Length;
        }
        catch
        {
            // Individual write failures are silently ignored
        }
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = Path.Combine(
            _baseDirectory,
            $"{_prefix}_{_currentDate}_{_fileSequence:D4}.jsonl");

        try
        {
            _currentFileSize = File.Exists(_currentFilePath) ? new FileInfo(_currentFilePath).Length : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _cts.Cancel();
        _flushTimer.Dispose();

        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }

        _writeLock.Dispose();
        _cts.Dispose();
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryConfiguration.cs
SIZE: 0.77 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs
SIZE: 3.16 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification
/// with graceful fallback behavior.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName = "MyImapDownloader")
    {
        // Try locations in order of preference
        var candidates = GetCandidateDirectories(appName);

        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }

        return null; // No writable location found - telemetry will be disabled
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        // 1. XDG_DATA_HOME (Linux/macOS) or LocalApplicationData (Windows)
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgDataHome))
        {
            yield return Path.Combine(xdgDataHome, appName, "telemetry");
        }

        // 2. Platform-specific user data directory
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        if (!string.IsNullOrEmpty(localAppData))
        {
            yield return Path.Combine(localAppData, appName, "telemetry");
        }

        // 3. XDG_STATE_HOME for state/log data (more appropriate for telemetry)
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgStateHome))
        {
            yield return Path.Combine(xdgStateHome, appName, "telemetry");
        }

        // 4. Fallback to ~/.local/state on Unix-like systems
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (!string.IsNullOrEmpty(homeDir))
        {
            yield return Path.Combine(homeDir, ".local", "state", appName, "telemetry");
            yield return Path.Combine(homeDir, ".local", "share", appName, "telemetry");
        }

        // 5. Directory relative to executable
        var exeDir = AppContext.BaseDirectory;
        if (!string.IsNullOrEmpty(exeDir))
        {
            yield return Path.Combine(exeDir, "telemetry");
        }

        // 6. Current working directory as last resort
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            // Attempt to create the directory
            Directory.CreateDirectory(path);

            // Verify we can write to it
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}


================================================================================
FILE: MyImapDownloader/Telemetry/TelemetryExtensions.cs
SIZE: 2.34 KB
MODIFIED: 2026-01-21 20:27:15
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

using MyImapDownloader.Core.Telemetry;

using OpenTelemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for configuring telemetry in MyImapDownloader.
/// </summary>
public static class TelemetryExtensions
{
    /// <summary>
    /// Adds telemetry services using the Core infrastructure.
    /// </summary>
    public static IServiceCollection AddTelemetry(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        return services.AddCoreTelemetry(
            configuration,
            DiagnosticsConfig.ServiceName,
            DiagnosticsConfig.ServiceVersion);
    }

    /// <summary>
    /// Adds telemetry logging.
    /// </summary>
    public static ILoggingBuilder AddTelemetryLogging(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);

        if (!config.EnableLogging)
            return builder;

        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        if (telemetryBaseDir == null)
            return builder;

        var logsDir = Path.Combine(telemetryBaseDir, "logs");
        Directory.CreateDirectory(logsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        try
        {
            var logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);

            builder.AddOpenTelemetry(options =>
            {
                options.IncludeFormattedMessage = true;
                options.IncludeScopes = true;
                options.ParseStateValues = true;
                options.AddProcessor(new BatchLogRecordExportProcessor(
                    new JsonFileLogExporter(logsWriter),
                    maxQueueSize: 2048,
                    scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                    exporterTimeoutMilliseconds: 30000,
                    maxExportBatchSize: 512));
            });
        }
        catch
        {
            // Continue without log telemetry
        }

        return builder;
    }
}


================================================================================
FILE: MyImapDownloader.Tests/DownloadOptionsTests.cs
SIZE: 2.35 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyImapDownloader.Tests;

public class DownloadOptionsTests
{
    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret",
            OutputDirectory = "/output"
        };

        await Assert.That(options.Server).IsEqualTo("imap.example.com");
        await Assert.That(options.Username).IsEqualTo("user@example.com");
        await Assert.That(options.Password).IsEqualTo("secret");
        await Assert.That(options.OutputDirectory).IsEqualTo("/output");
    }

    [Test]
    public async Task Port_DefaultsToZero()
    {
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test"
        };

        await Assert.That(options.Port).IsEqualTo(993);
    }

    [Test]
    public async Task AllFolders_DefaultsToFalse()
    {
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test"
        };

        await Assert.That(options.AllFolders).IsFalse();
    }

    [Test]
    public async Task Verbose_DefaultsToFalse()
    {
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test"
        };

        await Assert.That(options.Verbose).IsFalse();
    }

    [Test]
    public async Task StartDate_CanBeSet()
    {
        var date = new DateTime(2024, 1, 1);
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test",
            StartDate = date
        };

        await Assert.That(options.StartDate).IsEqualTo(date);
    }

    [Test]
    public async Task EndDate_CanBeSet()
    {
        var date = new DateTime(2024, 12, 31);
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test",
            EndDate = date
        };

        await Assert.That(options.EndDate).IsEqualTo(date);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/EmailDownloadExceptionTests.cs
SIZE: 1.54 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyImapDownloader.Tests;

public class EmailDownloadExceptionTests
{
    [Test]
    public async Task Constructor_SetsMessage()
    {
        var ex = new EmailDownloadException(
            "Test error",
            42,
            new InvalidOperationException("Inner"));

        await Assert.That(ex.Message).IsEqualTo("Test error");
    }

    [Test]
    public async Task Constructor_SetsMessageIndex()
    {
        var ex = new EmailDownloadException(
            "Test error",
            42,
            new InvalidOperationException("Inner"));

        await Assert.That(ex.MessageIndex).IsEqualTo(42);
    }

    [Test]
    public async Task Constructor_SetsInnerException()
    {
        var inner = new InvalidOperationException("Inner error");
        var ex = new EmailDownloadException("Test", 0, inner);

        await Assert.That(ex.InnerException).IsEqualTo(inner);
    }

    [Test]
    public async Task Exception_CanBeThrown()
    {
        var act = () =>
        {
            throw new EmailDownloadException(
                "Download failed",
                5,
                new IOException("Network error"));
        };

        await Assert.That(act).ThrowsException();
    }

    [Test]
    [Arguments(0)]
    [Arguments(1)]
    [Arguments(100)]
    [Arguments(int.MaxValue)]
    public async Task MessageIndex_AcceptsVariousValues(int index)
    {
        var ex = new EmailDownloadException(
            "Test",
            index,
            new Exception());

        await Assert.That(ex.MessageIndex).IsEqualTo(index);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/EmailStorageSanitizationTests.cs
SIZE: 2.42 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using MyImapDownloader;

public class EmailStorageSanitizationTests
{
    [Test]
    public async Task NormalizeMessageId_RemovesDirectorySeparators()
    {
        var raw = "playwright-test/check/suites/<id>@github.com";

        var normalized = EmailStorageService.NormalizeMessageId(raw);

        await Assert.That(normalized).DoesNotContain("/");
        await Assert.That(normalized).DoesNotContain("\\");
    }


    [Test]
    public async Task GenerateFilename_IsSingleFileName()
    {
        var date = DateTimeOffset.FromUnixTimeSeconds(1700000000);
        var safeId = "abc_def_ghi";

        var name = EmailStorageService.GenerateFilename(date, safeId);

        await Assert.That(Path.GetFileName(name)).IsEqualTo(name);
        await Assert.That(name).DoesNotContain("/");
    }

    [Test]
    public async Task SaveStreamAsync_DoesNotCreateDirectoriesFromMessageId()
    {
        using var tempDir = new TempDirectory();
        var logger = TestLogger.Create<EmailStorageService>();

        var service = new EmailStorageService(logger, tempDir.Path);
        await service.InitializeAsync(CancellationToken.None);

        var messageId = "foo/bar/baz@github.com";
        using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes("Subject: test\r\n\r\nbody"));

        await service.SaveStreamAsync(
            stream,
            messageId,
            DateTimeOffset.UtcNow,
            "Inbox",
            CancellationToken.None);

        var cur = Path.Combine(tempDir.Path, "Inbox", "cur");

        // No subdirectories under cur
        await Assert.That(Directory.GetDirectories(cur)).IsEmpty();
    }

    [Test]
    public async Task SaveStreamAsync_DuplicateMessage_ReturnsFalse()
    {
        using var tempDir = new TempDirectory();
        var logger = TestLogger.Create<EmailStorageService>();

        var service = new EmailStorageService(logger, tempDir.Path);
        await service.InitializeAsync(CancellationToken.None);

        var msg = "dup@test";
        var content = System.Text.Encoding.UTF8.GetBytes("Subject: dup\r\n\r\nbody");

        await Assert.That(await service.SaveStreamAsync(
            new MemoryStream(content), msg, DateTimeOffset.UtcNow, "Inbox", CancellationToken.None))
            .IsTrue();

        await Assert.That(await service.SaveStreamAsync(
            new MemoryStream(content), msg, DateTimeOffset.UtcNow, "Inbox", CancellationToken.None))
            .IsFalse();
    }


}


================================================================================
FILE: MyImapDownloader.Tests/EmailStorageServiceParsingTests.cs
SIZE: 3.63 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using System.Text;

using AwesomeAssertions;

namespace MyImapDownloader.Tests;

/// <summary>
/// Tests for EmailStorageService parsing behavior.
/// FIX: Validates that header-only parsing is being used.
/// </summary>
public class EmailStorageServiceParsingTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public EmailStorageServiceParsingTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"storage_parse_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task SaveStreamAsync_WithLargeAttachment_DoesNotLoadFullMessageInMemory()
    {
        // Arrange
        var logger = TestLogger.Create<EmailStorageService>();
        var service = new EmailStorageService(logger, _testDirectory);
        await service.InitializeAsync(CancellationToken.None);

        // Create a minimal email with headers only (simulating what we'd get from IMAP)
        // The actual body/attachment content is not loaded into memory
        var email = """
            Message-ID: <memory-test@example.com>
            Subject: Memory Test Email
            From: sender@example.com
            To: recipient@example.com
            Date: Fri, 03 Jan 2025 12:00:00 +0000
            Content-Type: text/plain

            This is the body text.
            """;

        using var stream = new MemoryStream(Encoding.UTF8.GetBytes(email));

        // Act - This should NOT load the full message into memory
        var result = await service.SaveStreamAsync(
            stream,
            "<memory-test@example.com>",
            DateTimeOffset.UtcNow,
            "Inbox",
            CancellationToken.None);

        // Assert
        await Assert.That(result).IsTrue();

        // Verify the file was created
        var curDir = Path.Combine(_testDirectory, "Inbox", "cur");
        var files = Directory.GetFiles(curDir, "*.eml");
        await Assert.That(files.Length).IsEqualTo(1);
    }

    [Test]
    public async Task SaveStreamAsync_ExtractsMetadataFromHeadersOnly()
    {
        // Arrange
        var logger = TestLogger.Create<EmailStorageService>();
        var service = new EmailStorageService(logger, _testDirectory);
        await service.InitializeAsync(CancellationToken.None);

        var email = """
            Message-ID: <metadata-test@example.com>
            Subject: Test Subject Line
            From: John Doe <john@example.com>
            To: Jane Doe <jane@example.com>
            Date: Fri, 03 Jan 2025 14:30:00 +0000
            Content-Type: text/plain

            Email body content that should not affect metadata extraction.
            """;

        using var stream = new MemoryStream(Encoding.UTF8.GetBytes(email));

        // Act
        await service.SaveStreamAsync(
            stream,
            "<metadata-test@example.com>",
            DateTimeOffset.UtcNow,
            "Inbox",
            CancellationToken.None);

        // Assert - Check that metadata file was created with correct content
        var curDir = Path.Combine(_testDirectory, "Inbox", "cur");
        var metaFiles = Directory.GetFiles(curDir, "*.meta.json");
        await Assert.That(metaFiles.Length).IsEqualTo(1);

        var metaContent = await File.ReadAllTextAsync(metaFiles[0]);
        metaContent.Should().Contain("Test Subject Line");
        metaContent.Should().Contain("john@example.com");
    }
}


================================================================================
FILE: MyImapDownloader.Tests/EmailStorageServiceTests.cs
SIZE: 6.90 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MimeKit;

namespace MyImapDownloader.Tests;

public sealed class EmailStorageServiceTests : IAsyncDisposable
{
    private readonly string _tempRoot;

    public EmailStorageServiceTests()
    {
        _tempRoot = Path.Combine(
            Path.GetTempPath(),
            "imap-tests-" + Guid.NewGuid().ToString("N"));

        Directory.CreateDirectory(_tempRoot);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Yield();

        try
        {
            if (Directory.Exists(_tempRoot))
                Directory.Delete(_tempRoot, recursive: true);
        }
        catch
        {
            // best-effort cleanup
        }
    }

    private static MemoryStream CreateSimpleEmail(
        string messageId,
        string subject = "test",
        string body = "hello")
    {
        var msg = new MimeMessage();
        msg.From.Add(new MailboxAddress("Sender", "sender@test.com"));
        msg.To.Add(new MailboxAddress("Receiver", "receiver@test.com"));
        msg.Subject = subject;
        msg.MessageId = messageId;
        msg.Body = new TextPart("plain") { Text = body };

        var ms = new MemoryStream();
        msg.WriteTo(ms);
        ms.Position = 0;
        return ms;
    }

    [Test]
    public async Task SaveStreamAsync_creates_maildir_structure()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<a@test>");

        var saved = await svc.SaveStreamAsync(
            stream,
            "<a@test>",
            DateTimeOffset.UtcNow,
            "Archives/2021",
            CancellationToken.None);

        saved.Should().BeTrue();

        var folder = Path.Combine(_tempRoot, "Archives_2021");
        Directory.Exists(Path.Combine(folder, "cur")).Should().BeTrue();
        Directory.Exists(Path.Combine(folder, "new")).Should().BeTrue();
        Directory.Exists(Path.Combine(folder, "tmp")).Should().BeTrue();
    }

    [Test]
    public async Task SaveStreamAsync_sanitizes_message_id_with_slashes()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        using var stream =
            CreateSimpleEmail("<kushalgmx/playwright/test@github.com>");

        var saved = await svc.SaveStreamAsync(
            stream,
            "<kushalgmx/playwright/test@github.com>",
            DateTimeOffset.UtcNow,
            "Archives/2021",
            CancellationToken.None);

        saved.Should().BeTrue();

        var cur = Path.Combine(_tempRoot, "Archives_2021", "cur");
        var files = Directory.GetFiles(cur, "*.eml");

        files.Should().ContainSingle();

        var fileName = Path.GetFileName(files[0]);

        fileName.Should().NotContain("/");
        fileName.Should().NotContain("\\");
    }


    [Test]
    public async Task SaveStreamAsync_does_not_throw_if_cur_directory_was_deleted()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        var folder = Path.Combine(_tempRoot, "Archives_2021");
        Directory.CreateDirectory(folder);

        var curPath = Path.Combine(folder, "cur");
        if (Directory.Exists(curPath))
            Directory.Delete(curPath, recursive: true);

        using var stream = CreateSimpleEmail("<b@test>");

        Func<Task> act = async () =>
        {
            await svc.SaveStreamAsync(
                stream,
                "<b@test>",
                DateTimeOffset.UtcNow,
                "Archives/2021",
                CancellationToken.None);
        };

        await act.Should().NotThrowAsync();
    }

    [Test]
    public async Task SaveStreamAsync_deduplicates_by_message_id()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        using var s1 = CreateSimpleEmail("<dup@test>");
        using var s2 = CreateSimpleEmail("<dup@test>");

        var first = await svc.SaveStreamAsync(
            s1,
            "<dup@test>",
            DateTimeOffset.UtcNow,
            "Inbox",
            CancellationToken.None);

        var second = await svc.SaveStreamAsync(
            s2,
            "<dup@test>",
            DateTimeOffset.UtcNow,
            "Inbox",
            CancellationToken.None);

        first.Should().BeTrue();
        second.Should().BeFalse();
    }

    [Test]
    public async Task SaveStreamAsync_writes_meta_json_sidecar()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<meta@test>");

        await svc.SaveStreamAsync(
            stream,
            "<meta@test>",
            DateTimeOffset.UtcNow,
            "Inbox",
            CancellationToken.None);

        var cur = Path.Combine(_tempRoot, "Inbox", "cur");
        var metaFiles = Directory.GetFiles(cur, "*.meta.json");

        metaFiles.Should().ContainSingle();

        var json = await File.ReadAllTextAsync(metaFiles[0]);
        json.Should().Contain("\"MessageId\"");
        json.Should().Contain("\"Folder\"");
    }

    [Test]
    public async Task GetLastUidAsync_resets_when_uidvalidity_changes()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        await svc.UpdateLastUidAsync(
            "Inbox",
            lastUid: 123,
            validity: 1,
            CancellationToken.None);

        var sameValidity = await svc.GetLastUidAsync(
            "Inbox",
            currentValidity: 1,
            CancellationToken.None);

        var changedValidity = await svc.GetLastUidAsync(
            "Inbox",
            currentValidity: 999,
            CancellationToken.None);

        sameValidity.Should().Be(123);
        changedValidity.Should().Be(0);
    }

    [Test]
    public async Task UpdateLastUidAsync_does_not_move_cursor_backwards()
    {
        var svc = new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _tempRoot);

        await svc.InitializeAsync(CancellationToken.None);

        await svc.UpdateLastUidAsync("Inbox", 100, 1, CancellationToken.None);
        await svc.UpdateLastUidAsync("Inbox", 50, 1, CancellationToken.None);

        var uid = await svc.GetLastUidAsync(
            "Inbox",
            currentValidity: 1,
            CancellationToken.None);

        uid.Should().Be(100);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/ImapConfigurationTests.cs
SIZE: 1.61 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

namespace MyImapDownloader.Tests;

public class ImapConfigurationTests
{
    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret"
        };

        await Assert.That(config.Server).IsEqualTo("imap.example.com");
        await Assert.That(config.Username).IsEqualTo("user@example.com");
        await Assert.That(config.Password).IsEqualTo("secret");
    }

    [Test]
    public async Task UseSsl_DefaultsToTrue()
    {
        var config = new ImapConfiguration
        {
            Server = "test",
            Username = "test",
            Password = "test"
        };

        await Assert.That(config.UseSsl).IsTrue();
    }

    [Test]
    public async Task Port_CanBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "test",
            Username = "test",
            Password = "test",
            Port = 143
        };

        await Assert.That(config.Port).IsEqualTo(143);
    }

    [Test]
    [Arguments(993, true)]
    [Arguments(143, false)]
    [Arguments(587, false)]
    public async Task CommonConfigurations_AreValid(int port, bool useSsl)
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret",
            Port = port,
            UseSsl = useSsl
        };

        await Assert.That(config.Port).IsEqualTo(port);
        await Assert.That(config.UseSsl).IsEqualTo(useSsl);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/MyImapDownloader.Tests.csproj
SIZE: 0.73 KB
MODIFIED: 2026-01-21 19:22:48
================================================================================

<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="AwesomeAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader\MyImapDownloader.csproj" />
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>
</Project>


================================================================================
FILE: MyImapDownloader.Tests/NormalizeMessageIdTests.cs
SIZE: 3.14 KB
MODIFIED: 2026-02-18 19:56:12
================================================================================

using AwesomeAssertions;

namespace MyImapDownloader.Tests;

/// <summary>
/// Tests for EmailStorageService.NormalizeMessageId edge cases,
/// particularly the hash truncation path for long IDs.
/// </summary>
public class NormalizeMessageIdTests
{
    [Test]
    public async Task NormalizeMessageId_LongId_TruncatesWithHash()
    {
        // Create a message ID longer than 100 characters
        var longId = "<" + new string('a', 120) + "@example.com>";
        var normalized = EmailStorageService.NormalizeMessageId(longId);

        await Assert.That(normalized.Length).IsLessThanOrEqualTo(100);
        // Should contain a hash suffix
        normalized.Should().Contain("_");
    }

    [Test]
    public async Task NormalizeMessageId_EmptyString_ReturnsUnknown()
    {
        var normalized = EmailStorageService.NormalizeMessageId("");

        await Assert.That(normalized).IsEqualTo("unknown");
    }

    [Test]
    public async Task NormalizeMessageId_AngleBrackets_Removed()
    {
        var normalized = EmailStorageService.NormalizeMessageId("<simple@test.com>");

        normalized.Should().NotContain("<");
        normalized.Should().NotContain(">");
    }

    [Test]
    public async Task NormalizeMessageId_SlashesReplaced()
    {
        var normalized = EmailStorageService.NormalizeMessageId("<org/repo/id@github.com>");

        normalized.Should().NotContain("/");
        normalized.Should().NotContain("\\");
    }

    [Test]
    public async Task NormalizeMessageId_ColonsReplaced()
    {
        var normalized = EmailStorageService.NormalizeMessageId("<urn:uuid:abc@test.com>");

        normalized.Should().NotContain(":");
    }

    [Test]
    public async Task NormalizeMessageId_ConsistentResults()
    {
        var id = "<test@example.com>";
        var first = EmailStorageService.NormalizeMessageId(id);
        var second = EmailStorageService.NormalizeMessageId(id);

        await Assert.That(first).IsEqualTo(second);
    }

    [Test]
    public async Task NormalizeMessageId_CaseInsensitive()
    {
        var lower = EmailStorageService.NormalizeMessageId("<TEST@EXAMPLE.COM>");

        lower.Should().Be(lower.ToLowerInvariant());
    }

    [Test]
    public async Task SanitizeForFilename_SpecialCharsRemoved()
    {
        var result = EmailStorageService.SanitizeForFilename("hello world! @#$%", 50);

        result.Should().NotContain("!");
        result.Should().NotContain("@");
        result.Should().NotContain("#");
    }

    [Test]
    public async Task SanitizeForFilename_RespectsMaxLength()
    {
        var input = new string('a', 200);
        var result = EmailStorageService.SanitizeForFilename(input, 50);

        await Assert.That(result.Length).IsLessThanOrEqualTo(50);
    }

    [Test]
    public async Task ComputeHash_DifferentInputs_DifferentHashes()
    {
        var hash1 = EmailStorageService.ComputeHash("input1");
        var hash2 = EmailStorageService.ComputeHash("input2");

        hash1.Should().NotBe(hash2);
    }

    [Test]
    public async Task ComputeHash_ReturnsLowercaseHex()
    {
        var hash = EmailStorageService.ComputeHash("test");

        hash.Should().MatchRegex("^[0-9a-f]+$");
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Services/EmailStorageSanitizationTests.cs
SIZE: 1.82 KB
MODIFIED: 2026-01-21 19:37:49
================================================================================

using AwesomeAssertions;

namespace MyImapDownloader.Tests.Services;

public class EmailStorageSanitizationTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new();

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    [Test]
    [Arguments("<simple@test.com>", "simple_test.com")]
    [Arguments("<path/with/slashes@test.com>", "path_with_slashes_test.com")]
    [Arguments("<spaces here@test.com>", "spaces_here_test.com")]
    public void NormalizeMessageId_SanitizesCorrectly(string input, string expected)
    {
        var result = EmailStorageService.NormalizeMessageId(input);
        result.Should().NotContain("/");
        result.Should().NotContain("\\");
        result.Should().NotContain("<");
        result.Should().NotContain(">");
    }

    [Test]
    public async Task SanitizeForFilename_TruncatesLongInput()
    {
        var longInput = new string('a', 200);
        var result = EmailStorageService.SanitizeForFilename(longInput, 50);

        await Assert.That(result.Length).IsLessThanOrEqualTo(50);
    }

    [Test]
    public void SanitizeForFilename_RemovesInvalidChars()
    {
        var input = "test<>:\"/\\|?*file";
        var result = EmailStorageService.SanitizeForFilename(input, 100);

        result.Should().NotContain("<");
        result.Should().NotContain(">");
        result.Should().NotContain(":");
        result.Should().NotContain("/");
        result.Should().NotContain("\\");
    }

    [Test]
    public async Task GenerateFilename_IsValidFilename()
    {
        var date = DateTimeOffset.FromUnixTimeSeconds(1700000000);
        var filename = EmailStorageService.GenerateFilename(date, "test_id");

        await Assert.That(Path.GetFileName(filename)).IsEqualTo(filename);
        filename.Should().EndWith(".eml");
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Services/EmailStorageServiceTests.cs
SIZE: 6.39 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Logging.Abstractions;

using MimeKit;

namespace MyImapDownloader.Tests.Services;

public class EmailStorageServiceTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new();

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    private EmailStorageService CreateService()
    {
        return new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _temp.Path);
    }

    private static MemoryStream CreateSimpleEmail(
        string messageId,
        string subject = "Test",
        string body = "Hello")
    {
        var msg = new MimeMessage();
        msg.From.Add(new MailboxAddress("Sender", "sender@test.com"));
        msg.To.Add(new MailboxAddress("Receiver", "receiver@test.com"));
        msg.Subject = subject;
        msg.MessageId = messageId;
        msg.Body = new TextPart("plain") { Text = body };

        var ms = new MemoryStream();
        msg.WriteTo(ms);
        ms.Position = 0;
        return ms;
    }

    [Test]
    public async Task InitializeAsync_CreatesDatabase()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        var dbPath = Path.Combine(_temp.Path, "index.v1.db");
        await Assert.That(File.Exists(dbPath)).IsTrue();
    }

    [Test]
    public async Task SaveStreamAsync_CreatesMaildirStructure()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<test1@example.com>");
        var saved = await service.SaveStreamAsync(
            stream,
            "<test1@example.com>",
            DateTimeOffset.UtcNow,
            "INBOX",
            CancellationToken.None);

        await Assert.That(saved).IsTrue();

        var inboxPath = Path.Combine(_temp.Path, "INBOX");
        await Assert.That(Directory.Exists(Path.Combine(inboxPath, "cur"))).IsTrue();
        await Assert.That(Directory.Exists(Path.Combine(inboxPath, "new"))).IsTrue();
        await Assert.That(Directory.Exists(Path.Combine(inboxPath, "tmp"))).IsTrue();
    }

    [Test]
    public async Task SaveStreamAsync_DeduplicatesByMessageId()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream1 = CreateSimpleEmail("<dup@test.com>");
        using var stream2 = CreateSimpleEmail("<dup@test.com>");

        var first = await service.SaveStreamAsync(
            stream1, "<dup@test.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);
        var second = await service.SaveStreamAsync(
            stream2, "<dup@test.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);

        await Assert.That(first).IsTrue();
        await Assert.That(second).IsFalse();
    }

    [Test]
    public async Task SaveStreamAsync_CreatesSidecarMetadata()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<meta@test.com>", "Test Subject");
        await service.SaveStreamAsync(
            stream, "<meta@test.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);

        var curPath = Path.Combine(_temp.Path, "INBOX", "cur");
        var metaFiles = Directory.GetFiles(curPath, "*.meta.json");

        await Assert.That(metaFiles.Length).IsEqualTo(1);

        var content = await File.ReadAllTextAsync(metaFiles[0]);
        content.Should().Contain("Test Subject");
    }

    [Test]
    public async Task SaveStreamAsync_SanitizesMessageIdWithSlashes()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<user/repo/test@github.com>");
        var saved = await service.SaveStreamAsync(
            stream, "<user/repo/test@github.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);

        await Assert.That(saved).IsTrue();

        var curPath = Path.Combine(_temp.Path, "INBOX", "cur");
        var files = Directory.GetFiles(curPath, "*.eml");
        await Assert.That(files.Length).IsEqualTo(1);

        var fileName = Path.GetFileName(files[0]);
        fileName.Should().NotContain("/");
        fileName.Should().NotContain("\\");
    }

    [Test]
    public async Task GetLastUidAsync_ReturnsZero_WhenNoSyncState()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        var lastUid = await service.GetLastUidAsync("INBOX", 12345, CancellationToken.None);

        await Assert.That(lastUid).IsEqualTo(0);
    }

    [Test]
    public async Task UpdateLastUidAsync_PersistsUid()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        await service.UpdateLastUidAsync("INBOX", 100, 12345, CancellationToken.None);
        var lastUid = await service.GetLastUidAsync("INBOX", 12345, CancellationToken.None);

        await Assert.That(lastUid).IsEqualTo(100);
    }

    [Test]
    public async Task GetLastUidAsync_ResetsOnUidValidityChange()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        await service.UpdateLastUidAsync("INBOX", 100, 12345, CancellationToken.None);
        var sameValidity = await service.GetLastUidAsync("INBOX", 12345, CancellationToken.None);
        var changedValidity = await service.GetLastUidAsync("INBOX", 99999, CancellationToken.None);

        await Assert.That(sameValidity).IsEqualTo(100);
        await Assert.That(changedValidity).IsEqualTo(0);
    }

    [Test]
    public async Task NormalizeMessageId_RemovesInvalidCharacters()
    {
        var normalized = EmailStorageService.NormalizeMessageId("<test/path:id@example.com>");

        normalized.Should().NotContain("/");
        normalized.Should().NotContain(":");
        normalized.Should().NotContain("<");
        normalized.Should().NotContain(">");
    }

    [Test]
    public async Task ComputeHash_ReturnsConsistentHash()
    {
        var hash1 = EmailStorageService.ComputeHash("test input");
        var hash2 = EmailStorageService.ComputeHash("test input");
        var hash3 = EmailStorageService.ComputeHash("different input");

        await Assert.That(hash1).IsEqualTo(hash2);
        await Assert.That(hash1).IsNotEqualTo(hash3);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/ActivityExtensionsTests.cs
SIZE: 5.56 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using System.Diagnostics;

using AwesomeAssertions;

using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class ActivityExtensionsTests : IDisposable
{
    private readonly ActivitySource _activitySource;
    private readonly ActivityListener _listener;
    private readonly List<Activity> _recordedActivities = [];

    public ActivityExtensionsTests()
    {
        _activitySource = new ActivitySource("TestSource");
        _listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded,
            ActivityStopped = activity => _recordedActivities.Add(activity)
        };
        ActivitySource.AddActivityListener(_listener);
    }

    public void Dispose()
    {
        _listener.Dispose();
        _activitySource.Dispose();
    }

    [Test]
    public async Task RecordException_AddsExceptionEvent_ToActivity()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new InvalidOperationException("Test error message");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(1);

        var exceptionEvent = events[0];
        await Assert.That(exceptionEvent.Name).IsEqualTo("exception");
    }

    [Test]
    public async Task RecordException_IncludesExceptionType()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new ArgumentNullException("paramName");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.type");
        tags["exception.type"].Should().Be(typeof(ArgumentNullException).FullName);
    }

    [Test]
    public async Task RecordException_IncludesExceptionMessage()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Specific error details");

        activity.RecordException(exception);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.message");
        tags["exception.message"]!.ToString().Should().Contain("Specific error details");
    }

    [Test]
    public async Task RecordException_IncludesStackTrace_WhenAvailable()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        Exception? capturedException = null;
        try
        {
            throw new Exception("Error with stack trace");
        }
        catch (Exception ex)
        {
            capturedException = ex;
        }

        activity.RecordException(capturedException!);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        tags.Should().ContainKey("exception.stacktrace");
        tags["exception.stacktrace"]!.ToString().Should().Contain("RecordException_IncludesStackTrace");
    }

    [Test]
    public async Task RecordException_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.RecordException(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_WithNullException_DoesNotThrow()
    {
        using var activity = _activitySource.StartActivity("TestOperation");

        // Should not throw
        activity.RecordException(null!);

        var events = activity!.Events.ToList();
        await Assert.That(events.Count).IsEqualTo(0);
    }

    [Test]
    public async Task SetErrorStatus_SetsStatusToError()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Operation failed");

        activity.SetErrorStatus(exception);

        await Assert.That(activity!.Status).IsEqualTo(ActivityStatusCode.Error);
    }

    [Test]
    public async Task SetErrorStatus_IncludesExceptionMessage_InStatusDescription()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var exception = new Exception("Detailed failure reason");

        activity.SetErrorStatus(exception);

        activity!.StatusDescription.Should().Contain("Detailed failure reason");
    }

    [Test]
    public async Task SetErrorStatus_WithNullActivity_DoesNotThrow()
    {
        Activity? nullActivity = null;
        var exception = new Exception("Test");

        // Should not throw
        nullActivity.SetErrorStatus(exception);

        // If we reach here, the test passed
        await Assert.That(nullActivity).IsNull();
    }

    [Test]
    public async Task RecordException_HandlesNestedExceptions()
    {
        using var activity = _activitySource.StartActivity("TestOperation");
        var inner = new ArgumentException("Inner error");
        var outer = new InvalidOperationException("Outer error", inner);

        activity.RecordException(outer);

        var events = activity!.Events.ToList();
        var tags = events[0].Tags.ToDictionary(t => t.Key, t => t.Value);

        // Should record the outer exception's details
        tags["exception.type"].Should().Be(typeof(InvalidOperationException).FullName);
        tags["exception.message"]!.ToString().Should().Contain("Outer error");
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/DiagnosticsConfigTests.cs
SIZE: 2.50 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using System.Diagnostics;

using AwesomeAssertions;

using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class DiagnosticsConfigTests
{
    [Test]
    public async Task ServiceName_IsExpectedValue()
    {
        var serviceName = DiagnosticsConfig.ServiceName;
        await Assert.That(serviceName).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_HasCorrectName()
    {
        var source = DiagnosticsConfig.ActivitySource;

        source.Should().NotBeNull();
        await Assert.That(source.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task Meter_HasCorrectName()
    {
        var meter = DiagnosticsConfig.Meter;

        meter.Should().NotBeNull();
        await Assert.That(meter.Name).IsEqualTo("MyImapDownloader");
    }

    [Test]
    public async Task ActivitySource_CanCreateActivity()
    {
        // Need a listener to actually create activities
        using var listener = new ActivityListener
        {
            ShouldListenTo = source => source.Name == DiagnosticsConfig.ServiceName,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = DiagnosticsConfig.ActivitySource.StartActivity("TestOperation");

        activity.Should().NotBeNull();
        await Assert.That(activity!.OperationName).IsEqualTo("TestOperation");
    }

    [Test]
    public async Task Meter_CanCreateCounter()
    {
        var counter = DiagnosticsConfig.Meter.CreateCounter<long>("test_counter");

        counter.Should().NotBeNull();
        counter.Name.Should().Be("test_counter");
    }

    [Test]
    public async Task Meter_CanCreateHistogram()
    {
        var histogram = DiagnosticsConfig.Meter.CreateHistogram<double>("test_histogram");

        histogram.Should().NotBeNull();
        histogram.Name.Should().Be("test_histogram");
    }

    [Test]
    public async Task ActivitySource_IsSingleton()
    {
        var source1 = DiagnosticsConfig.ActivitySource;
        var source2 = DiagnosticsConfig.ActivitySource;

        var areSame = ReferenceEquals(source1, source2);
        await Assert.That(areSame).IsTrue();
    }

    [Test]
    public async Task Meter_IsSingleton()
    {
        var meter1 = DiagnosticsConfig.Meter;
        var meter2 = DiagnosticsConfig.Meter;

        var areSame = ReferenceEquals(meter1, meter2);
        await Assert.That(areSame).IsTrue();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/JsonExporterTests.cs
SIZE: 4.74 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using System.Diagnostics;

using AwesomeAssertions;

using MyImapDownloader.Telemetry;

using OpenTelemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonFileTraceExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonFileTraceExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"trace_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix = "traces")
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileTraceExporter(null);

        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }

    [Test]
    public async Task Export_WithWriter_EnqueuesRecords()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        using var activitySource = new ActivitySource("Test");
        using var listener = new ActivityListener
        {
            ShouldListenTo = _ => true,
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded
        };
        ActivitySource.AddActivityListener(listener);

        using var activity = activitySource.StartActivity("ExportTest");
        activity?.SetTag("test.key", "test.value");
        activity?.Stop();

        var batch = new Batch<Activity>([activity!], 1);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);

        // Flush and verify
        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("ExportTest");
    }

    [Test]
    public async Task Export_ReturnsSuccess_EvenOnError()
    {
        var writer = CreateWriter();
        var exporter = new JsonFileTraceExporter(writer);

        // Empty batch should still return success
        var batch = new Batch<Activity>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileLogExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileLogExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"log_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileLogExporter(null);

        // Test with empty batch
        var batch = new Batch<OpenTelemetry.Logs.LogRecord>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}

public class JsonFileMetricsExporterTests : IAsyncDisposable
{
    private readonly string _testDirectory;

    public JsonFileMetricsExporterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"metrics_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    [Test]
    public async Task Export_WithNullWriter_ReturnsSuccess()
    {
        var exporter = new JsonFileMetricsExporter(null);

        var batch = new Batch<OpenTelemetry.Metrics.Metric>([], 0);
        var result = exporter.Export(batch);

        await Assert.That(result).IsEqualTo(ExportResult.Success);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/JsonTelemetryFileWriterTests.cs
SIZE: 5.63 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using System.Text.Json;

using AwesomeAssertions;

using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class JsonTelemetryFileWriterTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public JsonTelemetryFileWriterTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"telemetry_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string? subDir = null, string prefix = "test", long maxSize = 1024 * 1024)
    {
        var dir = subDir != null ? Path.Combine(_testDirectory, subDir) : _testDirectory;
        var writer = new JsonTelemetryFileWriter(dir, prefix, maxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_CreatesDirectory_WhenItDoesNotExist()
    {
        var newDir = Path.Combine(_testDirectory, "new_subdir");

        var writer = new JsonTelemetryFileWriter(newDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        await Assert.That(Directory.Exists(newDir)).IsTrue();
    }

    [Test]
    public async Task Enqueue_DoesNotThrow_WhenCalled()
    {
        var writer = CreateWriter();

        var record = new { Message = "Test", Timestamp = DateTime.UtcNow };

        // Should not throw
        writer.Enqueue(record);

        // If we get here, the test passed
        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task FlushAsync_WritesEnqueuedRecords_ToFile()
    {
        var writer = CreateWriter();

        var record = new TestRecord { Id = 1, Message = "Hello" };
        writer.Enqueue(record);

        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);

        var content = await File.ReadAllTextAsync(files[0]);
        content.Should().Contain("Hello");
        content.Should().Contain("\"id\":1");
    }

    [Test]
    public async Task FlushAsync_WritesMultipleRecords_InJsonlFormat()
    {
        var writer = CreateWriter();

        writer.Enqueue(new TestRecord { Id = 1, Message = "First" });
        writer.Enqueue(new TestRecord { Id = 2, Message = "Second" });
        writer.Enqueue(new TestRecord { Id = 3, Message = "Third" });

        await writer.FlushAsync();

        var files = Directory.GetFiles(_testDirectory, "*.jsonl");
        var lines = await File.ReadAllLinesAsync(files[0]);

        // Each record should be on its own line (JSONL format)
        await Assert.That(lines.Length).IsEqualTo(3);

        // Each line should be valid JSON
        foreach (var line in lines)
        {
            var parsed = JsonSerializer.Deserialize<TestRecord>(line);
            parsed.Should().NotBeNull();
        }
    }

    [Test]
    public async Task Dispose_CanBeCalledMultipleTimes()
    {
        var writer = new JsonTelemetryFileWriter(_testDirectory, "dispose", 1024 * 1024, TimeSpan.FromSeconds(30));

        // Should not throw when called multiple times
        writer.Dispose();
        writer.Dispose();
        writer.Dispose();

        await Assert.That(writer).IsNotNull();
    }

    [Test]
    public async Task Dispose_FlushesRemainingRecords()
    {
        var subDir = Path.Combine(_testDirectory, "dispose_flush");
        Directory.CreateDirectory(subDir);

        var writer = new JsonTelemetryFileWriter(subDir, "test", 1024 * 1024, TimeSpan.FromSeconds(30));

        writer.Enqueue(new { Test = true });

        // Force a flush before dispose to ensure it works
        await writer.FlushAsync();

        writer.Dispose();

        var files = Directory.GetFiles(subDir, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }

    [Test]
    public async Task FlushAsync_WithEmptyBuffer_DoesNotCreateFile()
    {
        var emptyDir = Path.Combine(_testDirectory, "empty");
        Directory.CreateDirectory(emptyDir);

        var writer = CreateWriter("empty");

        await writer.FlushAsync();

        var files = Directory.GetFiles(emptyDir, "*.jsonl");
        await Assert.That(files.Length).IsEqualTo(0);
    }

    [Test]
    public async Task FileRotation_OccursWhenSizeExceeded()
    {
        // Small max file size to trigger rotation quickly
        const long smallMaxSize = 500; // 500 bytes
        var rotateDir = Path.Combine(_testDirectory, "rotate");
        Directory.CreateDirectory(rotateDir);

        var writer = new JsonTelemetryFileWriter(rotateDir, "rotate", smallMaxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);

        // Write enough data to trigger rotation (each record ~50-100 bytes)
        for (int i = 0; i < 20; i++)
        {
            writer.Enqueue(new TestRecord { Id = i, Message = $"Record number {i} with some padding text" });
        }

        await writer.FlushAsync();

        var files = Directory.GetFiles(rotateDir, "rotate_*.jsonl");

        // Should have created multiple files due to rotation
        await Assert.That(files.Length).IsGreaterThan(1);
    }

    private record TestRecord
    {
        public int Id { get; init; }
        public string? Message { get; init; }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryConfigurationTests.cs
SIZE: 2.64 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreReasonable()
    {
        var config = new TelemetryConfiguration();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.ServiceVersion).IsEqualTo("1.0.0");
        await Assert.That(config.EnableTracing).IsTrue();
        await Assert.That(config.EnableMetrics).IsTrue();
        await Assert.That(config.EnableLogging).IsTrue();
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(25);
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(5);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(15);
    }

    [Test]
    public async Task MaxFileSizeBytes_CalculatesCorrectly()
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = 10 };

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(10L * 1024L * 1024L);
    }

    [Test]
    [Arguments(1)]
    [Arguments(25)]
    [Arguments(100)]
    [Arguments(1024)]
    public async Task MaxFileSizeBytes_ScalesWithMB(int megabytes)
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = megabytes };
        var expected = (long)megabytes * 1024L * 1024L;

        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(expected);
    }

    [Test]
    public async Task SectionName_IsExpectedValue()
    {
        var sectionName = TelemetryConfiguration.SectionName;
        await Assert.That(sectionName).IsEqualTo("Telemetry");
    }

    [Test]
    public async Task AllPropertiesAreMutable()
    {
        var config = new TelemetryConfiguration
        {
            ServiceName = "CustomService",
            ServiceVersion = "2.0.0",
            OutputDirectory = "/custom/path",
            MaxFileSizeMB = 50,
            EnableTracing = false,
            EnableMetrics = false,
            EnableLogging = false,
            FlushIntervalSeconds = 10,
            MetricsExportIntervalSeconds = 30
        };

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.OutputDirectory).IsEqualTo("/custom/path");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableTracing).IsFalse();
        await Assert.That(config.EnableMetrics).IsFalse();
        await Assert.That(config.EnableLogging).IsFalse();
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(10);
        await Assert.That(config.MetricsExportIntervalSeconds).IsEqualTo(30);
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryDirectoryResolverTests.cs
SIZE: 3.41 KB
MODIFIED: 2026-01-21 20:27:05
================================================================================

using AwesomeAssertions;

using MyImapDownloader.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryDirectoryResolverTests
{
    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsNonNullPath()
    {
        // On any normal system, at least one location should be writable
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        // This could be null in a sandboxed environment, but typically won't be
        // We're testing that the method runs without throwing
        result.Should().NotBeNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_ReturnsWritablePath_WhenSuccessful()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory("TestApp");

        if (result != null)
        {
            // If a path is returned, it should be writable
            var testFile = Path.Combine(result, $".test_{Guid.NewGuid():N}");
            try
            {
                await File.WriteAllTextAsync(testFile, "test");
                await Assert.That(File.Exists(testFile)).IsTrue();
                File.Delete(testFile);
            }
            finally
            {
                if (File.Exists(testFile))
                    File.Delete(testFile);
            }
        }
        else
        {
            // Null is acceptable if no writable location exists
            await Assert.That(result).IsNull();
        }
    }

    [Test]
    public async Task ResolveTelemetryDirectory_IncludesAppName_InPath()
    {
        const string appName = "MyUniqueTestApp";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        if (result != null)
        {
            result.Should().Contain(appName);
        }

        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_UsesDefaultAppName_WhenNotSpecified()
    {
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory();

        // Should use "MyImapDownloader" as default
        if (result != null)
        {
            result.Should().Contain("MyImapDownloader");
        }

        await Assert.That(result).IsNotNull();
    }

    [Test]
    public async Task ResolveTelemetryDirectory_CreatesDirectory_WhenItDoesNotExist()
    {
        var uniqueAppName = $"TestApp_{Guid.NewGuid():N}";
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(uniqueAppName);

        try
        {
            if (result != null)
            {
                await Assert.That(Directory.Exists(result)).IsTrue();
            }
        }
        finally
        {
            // Cleanup
            if (result != null && Directory.Exists(result))
            {
                try { Directory.Delete(result, recursive: true); } catch { }
            }
        }
    }

    [Test]
    [Arguments("SimpleApp")]
    [Arguments("App-With-Dashes")]
    [Arguments("App_With_Underscores")]
    [Arguments("AppWithNumbers123")]
    public async Task ResolveTelemetryDirectory_HandlesVariousAppNames(string appName)
    {
        // Should not throw for valid app names
        var result = TelemetryDirectoryResolver.ResolveTelemetryDirectory(appName);

        result.Should().NotBeNull();

        // Cleanup if directory was created
        if (result != null && Directory.Exists(result))
        {
            try { Directory.Delete(result, recursive: true); } catch { }
        }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryExtensionsTests.cs
SIZE: 4.78 KB
MODIFIED: 2026-01-22 07:04:25
================================================================================

using AwesomeAssertions;

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

using MyImapDownloader.Core.Telemetry;
using MyImapDownloader.Telemetry;

// IMPORTANT: Use the CORE TelemetryConfiguration, which is what AddCoreTelemetry registers
using TelemetryConfiguration = MyImapDownloader.Core.Telemetry.TelemetryConfiguration;

namespace MyImapDownloader.Tests.Telemetry;

/// <summary>
/// Tests for TelemetryExtensions.
/// </summary>
public class TelemetryExtensionsTests
{
    [Test]
    public async Task AddTelemetry_RegistersTelemetryConfiguration()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        // AddCoreTelemetry registers Core.TelemetryConfiguration
        var config = provider.GetService<TelemetryConfiguration>();
        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_RegistersWriterProvider()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_BindsConfigurationValues()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:ServiceName"] = "CustomService",
            ["Telemetry:ServiceVersion"] = "2.0.0",
            ["Telemetry:MaxFileSizeMB"] = "50",
            ["Telemetry:EnableTracing"] = "true",
            ["Telemetry:EnableMetrics"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();

        await Assert.That(config.ServiceName).IsEqualTo("CustomService");
        await Assert.That(config.ServiceVersion).IsEqualTo("2.0.0");
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(50);
        await Assert.That(config.EnableMetrics).IsFalse();
    }

    [Test]
    public async Task AddTelemetry_WithDisabledTelemetry_RegistersNullProvider()
    {
        var configData = new Dictionary<string, string?>
        {
            ["Telemetry:EnableTracing"] = "false",
            ["Telemetry:EnableMetrics"] = "false",
            ["Telemetry:EnableLogging"] = "false"
        };

        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder()
            .AddInMemoryCollection(configData)
            .Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var writerProvider = provider.GetService<ITelemetryWriterProvider>();
        writerProvider.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_CanBeCalledMultipleTimes_WithoutError()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        // Should not throw on multiple calls
        services.AddTelemetry(configuration);
        services.AddTelemetry(configuration);

        var provider = services.BuildServiceProvider();
        var config = provider.GetService<TelemetryConfiguration>();

        config.Should().NotBeNull();
    }

    [Test]
    public async Task AddTelemetry_WithEmptyConfiguration_UsesDefaults()
    {
        var services = new ServiceCollection();
        var configuration = new ConfigurationBuilder().Build();

        services.AddTelemetry(configuration);
        var provider = services.BuildServiceProvider();

        var config = provider.GetRequiredService<TelemetryConfiguration>();

        // Core's default is "MyImapDownloader" because AddTelemetry passes DiagnosticsConfig.ServiceName
        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.EnableTracing).IsTrue();
    }

    [Test]
    public async Task AddTelemetry_ReturnsServiceCollection_ForChaining()
    {
        var services = new ServiceCollection();
        var configuration = CreateConfiguration();

        var result = services.AddTelemetry(configuration);

        result.Should().BeSameAs(services);
    }

    private static IConfiguration CreateConfiguration()
    {
        return new ConfigurationBuilder()
            .AddInMemoryCollection(new Dictionary<string, string?>
            {
                ["Telemetry:ServiceName"] = "TestService"
            })
            .Build();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/Telemetry/TelemetryWriterProviderTests.cs
SIZE: 3.47 KB
MODIFIED: 2026-01-21 19:36:35
================================================================================

using AwesomeAssertions;

using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Tests.Telemetry;

public class TelemetryWriterProviderTests : IAsyncDisposable
{
    private readonly string _testDirectory;
    private readonly List<JsonTelemetryFileWriter> _writers = new();

    public TelemetryWriterProviderTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"provider_test_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }

        await Task.Delay(100);

        try
        {
            if (Directory.Exists(_testDirectory))
            {
                Directory.Delete(_testDirectory, recursive: true);
            }
        }
        catch { }
    }

    private JsonTelemetryFileWriter CreateWriter(string prefix)
    {
        var writer = new JsonTelemetryFileWriter(
            _testDirectory, prefix, 1024 * 1024, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Constructor_AcceptsAllWriters()
    {
        var traceWriter = CreateWriter("traces");
        var metricsWriter = CreateWriter("metrics");
        var logsWriter = CreateWriter("logs");

        var provider = new TelemetryWriterProvider(traceWriter, metricsWriter, logsWriter);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsEqualTo(metricsWriter);
        await Assert.That(provider.LogsWriter).IsEqualTo(logsWriter);
    }

    [Test]
    public async Task Constructor_AcceptsNullWriters()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task Constructor_AcceptsMixedNullAndNonNullWriters()
    {
        var traceWriter = CreateWriter("traces");

        var provider = new TelemetryWriterProvider(traceWriter, null, null);

        await Assert.That(provider.TraceWriter).IsEqualTo(traceWriter);
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task ImplementsInterface()
    {
        var provider = new TelemetryWriterProvider(null, null, null);

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task NullProvider_ReturnsAllNull()
    {
        var provider = new NullTelemetryWriterProvider();

        await Assert.That(provider.TraceWriter).IsNull();
        await Assert.That(provider.MetricsWriter).IsNull();
        await Assert.That(provider.LogsWriter).IsNull();
    }

    [Test]
    public async Task NullProvider_ImplementsInterface()
    {
        var provider = new NullTelemetryWriterProvider();

        provider.Should().BeAssignableTo<ITelemetryWriterProvider>();
    }

    [Test]
    public async Task ProvidersAreInterchangeable()
    {
        ITelemetryWriterProvider provider1 = new NullTelemetryWriterProvider();
        ITelemetryWriterProvider provider2 = new TelemetryWriterProvider(null, null, null);

        // Both should work identically through the interface
        await Assert.That(provider1.TraceWriter).IsNull();
        await Assert.That(provider2.TraceWriter).IsNull();
    }
}


================================================================================
FILE: MyImapDownloader.Tests/TempDirectory.cs
SIZE: 0.56 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

public sealed class TempDirectory : IDisposable
{
    public string Path { get; }

    public TempDirectory()
    {
        Path = System.IO.Path.Combine(
            System.IO.Path.GetTempPath(),
            "MyImapDownloaderTests",
            Guid.NewGuid().ToString("N"));

        Directory.CreateDirectory(Path);
    }

    public void Dispose()
    {
        try
        {
            if (Directory.Exists(Path))
                Directory.Delete(Path, recursive: true);
        }
        catch
        {
            // Never throw from Dispose in tests
        }
    }
}


================================================================================
FILE: MyImapDownloader.Tests/TestLogger.cs
SIZE: 0.82 KB
MODIFIED: 2026-01-21 19:34:16
================================================================================

using Microsoft.Extensions.Logging;

public static class TestLogger
{
    public static ILogger<T> Create<T>() => new NullLogger<T>();

    private sealed class NullLogger<T> : ILogger<T>
    {
        public IDisposable? BeginScope<TState>(TState state)
            where TState : notnull
        {
            return NullScope.Instance;
        }

        public bool IsEnabled(LogLevel logLevel) => false;

        public void Log<TState>(
            LogLevel logLevel,
            EventId eventId,
            TState state,
            Exception? exception,
            Func<TState, Exception?, string> formatter)
        {
            // Intentionally no-op
        }
    }

    private sealed class NullScope : IDisposable
    {
        public static readonly NullScope Instance = new();
        public void Dispose() { }
    }
}


===============================================================================
EXPORT COMPLETED: Wed Feb 18 08:00:59 PM EST 2026
Total Files Exported: 109
Output File: /home/kushal/src/dotnet/MyImapDownloader/docs/llm/dump.txt
===============================================================================
