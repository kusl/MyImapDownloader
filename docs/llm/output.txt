kushal@fedora:~/src/rust/podman-linux/mesh-communication$ cd ~/src/dotnet/MyImapDownloader/; time dotnet format; time bash export.sh; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;

real	0m7.545s
user	0m17.644s
sys	0m0.941s
Starting project export...
Project Path: /home/kushal/src/dotnet/MyImapDownloader
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 76 files to export
Processing (1/76): Directory.Build.props
Processing (2/76): Directory.Packages.props
Processing (3/76): .github/workflows/ci.yml
Processing (4/76): .github/workflows/release.yml
Processing (5/76): global.json
Processing (6/76): MyEmailSearch/appsettings.json
Processing (7/76): MyEmailSearch/.backup/IndexCommand.cs
Processing (8/76): MyEmailSearch/.backup/Program.cs
Processing (9/76): MyEmailSearch/.backup/RebuildCommand.cs
Processing (10/76): MyEmailSearch/.backup/SearchCommand.cs
Processing (11/76): MyEmailSearch/.backup/StatusCommand.cs
Processing (12/76): MyEmailSearch/Commands/IndexCommand.cs
Processing (13/76): MyEmailSearch/Commands/RebuildCommand.cs
Processing (14/76): MyEmailSearch/Commands/SearchCommand.cs
Processing (15/76): MyEmailSearch/Commands/StatusCommand.cs
Processing (16/76): MyEmailSearch/Configuration/PathResolver.cs
Processing (17/76): MyEmailSearch/Data/DatabaseStatistics.cs
Processing (18/76): MyEmailSearch/Data/EmailDocument.cs
Processing (19/76): MyEmailSearch/Data/IndexStatistics.cs
Processing (20/76): MyEmailSearch/Data/SearchDatabase.cs
Processing (21/76): MyEmailSearch/Data/SearchQuery.cs
Processing (22/76): MyEmailSearch/Data/SearchResult.cs
Processing (23/76): MyEmailSearch/Indexing/ArchiveScanner.cs
Processing (24/76): MyEmailSearch/Indexing/EmailParser.cs
Processing (25/76): MyEmailSearch/Indexing/IndexManager.cs
Processing (26/76): MyEmailSearch/MyEmailSearch.csproj
Processing (27/76): MyEmailSearch/Program.cs
Processing (28/76): MyEmailSearch/Search/QueryParser.cs
Processing (29/76): MyEmailSearch/Search/SearchEngine.cs
Processing (30/76): MyEmailSearch/Search/SnippetGenerator.cs
Processing (31/76): MyEmailSearch.Tests/Data/Fts5HelperTests.cs
Processing (32/76): MyEmailSearch.Tests/Data/SearchDatabaseCountTests.cs
Processing (33/76): MyEmailSearch.Tests/Data/SearchDatabaseEscapingTests.cs
Processing (34/76): MyEmailSearch.Tests/Data/SearchDatabaseFtsTests.cs
Processing (35/76): MyEmailSearch.Tests/Data/SearchDatabaseTests.cs
Processing (36/76): MyEmailSearch.Tests/MyEmailSearch.Tests.csproj
Processing (37/76): MyEmailSearch.Tests/Search/QueryParserTests.cs
Processing (38/76): MyEmailSearch.Tests/Search/SearchEngineCountTests.cs
Processing (39/76): MyEmailSearch.Tests/Search/SnippetGeneratorTests.cs
Processing (40/76): MyEmailSearch.Tests/SmokeTests.cs
Processing (41/76): MyImapDownloader/appsettings.json
Processing (42/76): MyImapDownloader/DownloadOptions.cs
Processing (43/76): MyImapDownloader/EmailDownloadException.cs
Processing (44/76): MyImapDownloader/EmailDownloadService.cs
Processing (45/76): MyImapDownloader/EmailMetadata.cs
Processing (46/76): MyImapDownloader/EmailStorageService.cs
Processing (47/76): MyImapDownloader/ImapConfiguration.cs
Processing (48/76): MyImapDownloader/MyImapDownloader.csproj
Processing (49/76): MyImapDownloader/Program.cs
Processing (50/76): MyImapDownloader.slnx
Processing (51/76): MyImapDownloader/Telemetry/ActivityExtension.cs
Processing (52/76): MyImapDownloader/Telemetry/DiagnosticsConfig.cs
Processing (53/76): MyImapDownloader/Telemetry/JsonFileLogExporter.cs
Processing (54/76): MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs
Processing (55/76): MyImapDownloader/Telemetry/JsonFileTraceExporter.cs
Processing (56/76): MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs
Processing (57/76): MyImapDownloader/Telemetry/TelemetryConfiguration.cs
Processing (58/76): MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs
Processing (59/76): MyImapDownloader/Telemetry/TelemetryExtensions.cs
Processing (60/76): MyImapDownloader.Tests/DownloadOptionsTests.cs
Processing (61/76): MyImapDownloader.Tests/EmailDownloadExceptionTests.cs
Processing (62/76): MyImapDownloader.Tests/EmailStorageSanitizationTests.cs
Processing (63/76): MyImapDownloader.Tests/EmailStorageServiceParsingTests.cs
Processing (64/76): MyImapDownloader.Tests/EmailStorageServiceTests.cs
Processing (65/76): MyImapDownloader.Tests/ImapConfigurationTests.cs
Processing (66/76): MyImapDownloader.Tests/MyImapDownloader.Tests.csproj
Processing (67/76): MyImapDownloader.Tests/Telemetry/ActivityExtensionsTests.cs
Processing (68/76): MyImapDownloader.Tests/Telemetry/DiagnosticsConfigTests.cs
Processing (69/76): MyImapDownloader.Tests/Telemetry/JsonExporterTests.cs
Processing (70/76): MyImapDownloader.Tests/Telemetry/JsonTelemetryFileWriterTests.cs
Processing (71/76): MyImapDownloader.Tests/Telemetry/TelemetryConfigurationTests.cs
Processing (72/76): MyImapDownloader.Tests/Telemetry/TelemetryDirectoryResolverTests.cs
Processing (73/76): MyImapDownloader.Tests/Telemetry/TelemetryExtensionsTests.cs
Processing (74/76): MyImapDownloader.Tests/Telemetry/TelemetryWriterProviderTests.cs
Processing (75/76): MyImapDownloader.Tests/TempDirectory.cs
Processing (76/76): MyImapDownloader.Tests/TestLogger.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/MyImapDownloader/docs/llm/dump.txt
Total files exported: 76
Output file size: 0.29 MB

real	0m0.702s
user	0m0.309s
sys	0m0.513s
Restore complete (0.5s)
  MyEmailSearch net10.0 succeeded (2.3s) → MyEmailSearch/bin/Debug/net10.0/MyEmailSearch.dll
  MyImapDownloader net10.0 succeeded (2.3s) → MyImapDownloader/bin/Debug/net10.0/MyImapDownloader.dll
  MyEmailSearch.Tests net10.0 succeeded (1.1s) → MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll
  MyImapDownloader.Tests net10.0 succeeded (1.2s) → MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll

Build succeeded in 4.1s

real	0m4.319s
user	0m2.187s
sys	0m0.357s
Running tests from MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll (net10.0|x64)
Running tests from MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll (net10.0|x64)
MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll (net10.0|x64) passed (648ms)
MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll (net10.0|x64) passed (709ms)

Test run summary: Passed!
  MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll (net10.0|x64) passed (648ms)
  MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll (net10.0|x64) passed (709ms)

  total: 154
  failed: 0
  succeeded: 154
  skipped: 0
  duration: 930ms

real	0m2.251s
user	0m3.969s
sys	0m0.749s
Restore complete (0.5s)

Build succeeded in 0.6s
Project 'MyEmailSearch.Tests' has the following package references
   [net10.0]: 
   Top-level Package                               Requested   Resolved
   > AwesomeAssertions                             9.3.0       9.3.0   
   > Microsoft.Extensions.Configuration            10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection      10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                  10.0.2      10.0.2  
   > Microsoft.NET.Test.Sdk                        18.0.1      18.0.1  
   > NSubstitute                                   5.3.0       5.3.0   
   > TUnit                                         1.12.3      1.12.3  

Project 'MyEmailSearch' has the following package references
   [net10.0]: 
   Top-level Package                                              Requested   Resolved
   > Microsoft.Data.Sqlite                                        10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration                           10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration.EnvironmentVariables      10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration.Json                      10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection                     10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                                 10.0.2      10.0.2  
   > Microsoft.Extensions.Logging.Console                         10.0.2      10.0.2  
   > MimeKit                                                      4.14.0      4.14.0  
   > SQLitePCLRaw.bundle_e_sqlite3                                3.0.2       3.0.2   
   > System.CommandLine                                           2.0.2       2.0.2   

Project 'MyImapDownloader.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > AwesomeAssertions                              9.3.0       9.3.0   
   > Microsoft.Extensions.Configuration             10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection       10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                   10.0.2      10.0.2  
   > Microsoft.Extensions.Logging.Abstractions      10.0.2      10.0.2  
   > NSubstitute                                    5.3.0       5.3.0   
   > TUnit                                          1.12.3      1.12.3  

Project 'MyImapDownloader' has the following package references
   [net10.0]: 
   Top-level Package                               Requested   Resolved
   > CommandLineParser                             2.9.1       2.9.1   
   > MailKit                                       4.14.1      4.14.1  
   > Microsoft.Data.Sqlite                         10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration            10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration.Json       10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection      10.0.2      10.0.2  
   > Microsoft.Extensions.Hosting                  10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                  10.0.2      10.0.2  
   > Microsoft.Extensions.Logging.Console          10.0.2      10.0.2  
   > OpenTelemetry                                 1.14.0      1.14.0  
   > OpenTelemetry.Exporter.Console                1.14.0      1.14.0  
   > OpenTelemetry.Extensions.Hosting              1.14.0      1.14.0  
   > OpenTelemetry.Instrumentation.Runtime         1.14.0      1.14.0  
   > Polly                                         8.6.5       8.6.5   
   > SQLitePCLRaw.bundle_e_sqlite3                 3.0.2       3.0.2   


real	0m1.770s
user	0m1.702s
sys	0m0.375s
Restore complete (0.5s)

Build succeeded in 0.6s

The following sources were used:
   https://api.nuget.org/v3/index.json

Project `MyEmailSearch.Tests` has the following updates to its packages
   [net10.0]: 
   Top-level Package      Requested   Resolved   Latest 
   > TUnit                1.12.3      1.12.3     1.12.15

The given project `MyEmailSearch` has no updates given the current sources.
Project `MyImapDownloader.Tests` has the following updates to its packages
   [net10.0]: 
   Top-level Package      Requested   Resolved   Latest 
   > TUnit                1.12.3      1.12.3     1.12.15

Project `MyImapDownloader` has the following updates to its packages
   [net10.0]: 
   Top-level Package                            Requested   Resolved   Latest
   > OpenTelemetry                              1.14.0      1.14.0     1.15.0
   > OpenTelemetry.Exporter.Console             1.14.0      1.14.0     1.15.0
   > OpenTelemetry.Extensions.Hosting           1.14.0      1.14.0     1.15.0
   > OpenTelemetry.Instrumentation.Runtime      1.14.0      1.14.0     1.15.0


real	0m4.365s
user	0m3.438s
sys	0m0.484s
kushal@fedora:~/src/dotnet/MyImapDownloader$ cd ~/src/dotnet/MyImapDownloader/; time dotnet format; time bash export.sh; time dotnet build; time dotnet test; time dotnet list package; time dotnet list package --outdated;

real	0m7.785s
user	0m18.874s
sys	0m1.028s
Starting project export...
Project Path: /home/kushal/src/dotnet/MyImapDownloader
Output File: docs/llm/dump.txt
Generating directory structure...
Collecting files...
Found 76 files to export
Processing (1/76): Directory.Build.props
Processing (2/76): Directory.Packages.props
Processing (3/76): .github/workflows/ci.yml
Processing (4/76): .github/workflows/release.yml
Processing (5/76): global.json
Processing (6/76): MyEmailSearch/appsettings.json
Processing (7/76): MyEmailSearch/.backup/IndexCommand.cs
Processing (8/76): MyEmailSearch/.backup/Program.cs
Processing (9/76): MyEmailSearch/.backup/RebuildCommand.cs
Processing (10/76): MyEmailSearch/.backup/SearchCommand.cs
Processing (11/76): MyEmailSearch/.backup/StatusCommand.cs
Processing (12/76): MyEmailSearch/Commands/IndexCommand.cs
Processing (13/76): MyEmailSearch/Commands/RebuildCommand.cs
Processing (14/76): MyEmailSearch/Commands/SearchCommand.cs
Processing (15/76): MyEmailSearch/Commands/StatusCommand.cs
Processing (16/76): MyEmailSearch/Configuration/PathResolver.cs
Processing (17/76): MyEmailSearch/Data/DatabaseStatistics.cs
Processing (18/76): MyEmailSearch/Data/EmailDocument.cs
Processing (19/76): MyEmailSearch/Data/IndexStatistics.cs
Processing (20/76): MyEmailSearch/Data/SearchDatabase.cs
Processing (21/76): MyEmailSearch/Data/SearchQuery.cs
Processing (22/76): MyEmailSearch/Data/SearchResult.cs
Processing (23/76): MyEmailSearch/Indexing/ArchiveScanner.cs
Processing (24/76): MyEmailSearch/Indexing/EmailParser.cs
Processing (25/76): MyEmailSearch/Indexing/IndexManager.cs
Processing (26/76): MyEmailSearch/MyEmailSearch.csproj
Processing (27/76): MyEmailSearch/Program.cs
Processing (28/76): MyEmailSearch/Search/QueryParser.cs
Processing (29/76): MyEmailSearch/Search/SearchEngine.cs
Processing (30/76): MyEmailSearch/Search/SnippetGenerator.cs
Processing (31/76): MyEmailSearch.Tests/Data/Fts5HelperTests.cs
Processing (32/76): MyEmailSearch.Tests/Data/SearchDatabaseCountTests.cs
Processing (33/76): MyEmailSearch.Tests/Data/SearchDatabaseEscapingTests.cs
Processing (34/76): MyEmailSearch.Tests/Data/SearchDatabaseFtsTests.cs
Processing (35/76): MyEmailSearch.Tests/Data/SearchDatabaseTests.cs
Processing (36/76): MyEmailSearch.Tests/MyEmailSearch.Tests.csproj
Processing (37/76): MyEmailSearch.Tests/Search/QueryParserTests.cs
Processing (38/76): MyEmailSearch.Tests/Search/SearchEngineCountTests.cs
Processing (39/76): MyEmailSearch.Tests/Search/SnippetGeneratorTests.cs
Processing (40/76): MyEmailSearch.Tests/SmokeTests.cs
Processing (41/76): MyImapDownloader/appsettings.json
Processing (42/76): MyImapDownloader/DownloadOptions.cs
Processing (43/76): MyImapDownloader/EmailDownloadException.cs
Processing (44/76): MyImapDownloader/EmailDownloadService.cs
Processing (45/76): MyImapDownloader/EmailMetadata.cs
Processing (46/76): MyImapDownloader/EmailStorageService.cs
Processing (47/76): MyImapDownloader/ImapConfiguration.cs
Processing (48/76): MyImapDownloader/MyImapDownloader.csproj
Processing (49/76): MyImapDownloader/Program.cs
Processing (50/76): MyImapDownloader.slnx
Processing (51/76): MyImapDownloader/Telemetry/ActivityExtension.cs
Processing (52/76): MyImapDownloader/Telemetry/DiagnosticsConfig.cs
Processing (53/76): MyImapDownloader/Telemetry/JsonFileLogExporter.cs
Processing (54/76): MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs
Processing (55/76): MyImapDownloader/Telemetry/JsonFileTraceExporter.cs
Processing (56/76): MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs
Processing (57/76): MyImapDownloader/Telemetry/TelemetryConfiguration.cs
Processing (58/76): MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs
Processing (59/76): MyImapDownloader/Telemetry/TelemetryExtensions.cs
Processing (60/76): MyImapDownloader.Tests/DownloadOptionsTests.cs
Processing (61/76): MyImapDownloader.Tests/EmailDownloadExceptionTests.cs
Processing (62/76): MyImapDownloader.Tests/EmailStorageSanitizationTests.cs
Processing (63/76): MyImapDownloader.Tests/EmailStorageServiceParsingTests.cs
Processing (64/76): MyImapDownloader.Tests/EmailStorageServiceTests.cs
Processing (65/76): MyImapDownloader.Tests/ImapConfigurationTests.cs
Processing (66/76): MyImapDownloader.Tests/MyImapDownloader.Tests.csproj
Processing (67/76): MyImapDownloader.Tests/Telemetry/ActivityExtensionsTests.cs
Processing (68/76): MyImapDownloader.Tests/Telemetry/DiagnosticsConfigTests.cs
Processing (69/76): MyImapDownloader.Tests/Telemetry/JsonExporterTests.cs
Processing (70/76): MyImapDownloader.Tests/Telemetry/JsonTelemetryFileWriterTests.cs
Processing (71/76): MyImapDownloader.Tests/Telemetry/TelemetryConfigurationTests.cs
Processing (72/76): MyImapDownloader.Tests/Telemetry/TelemetryDirectoryResolverTests.cs
Processing (73/76): MyImapDownloader.Tests/Telemetry/TelemetryExtensionsTests.cs
Processing (74/76): MyImapDownloader.Tests/Telemetry/TelemetryWriterProviderTests.cs
Processing (75/76): MyImapDownloader.Tests/TempDirectory.cs
Processing (76/76): MyImapDownloader.Tests/TestLogger.cs

Export completed successfully!
Output file: /home/kushal/src/dotnet/MyImapDownloader/docs/llm/dump.txt
Total files exported: 76
Output file size: 0.29 MB

real	0m0.731s
user	0m0.350s
sys	0m0.535s
Restore complete (0.5s)
  MyImapDownloader net10.0 succeeded (0.3s) → MyImapDownloader/bin/Debug/net10.0/MyImapDownloader.dll
  MyEmailSearch net10.0 succeeded (0.3s) → MyEmailSearch/bin/Debug/net10.0/MyEmailSearch.dll
  MyEmailSearch.Tests net10.0 succeeded (0.9s) → MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll
  MyImapDownloader.Tests net10.0 succeeded (0.9s) → MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll

Build succeeded in 1.9s

real	0m2.037s
user	0m1.571s
sys	0m0.289s
Running tests from MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll (net10.0|x64)
Running tests from MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll (net10.0|x64)
MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll (net10.0|x64) passed (557ms)
MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll (net10.0|x64) passed (630ms)

Test run summary: Passed!
  MyImapDownloader.Tests/bin/Debug/net10.0/MyImapDownloader.Tests.dll (net10.0|x64) passed (630ms)
  MyEmailSearch.Tests/bin/Debug/net10.0/MyEmailSearch.Tests.dll (net10.0|x64) passed (557ms)

  total: 154
  failed: 0
  succeeded: 154
  skipped: 0
  duration: 814ms

real	0m2.159s
user	0m3.702s
sys	0m0.780s
Restore complete (0.5s)

Build succeeded in 0.6s
Project 'MyEmailSearch.Tests' has the following package references
   [net10.0]: 
   Top-level Package                               Requested   Resolved
   > AwesomeAssertions                             9.3.0       9.3.0   
   > Microsoft.Extensions.Configuration            10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection      10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                  10.0.2      10.0.2  
   > Microsoft.NET.Test.Sdk                        18.0.1      18.0.1  
   > NSubstitute                                   5.3.0       5.3.0   
   > TUnit                                         1.12.15     1.12.15 

Project 'MyEmailSearch' has the following package references
   [net10.0]: 
   Top-level Package                                              Requested   Resolved
   > Microsoft.Data.Sqlite                                        10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration                           10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration.EnvironmentVariables      10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration.Json                      10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection                     10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                                 10.0.2      10.0.2  
   > Microsoft.Extensions.Logging.Console                         10.0.2      10.0.2  
   > MimeKit                                                      4.14.0      4.14.0  
   > SQLitePCLRaw.bundle_e_sqlite3                                3.0.2       3.0.2   
   > System.CommandLine                                           2.0.2       2.0.2   

Project 'MyImapDownloader.Tests' has the following package references
   [net10.0]: 
   Top-level Package                                Requested   Resolved
   > AwesomeAssertions                              9.3.0       9.3.0   
   > Microsoft.Extensions.Configuration             10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection       10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                   10.0.2      10.0.2  
   > Microsoft.Extensions.Logging.Abstractions      10.0.2      10.0.2  
   > NSubstitute                                    5.3.0       5.3.0   
   > TUnit                                          1.12.15     1.12.15 

Project 'MyImapDownloader' has the following package references
   [net10.0]: 
   Top-level Package                               Requested   Resolved
   > CommandLineParser                             2.9.1       2.9.1   
   > MailKit                                       4.14.1      4.14.1  
   > Microsoft.Data.Sqlite                         10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration            10.0.2      10.0.2  
   > Microsoft.Extensions.Configuration.Json       10.0.2      10.0.2  
   > Microsoft.Extensions.DependencyInjection      10.0.2      10.0.2  
   > Microsoft.Extensions.Hosting                  10.0.2      10.0.2  
   > Microsoft.Extensions.Logging                  10.0.2      10.0.2  
   > Microsoft.Extensions.Logging.Console          10.0.2      10.0.2  
   > OpenTelemetry                                 1.15.0      1.15.0  
   > OpenTelemetry.Exporter.Console                1.15.0      1.15.0  
   > OpenTelemetry.Extensions.Hosting              1.15.0      1.15.0  
   > OpenTelemetry.Instrumentation.Runtime         1.15.0      1.15.0  
   > Polly                                         8.6.5       8.6.5   
   > SQLitePCLRaw.bundle_e_sqlite3                 3.0.2       3.0.2   


real	0m1.631s
user	0m1.642s
sys	0m0.321s
Restore complete (0.5s)

Build succeeded in 0.6s

The following sources were used:
   https://api.nuget.org/v3/index.json

The given project `MyEmailSearch.Tests` has no updates given the current sources.
The given project `MyEmailSearch` has no updates given the current sources.
The given project `MyImapDownloader.Tests` has no updates given the current sources.
The given project `MyImapDownloader` has no updates given the current sources.

real	0m2.510s
user	0m2.586s
sys	0m0.384s
kushal@fedora:~/src/dotnet/MyImapDownloader$ cat implement-common-core.sh; time bash implement-common-core.sh; cat update-projects-to-use-core.sh; time bash update-projects-to-use-core.sh; cat create-all-unit-tests.sh; time bash create-all-unit-tests.sh 
#!/bin/bash
# =============================================================================
# MyImapDownloader Common Core Integration Script
# =============================================================================
# This script creates a shared library (MyImapDownloader.Core) containing
# common infrastructure used by both MyImapDownloader and MyEmailSearch.
#
# Components moved to Core:
#   - Telemetry (DiagnosticsConfig, exporters, file writer)
#   - Path resolution (XDG-compliant directory resolution)
#   - Common models (EmailMetadata)
#   - Database helpers (SQLite base patterns)
#   - Test infrastructure (TempDirectory, TestLogger)
# =============================================================================

set -euo pipefail

PROJECT_ROOT="${1:-$(pwd)}"
CORE_DIR="$PROJECT_ROOT/MyImapDownloader.Core"
CORE_TESTS_DIR="$PROJECT_ROOT/MyImapDownloader.Core.Tests"

echo "=========================================="
echo "Creating MyImapDownloader.Core Library"
echo "Project Root: $PROJECT_ROOT"
echo "=========================================="

# =============================================================================
# 1. Create Core project structure
# =============================================================================
echo ""
echo "[1/8] Creating directory structure..."

mkdir -p "$CORE_DIR/Telemetry"
mkdir -p "$CORE_DIR/Configuration"
mkdir -p "$CORE_DIR/Data"
mkdir -p "$CORE_DIR/Infrastructure"
mkdir -p "$CORE_TESTS_DIR/Telemetry"
mkdir -p "$CORE_TESTS_DIR/Configuration"
mkdir -p "$CORE_TESTS_DIR/Infrastructure"
mkdir -p "$CORE_TESTS_DIR/TestFixtures"

# =============================================================================
# 2. Create Core project file
# =============================================================================
echo "[2/8] Creating MyImapDownloader.Core.csproj..."

cat > "$CORE_DIR/MyImapDownloader.Core.csproj" << 'CSPROJ'
<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyImapDownloader.Core - Shared Infrastructure Library
    
    This library contains common components shared between:
      - MyImapDownloader (email archiving)
      - MyEmailSearch (email search)
    
    Components:
      - Telemetry: OpenTelemetry with JSONL file exporters
      - Configuration: XDG-compliant path resolution
      - Data: Common email metadata models
      - Infrastructure: SQLite helpers, test utilities
  -->
  
  <PropertyGroup>
    <RootNamespace>MyImapDownloader.Core</RootNamespace>
    <AssemblyName>MyImapDownloader.Core</AssemblyName>
    <Description>Shared infrastructure for MyImapDownloader and MyEmailSearch</Description>
  </PropertyGroup>

  <ItemGroup>
    <!-- Database -->
    <PackageReference Include="Microsoft.Data.Sqlite" />
    
    <!-- Telemetry -->
    <PackageReference Include="OpenTelemetry" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    
    <!-- Configuration & DI -->
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
  </ItemGroup>
</Project>
CSPROJ

# =============================================================================
# 3. Create Telemetry components
# =============================================================================
echo "[3/8] Creating Telemetry components..."

# 3.1 DiagnosticsConfig.cs - Base telemetry configuration
cat > "$CORE_DIR/Telemetry/DiagnosticsConfig.cs" << 'CSHARP'
using System.Diagnostics;
using System.Diagnostics.Metrics;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Base diagnostics configuration for shared telemetry infrastructure.
/// Applications should create their own derived config with application-specific metrics.
/// </summary>
public class DiagnosticsConfigBase
{
    private readonly ActivitySource _activitySource;
    private readonly Meter _meter;

    public DiagnosticsConfigBase(string serviceName, string serviceVersion)
    {
        ServiceName = serviceName;
        ServiceVersion = serviceVersion;
        _activitySource = new ActivitySource(serviceName, serviceVersion);
        _meter = new Meter(serviceName, serviceVersion);
    }

    public string ServiceName { get; }
    public string ServiceVersion { get; }
    public ActivitySource ActivitySource => _activitySource;
    public Meter Meter => _meter;

    /// <summary>
    /// Creates a counter metric.
    /// </summary>
    public Counter<T> CreateCounter<T>(string name, string? unit = null, string? description = null)
        where T : struct
        => _meter.CreateCounter<T>(name, unit, description);

    /// <summary>
    /// Creates a histogram metric.
    /// </summary>
    public Histogram<T> CreateHistogram<T>(string name, string? unit = null, string? description = null)
        where T : struct
        => _meter.CreateHistogram<T>(name, unit, description);

    /// <summary>
    /// Creates an observable gauge metric.
    /// </summary>
    public ObservableGauge<T> CreateObservableGauge<T>(
        string name,
        Func<T> observeValue,
        string? unit = null,
        string? description = null)
        where T : struct
        => _meter.CreateObservableGauge(name, observeValue, unit, description);
}

/// <summary>
/// Static helper for creating activity spans.
/// </summary>
public static class ActivityHelper
{
    /// <summary>
    /// Starts an activity with the given source and name.
    /// </summary>
    public static Activity? StartActivity(
        ActivitySource source,
        string name,
        ActivityKind kind = ActivityKind.Internal)
        => source.StartActivity(name, kind);
}
CSHARP

# 3.2 TelemetryConfiguration.cs
cat > "$CORE_DIR/Telemetry/TelemetryConfiguration.cs" << 'CSHARP'
namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Configuration options for telemetry export.
/// </summary>
public class TelemetryConfiguration
{
    public const string SectionName = "Telemetry";

    public string ServiceName { get; set; } = "MyImapDownloader";
    public string ServiceVersion { get; set; } = "1.0.0";
    public string OutputDirectory { get; set; } = "telemetry";
    public int MaxFileSizeMB { get; set; } = 25;
    public bool EnableTracing { get; set; } = true;
    public bool EnableMetrics { get; set; } = true;
    public bool EnableLogging { get; set; } = true;
    public int FlushIntervalSeconds { get; set; } = 5;
    public int MetricsExportIntervalSeconds { get; set; } = 15;

    public long MaxFileSizeBytes => MaxFileSizeMB * 1024L * 1024L;
}
CSHARP

# 3.3 JsonTelemetryFileWriter.cs
cat > "$CORE_DIR/Telemetry/JsonTelemetryFileWriter.cs" << 'CSHARP'
using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Thread-safe JSON Lines file writer with size-based rotation and periodic flushing.
/// </summary>
public sealed class JsonTelemetryFileWriter : IDisposable
{
    private readonly string _directory;
    private readonly string _prefix;
    private readonly long _maxFileSize;
    private readonly TimeSpan _flushInterval;
    private readonly ConcurrentQueue<object> _queue = new();
    private readonly SemaphoreSlim _writeLock = new(1, 1);
    private readonly Timer _flushTimer;
    private readonly CancellationTokenSource _cts = new();

    private string _currentFilePath;
    private long _currentFileSize;
    private int _fileSequence;
    private bool _disposed;

    public JsonTelemetryFileWriter(
        string directory,
        string prefix,
        long maxFileSizeBytes,
        TimeSpan flushInterval)
    {
        _directory = directory;
        _prefix = prefix;
        _maxFileSize = maxFileSizeBytes;
        _flushInterval = flushInterval;

        Directory.CreateDirectory(directory);
        _currentFilePath = GenerateFilePath();
        InitializeFileSize();

        _flushTimer = new Timer(
            _ => _ = FlushAsync(),
            null,
            flushInterval,
            flushInterval);
    }

    public void Enqueue(object record)
    {
        if (_disposed) return;
        _queue.Enqueue(record);
    }

    public async Task FlushAsync()
    {
        if (_disposed || _queue.IsEmpty) return;

        var records = new List<object>();
        while (_queue.TryDequeue(out var record))
        {
            records.Add(record);
        }

        if (records.Count == 0) return;

        await _writeLock.WaitAsync(_cts.Token);
        try
        {
            await WriteRecordsAsync(records);
        }
        finally
        {
            _writeLock.Release();
        }
    }

    private async Task WriteRecordsAsync(List<object> records)
    {
        var sb = new StringBuilder();
        foreach (var record in records)
        {
            var json = JsonSerializer.Serialize(record, new JsonSerializerOptions
            {
                WriteIndented = false,
                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
            });
            sb.AppendLine(json);
        }

        var content = sb.ToString();
        var bytes = Encoding.UTF8.GetBytes(content);

        if (_currentFileSize + bytes.Length > _maxFileSize)
        {
            RotateFile();
        }

        await File.AppendAllTextAsync(_currentFilePath, content, _cts.Token);
        _currentFileSize += bytes.Length;
    }

    private void RotateFile()
    {
        _fileSequence++;
        _currentFilePath = GenerateFilePath();
        _currentFileSize = 0;
    }

    private string GenerateFilePath()
    {
        var date = DateTime.UtcNow.ToString("yyyyMMdd");
        return Path.Combine(_directory, $"{_prefix}_{date}_{_fileSequence:D4}.jsonl");
    }

    private void InitializeFileSize()
    {
        try
        {
            _currentFileSize = File.Exists(_currentFilePath)
                ? new FileInfo(_currentFilePath).Length
                : 0;
        }
        catch
        {
            _currentFileSize = 0;
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _cts.Cancel();
        _flushTimer.Dispose();

        try
        {
            FlushAsync().GetAwaiter().GetResult();
        }
        catch
        {
            // Ignore flush errors during disposal
        }

        _writeLock.Dispose();
        _cts.Dispose();
    }
}
CSHARP

# 3.4 ActivityExtensions.cs
cat > "$CORE_DIR/Telemetry/ActivityExtensions.cs" << 'CSHARP'
using System.Diagnostics;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Extension methods for System.Diagnostics.Activity.
/// </summary>
public static class ActivityExtensions
{
    /// <summary>
    /// Records an exception on the activity with full details.
    /// </summary>
    public static void RecordException(this Activity? activity, Exception exception)
    {
        if (activity == null || exception == null) return;

        var tags = new ActivityTagsCollection
        {
            { "exception.type", exception.GetType().FullName },
            { "exception.message", exception.Message }
        };

        if (!string.IsNullOrEmpty(exception.StackTrace))
        {
            tags.Add("exception.stacktrace", exception.StackTrace);
        }

        activity.AddEvent(new ActivityEvent("exception", tags: tags));
        activity.SetStatus(ActivityStatusCode.Error, exception.Message);
    }

    /// <summary>
    /// Sets the activity status to OK.
    /// </summary>
    public static void SetSuccess(this Activity? activity, string? description = null)
    {
        activity?.SetStatus(ActivityStatusCode.Ok, description);
    }

    /// <summary>
    /// Sets the activity status to Error.
    /// </summary>
    public static void SetError(this Activity? activity, string? description = null)
    {
        activity?.SetStatus(ActivityStatusCode.Error, description);
    }

    /// <summary>
    /// Adds a tag if the value is not null or empty.
    /// </summary>
    public static Activity? SetTagIfNotEmpty(this Activity? activity, string key, string? value)
    {
        if (activity != null && !string.IsNullOrEmpty(value))
        {
            activity.SetTag(key, value);
        }
        return activity;
    }
}
CSHARP

# 3.5 JsonFileLogExporter.cs
cat > "$CORE_DIR/Telemetry/JsonFileLogExporter.cs" << 'CSHARP'
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Exports OpenTelemetry logs to JSON files.
/// </summary>
public sealed class JsonFileLogExporter(JsonTelemetryFileWriter? writer) : BaseExporter<LogRecord>
{
    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var log in batch)
            {
                var record = new LogRecordData
                {
                    Timestamp = log.Timestamp != default ? log.Timestamp : DateTime.UtcNow,
                    TraceId = log.TraceId != default ? log.TraceId.ToString() : null,
                    SpanId = log.SpanId != default ? log.SpanId.ToString() : null,
                    LogLevel = log.LogLevel.ToString(),
                    CategoryName = log.CategoryName,
                    EventId = log.EventId.Id != 0 ? log.EventId.Id : null,
                    EventName = log.EventId.Name,
                    FormattedMessage = log.FormattedMessage,
                    Body = log.Body,
                    Attributes = ExtractAttributes(log),
                    Exception = ExtractException(log.Exception)
                };

                writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, object?>? ExtractAttributes(LogRecord log)
    {
        if (log.Attributes == null) return null;

        var attrs = new Dictionary<string, object?>();
        foreach (var attr in log.Attributes)
        {
            attrs[attr.Key] = attr.Value;
        }
        return attrs.Count > 0 ? attrs : null;
    }

    private static ExceptionInfo? ExtractException(Exception? ex)
    {
        if (ex == null) return null;

        return new ExceptionInfo
        {
            Type = ex.GetType().FullName,
            Message = ex.Message,
            StackTrace = ex.StackTrace,
            InnerException = ExtractException(ex.InnerException)
        };
    }
}

public record LogRecordData
{
    public string Type => "log";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? LogLevel { get; init; }
    public string? CategoryName { get; init; }
    public int? EventId { get; init; }
    public string? EventName { get; init; }
    public string? FormattedMessage { get; init; }
    public string? Body { get; init; }
    public Dictionary<string, object?>? Attributes { get; init; }
    public ExceptionInfo? Exception { get; init; }
}

public record ExceptionInfo
{
    public string? Type { get; init; }
    public string? Message { get; init; }
    public string? StackTrace { get; init; }
    public ExceptionInfo? InnerException { get; init; }
}
CSHARP

# 3.6 JsonFileTraceExporter.cs
cat > "$CORE_DIR/Telemetry/JsonFileTraceExporter.cs" << 'CSHARP'
using System.Diagnostics;
using OpenTelemetry;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Exports OpenTelemetry traces to JSON files.
/// </summary>
public sealed class JsonFileTraceExporter(JsonTelemetryFileWriter? writer) : BaseExporter<Activity>
{
    public override ExportResult Export(in Batch<Activity> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var activity in batch)
            {
                var record = new TraceRecord
                {
                    Timestamp = activity.StartTimeUtc,
                    TraceId = activity.TraceId.ToString(),
                    SpanId = activity.SpanId.ToString(),
                    ParentSpanId = activity.ParentSpanId.ToString(),
                    OperationName = activity.OperationName,
                    DisplayName = activity.DisplayName,
                    Kind = activity.Kind.ToString(),
                    Status = activity.Status.ToString(),
                    StatusDescription = activity.StatusDescription,
                    Duration = activity.Duration,
                    DurationMs = activity.Duration.TotalMilliseconds,
                    Source = new SourceInfo
                    {
                        Name = activity.Source.Name,
                        Version = activity.Source.Version
                    },
                    Tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value),
                    Events = activity.Events.Select(e => new SpanEvent
                    {
                        Name = e.Name,
                        Timestamp = e.Timestamp.UtcDateTime,
                        Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
                    }).ToList()
                };

                writer.Enqueue(record);
            }
        }
        catch
        {
            // Silently ignore export failures
        }

        return ExportResult.Success;
    }
}

public record TraceRecord
{
    public string Type => "trace";
    public DateTime Timestamp { get; init; }
    public string? TraceId { get; init; }
    public string? SpanId { get; init; }
    public string? ParentSpanId { get; init; }
    public string? OperationName { get; init; }
    public string? DisplayName { get; init; }
    public string? Kind { get; init; }
    public string? Status { get; init; }
    public string? StatusDescription { get; init; }
    public TimeSpan Duration { get; init; }
    public double DurationMs { get; init; }
    public SourceInfo? Source { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public List<SpanEvent>? Events { get; init; }
}

public record SourceInfo
{
    public string? Name { get; init; }
    public string? Version { get; init; }
}

public record SpanEvent
{
    public string? Name { get; init; }
    public DateTime Timestamp { get; init; }
    public Dictionary<string, string?>? Attributes { get; init; }
}
CSHARP

# 3.7 JsonFileMetricsExporter.cs
cat > "$CORE_DIR/Telemetry/JsonFileMetricsExporter.cs" << 'CSHARP'
using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Exports OpenTelemetry metrics to JSON files.
/// </summary>
public sealed class JsonFileMetricsExporter(JsonTelemetryFileWriter? writer) : BaseExporter<Metric>
{
    public override ExportResult Export(in Batch<Metric> batch)
    {
        if (writer == null) return ExportResult.Success;

        try
        {
            foreach (var metric in batch)
            {
                foreach (ref readonly var point in metric.GetMetricPoints())
                {
                    var record = new MetricRecord
                    {
                        Timestamp = point.EndTime.UtcDateTime,
                        MetricName = metric.Name,
                        MetricDescription = metric.Description,
                        MetricUnit = metric.Unit,
                        MetricType = metric.MetricType.ToString(),
                        MeterName = metric.MeterName,
                        StartTime = point.StartTime.UtcDateTime,
                        EndTime = point.EndTime.UtcDateTime,
                        Tags = ExtractTags(point),
                        Value = ExtractValue(metric, point)
                    };

                    writer.Enqueue(record);
                }
            }
        }
        catch
        {
            // Silently ignore export failures
        }

        return ExportResult.Success;
    }

    private static Dictionary<string, string?>? ExtractTags(MetricPoint point)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in point.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }
        return tags.Count > 0 ? tags : null;
    }

    private static object? ExtractValue(Metric metric, MetricPoint point)
    {
        return metric.MetricType switch
        {
            MetricType.LongSum => point.GetSumLong(),
            MetricType.DoubleSum => point.GetSumDouble(),
            MetricType.LongGauge => point.GetGaugeLastValueLong(),
            MetricType.DoubleGauge => point.GetGaugeLastValueDouble(),
            MetricType.Histogram => new
            {
                Count = point.GetHistogramCount(),
                Sum = point.GetHistogramSum(),
                Min = GetHistogramMin(point),
                Max = GetHistogramMax(point)
            },
            _ => null
        };
    }

    private static double? GetHistogramMin(MetricPoint point)
    {
        try
        {
            var prop = point.GetType().GetProperty("HistogramMin");
            return prop?.GetValue(point) as double?;
        }
        catch { return null; }
    }

    private static double? GetHistogramMax(MetricPoint point)
    {
        try
        {
            var prop = point.GetType().GetProperty("HistogramMax");
            return prop?.GetValue(point) as double?;
        }
        catch { return null; }
    }
}

public record MetricRecord
{
    public string Type => "metric";
    public DateTime Timestamp { get; init; }
    public string? MetricName { get; init; }
    public string? MetricDescription { get; init; }
    public string? MetricUnit { get; init; }
    public string? MetricType { get; init; }
    public string? MeterName { get; init; }
    public DateTime StartTime { get; init; }
    public DateTime EndTime { get; init; }
    public Dictionary<string, string?>? Tags { get; init; }
    public object? Value { get; init; }
}
CSHARP

# 3.8 TelemetryDirectoryResolver.cs
cat > "$CORE_DIR/Telemetry/TelemetryDirectoryResolver.cs" << 'CSHARP'
namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Resolves telemetry output directory following XDG Base Directory Specification.
/// </summary>
public static class TelemetryDirectoryResolver
{
    /// <summary>
    /// Attempts to resolve a writable telemetry directory.
    /// Returns null if no writable location can be found.
    /// </summary>
    public static string? ResolveTelemetryDirectory(string appName)
    {
        var candidates = GetCandidateDirectories(appName);

        foreach (var candidate in candidates)
        {
            if (TryEnsureWritableDirectory(candidate))
            {
                return candidate;
            }
        }

        return null;
    }

    private static IEnumerable<string> GetCandidateDirectories(string appName)
    {
        var lowerAppName = appName.ToLowerInvariant();

        // 1. XDG_STATE_HOME (preferred for telemetry/logs)
        var xdgState = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrEmpty(xdgState))
        {
            yield return Path.Combine(xdgState, lowerAppName, "telemetry");
        }

        // 2. XDG_DATA_HOME
        var xdgData = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrEmpty(xdgData))
        {
            yield return Path.Combine(xdgData, lowerAppName, "telemetry");
        }

        // 3. Platform-specific defaults
        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        if (OperatingSystem.IsLinux() || OperatingSystem.IsMacOS())
        {
            yield return Path.Combine(home, ".local", "state", lowerAppName, "telemetry");
            yield return Path.Combine(home, ".local", "share", lowerAppName, "telemetry");
        }
        else if (OperatingSystem.IsWindows())
        {
            var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            yield return Path.Combine(localAppData, appName, "telemetry");
        }

        // 4. Fallback to current directory
        yield return Path.Combine(Environment.CurrentDirectory, "telemetry");
    }

    private static bool TryEnsureWritableDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            try
            {
                File.WriteAllText(testFile, "test");
                File.Delete(testFile);
                return true;
            }
            catch
            {
                return false;
            }
        }
        catch
        {
            return false;
        }
    }
}
CSHARP

# 3.9 TelemetryExtensions.cs
cat > "$CORE_DIR/Telemetry/TelemetryExtensions.cs" << 'CSHARP'
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace MyImapDownloader.Core.Telemetry;

/// <summary>
/// Extension methods for configuring OpenTelemetry with JSON file exporters.
/// </summary>
public static class TelemetryExtensions
{
    public static IServiceCollection AddCoreTelemetry(
        this IServiceCollection services,
        IConfiguration configuration,
        string serviceName,
        string serviceVersion)
    {
        var config = new TelemetryConfiguration
        {
            ServiceName = serviceName,
            ServiceVersion = serviceVersion
        };
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);
        services.AddSingleton(config);

        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);

        if (telemetryBaseDir == null)
        {
            services.AddSingleton<ITelemetryWriterProvider>(new NullTelemetryWriterProvider());
            return services;
        }

        config.OutputDirectory = telemetryBaseDir;

        var tracesDir = Path.Combine(telemetryBaseDir, "traces");
        var metricsDir = Path.Combine(telemetryBaseDir, "metrics");

        TryCreateDirectory(tracesDir);
        TryCreateDirectory(metricsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        JsonTelemetryFileWriter? traceWriter = null;
        JsonTelemetryFileWriter? metricsWriter = null;

        if (config.EnableTracing)
        {
            try
            {
                traceWriter = new JsonTelemetryFileWriter(
                    tracesDir, "traces", config.MaxFileSizeBytes, flushInterval);
            }
            catch { }
        }

        if (config.EnableMetrics)
        {
            try
            {
                metricsWriter = new JsonTelemetryFileWriter(
                    metricsDir, "metrics", config.MaxFileSizeBytes, flushInterval);
            }
            catch { }
        }

        services.AddSingleton<ITelemetryWriterProvider>(
            new TelemetryWriterProvider(traceWriter, metricsWriter, null));

        if (traceWriter != null)
        {
            services.AddSingleton(traceWriter);
        }

        var resourceBuilder = ResourceBuilder.CreateDefault()
            .AddService(serviceName: config.ServiceName, serviceVersion: config.ServiceVersion);

        services.AddOpenTelemetry()
            .WithTracing(builder =>
            {
                if (config.EnableTracing && traceWriter != null)
                {
                    builder
                        .SetResourceBuilder(resourceBuilder)
                        .AddSource(config.ServiceName)
                        .AddProcessor(new BatchActivityExportProcessor(
                            new JsonFileTraceExporter(traceWriter),
                            maxQueueSize: 2048,
                            scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds));
                }
            })
            .WithMetrics(builder =>
            {
                if (config.EnableMetrics && metricsWriter != null)
                {
                    builder
                        .SetResourceBuilder(resourceBuilder)
                        .AddMeter(config.ServiceName)
                        .AddRuntimeInstrumentation()
                        .AddReader(new PeriodicExportingMetricReader(
                            new JsonFileMetricsExporter(metricsWriter),
                            exportIntervalMilliseconds: config.MetricsExportIntervalSeconds * 1000));
                }
            });

        return services;
    }

    private static bool TryCreateDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

/// <summary>
/// Interface for accessing telemetry file writers.
/// </summary>
public interface ITelemetryWriterProvider
{
    JsonTelemetryFileWriter? TraceWriter { get; }
    JsonTelemetryFileWriter? MetricsWriter { get; }
    JsonTelemetryFileWriter? LogsWriter { get; }
}

/// <summary>
/// Provides access to telemetry file writers.
/// </summary>
public sealed class TelemetryWriterProvider(
    JsonTelemetryFileWriter? traceWriter,
    JsonTelemetryFileWriter? metricsWriter,
    JsonTelemetryFileWriter? logsWriter) : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => traceWriter;
    public JsonTelemetryFileWriter? MetricsWriter => metricsWriter;
    public JsonTelemetryFileWriter? LogsWriter => logsWriter;
}

/// <summary>
/// Null implementation when telemetry is disabled.
/// </summary>
public sealed class NullTelemetryWriterProvider : ITelemetryWriterProvider
{
    public JsonTelemetryFileWriter? TraceWriter => null;
    public JsonTelemetryFileWriter? MetricsWriter => null;
    public JsonTelemetryFileWriter? LogsWriter => null;
}
CSHARP

# =============================================================================
# 4. Create Configuration components
# =============================================================================
echo "[4/8] Creating Configuration components..."

# 4.1 PathResolver.cs - Unified XDG path resolution
cat > "$CORE_DIR/Configuration/PathResolver.cs" << 'CSHARP'
namespace MyImapDownloader.Core.Configuration;

/// <summary>
/// Resolves paths following XDG Base Directory Specification.
/// Provides consistent cross-platform path resolution for all applications.
/// </summary>
public static class PathResolver
{
    /// <summary>
    /// Gets the XDG data home directory.
    /// </summary>
    public static string GetDataHome(string appName)
    {
        var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
        if (!string.IsNullOrWhiteSpace(xdgDataHome))
        {
            return Path.Combine(xdgDataHome, appName.ToLowerInvariant());
        }

        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        
        if (OperatingSystem.IsWindows())
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                appName);
        }

        return Path.Combine(home, ".local", "share", appName.ToLowerInvariant());
    }

    /// <summary>
    /// Gets the XDG config home directory.
    /// </summary>
    public static string GetConfigHome(string appName)
    {
        var xdgConfigHome = Environment.GetEnvironmentVariable("XDG_CONFIG_HOME");
        if (!string.IsNullOrWhiteSpace(xdgConfigHome))
        {
            return Path.Combine(xdgConfigHome, appName.ToLowerInvariant());
        }

        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        if (OperatingSystem.IsWindows())
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                appName);
        }

        return Path.Combine(home, ".config", appName.ToLowerInvariant());
    }

    /// <summary>
    /// Gets the XDG state home directory (for logs, telemetry, etc.).
    /// </summary>
    public static string GetStateHome(string appName)
    {
        var xdgStateHome = Environment.GetEnvironmentVariable("XDG_STATE_HOME");
        if (!string.IsNullOrWhiteSpace(xdgStateHome))
        {
            return Path.Combine(xdgStateHome, appName.ToLowerInvariant());
        }

        var home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

        if (OperatingSystem.IsWindows())
        {
            return Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                appName,
                "State");
        }

        return Path.Combine(home, ".local", "state", appName.ToLowerInvariant());
    }

    /// <summary>
    /// Finds the first existing path from a list of candidates.
    /// </summary>
    public static string? FindFirstExisting(params string[] candidates)
    {
        foreach (var path in candidates)
        {
            if (Directory.Exists(path))
            {
                return path;
            }
        }
        return null;
    }

    /// <summary>
    /// Ensures a directory exists and is writable.
    /// </summary>
    public static bool EnsureWritableDirectory(string path)
    {
        try
        {
            Directory.CreateDirectory(path);
            var testFile = Path.Combine(path, $".write-test-{Guid.NewGuid():N}");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}
CSHARP

# =============================================================================
# 5. Create Data models
# =============================================================================
echo "[5/8] Creating Data models..."

# 5.1 EmailMetadata.cs - Shared email metadata model
cat > "$CORE_DIR/Data/EmailMetadata.cs" << 'CSHARP'
namespace MyImapDownloader.Core.Data;

/// <summary>
/// Represents metadata for an archived email.
/// This is the common model used by both the downloader and search systems.
/// </summary>
public record EmailMetadata
{
    /// <summary>
    /// The unique message ID from the email headers.
    /// </summary>
    public required string MessageId { get; init; }

    /// <summary>
    /// The email subject line.
    /// </summary>
    public string? Subject { get; init; }

    /// <summary>
    /// The sender address (From header).
    /// </summary>
    public string? From { get; init; }

    /// <summary>
    /// The recipient addresses (To header).
    /// </summary>
    public string? To { get; init; }

    /// <summary>
    /// The CC addresses.
    /// </summary>
    public string? Cc { get; init; }

    /// <summary>
    /// The date the email was sent.
    /// </summary>
    public DateTimeOffset? Date { get; init; }

    /// <summary>
    /// The folder/mailbox where the email is stored.
    /// </summary>
    public string? Folder { get; init; }

    /// <summary>
    /// When this email was archived.
    /// </summary>
    public DateTimeOffset ArchivedAt { get; init; }

    /// <summary>
    /// Whether the email has attachments.
    /// </summary>
    public bool HasAttachments { get; init; }

    /// <summary>
    /// File size in bytes.
    /// </summary>
    public long? SizeBytes { get; init; }

    /// <summary>
    /// The account this email belongs to.
    /// </summary>
    public string? Account { get; init; }
}
CSHARP

# =============================================================================
# 6. Create Infrastructure components
# =============================================================================
echo "[6/8] Creating Infrastructure components..."

# 6.1 SqliteHelper.cs - Common SQLite patterns
cat > "$CORE_DIR/Infrastructure/SqliteHelper.cs" << 'CSHARP'
using Microsoft.Data.Sqlite;

namespace MyImapDownloader.Core.Infrastructure;

/// <summary>
/// Helper class for common SQLite operations.
/// </summary>
public static class SqliteHelper
{
    /// <summary>
    /// Creates a connection string with recommended settings.
    /// </summary>
    public static string CreateConnectionString(string dbPath, bool readOnly = false)
    {
        var builder = new SqliteConnectionStringBuilder
        {
            DataSource = dbPath,
            Mode = readOnly ? SqliteOpenMode.ReadOnly : SqliteOpenMode.ReadWriteCreate,
            Cache = SqliteCacheMode.Shared
        };
        return builder.ConnectionString;
    }

    /// <summary>
    /// Applies recommended pragmas for performance and safety.
    /// </summary>
    public static async Task ApplyRecommendedPragmasAsync(
        SqliteConnection connection,
        CancellationToken ct = default)
    {
        using var cmd = connection.CreateCommand();
        cmd.CommandText = """
            PRAGMA journal_mode = WAL;
            PRAGMA synchronous = NORMAL;
            PRAGMA temp_store = MEMORY;
            PRAGMA mmap_size = 268435456;
            PRAGMA cache_size = -64000;
            """;
        await cmd.ExecuteNonQueryAsync(ct);
    }

    /// <summary>
    /// Executes a non-query command.
    /// </summary>
    public static async Task<int> ExecuteNonQueryAsync(
        SqliteConnection connection,
        string sql,
        Dictionary<string, object?>? parameters = null,
        CancellationToken ct = default)
    {
        using var cmd = connection.CreateCommand();
        cmd.CommandText = sql;
        
        if (parameters != null)
        {
            foreach (var (key, value) in parameters)
            {
                cmd.Parameters.AddWithValue(key, value ?? DBNull.Value);
            }
        }

        return await cmd.ExecuteNonQueryAsync(ct);
    }

    /// <summary>
    /// Executes a scalar query.
    /// </summary>
    public static async Task<T?> ExecuteScalarAsync<T>(
        SqliteConnection connection,
        string sql,
        Dictionary<string, object?>? parameters = null,
        CancellationToken ct = default)
    {
        using var cmd = connection.CreateCommand();
        cmd.CommandText = sql;

        if (parameters != null)
        {
            foreach (var (key, value) in parameters)
            {
                cmd.Parameters.AddWithValue(key, value ?? DBNull.Value);
            }
        }

        var result = await cmd.ExecuteScalarAsync(ct);
        if (result == null || result == DBNull.Value)
        {
            return default;
        }
        return (T)Convert.ChangeType(result, typeof(T));
    }
}
CSHARP

# 6.2 TempDirectory.cs - Test helper
cat > "$CORE_DIR/Infrastructure/TempDirectory.cs" << 'CSHARP'
namespace MyImapDownloader.Core.Infrastructure;

/// <summary>
/// Creates a temporary directory that is automatically cleaned up on disposal.
/// Useful for tests and temporary file operations.
/// </summary>
public sealed class TempDirectory : IDisposable
{
    public string Path { get; }

    public TempDirectory(string? prefix = null)
    {
        var name = prefix ?? "temp";
        Path = System.IO.Path.Combine(
            System.IO.Path.GetTempPath(),
            $"{name}_{Guid.NewGuid():N}");
        Directory.CreateDirectory(Path);
    }

    public void Dispose()
    {
        try
        {
            if (Directory.Exists(Path))
            {
                Directory.Delete(Path, recursive: true);
            }
        }
        catch
        {
            // Best-effort cleanup
        }
    }
}
CSHARP

# 6.3 TestLogger.cs - Test logging helper
cat > "$CORE_DIR/Infrastructure/TestLogger.cs" << 'CSHARP'
using Microsoft.Extensions.Logging;

namespace MyImapDownloader.Core.Infrastructure;

/// <summary>
/// Factory for creating test loggers.
/// </summary>
public static class TestLogger
{
    /// <summary>
    /// Creates a logger that writes to the console.
    /// </summary>
    public static ILogger<T> Create<T>()
    {
        using var factory = LoggerFactory.Create(builder =>
        {
            builder.AddConsole();
            builder.SetMinimumLevel(LogLevel.Debug);
        });
        return factory.CreateLogger<T>();
    }

    /// <summary>
    /// Creates a null logger that discards all output.
    /// </summary>
    public static ILogger<T> CreateNull<T>()
    {
        return Microsoft.Extensions.Logging.Abstractions.NullLogger<T>.Instance;
    }
}
CSHARP

# =============================================================================
# 7. Create Core Tests project
# =============================================================================
echo "[7/8] Creating Core Tests project..."

cat > "$CORE_TESTS_DIR/MyImapDownloader.Core.Tests.csproj" << 'CSPROJ'
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="AwesomeAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>
</Project>
CSPROJ

# Test: TelemetryConfigurationTests.cs
cat > "$CORE_TESTS_DIR/Telemetry/TelemetryConfigurationTests.cs" << 'CSHARP'
using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Core.Tests.Telemetry;

public class TelemetryConfigurationTests
{
    [Test]
    public async Task DefaultValues_AreReasonable()
    {
        var config = new TelemetryConfiguration();

        await Assert.That(config.ServiceName).IsEqualTo("MyImapDownloader");
        await Assert.That(config.ServiceVersion).IsEqualTo("1.0.0");
        await Assert.That(config.EnableTracing).IsTrue();
        await Assert.That(config.EnableMetrics).IsTrue();
        await Assert.That(config.EnableLogging).IsTrue();
        await Assert.That(config.MaxFileSizeMB).IsEqualTo(25);
        await Assert.That(config.FlushIntervalSeconds).IsEqualTo(5);
    }

    [Test]
    public async Task MaxFileSizeBytes_CalculatesCorrectly()
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = 10 };
        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(10L * 1024L * 1024L);
    }

    [Test]
    [Arguments(1)]
    [Arguments(25)]
    [Arguments(100)]
    public async Task MaxFileSizeBytes_ScalesWithMB(int megabytes)
    {
        var config = new TelemetryConfiguration { MaxFileSizeMB = megabytes };
        var expected = (long)megabytes * 1024L * 1024L;
        await Assert.That(config.MaxFileSizeBytes).IsEqualTo(expected);
    }
}
CSHARP

# Test: PathResolverTests.cs
cat > "$CORE_TESTS_DIR/Configuration/PathResolverTests.cs" << 'CSHARP'
using MyImapDownloader.Core.Configuration;

namespace MyImapDownloader.Core.Tests.Configuration;

public class PathResolverTests
{
    [Test]
    public async Task GetDataHome_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetDataHome("TestApp");
        
        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task GetConfigHome_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetConfigHome("TestApp");
        
        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task GetStateHome_ReturnsNonEmptyPath()
    {
        var path = PathResolver.GetStateHome("TestApp");
        
        await Assert.That(path).IsNotNull();
        await Assert.That(path).IsNotEmpty();
    }

    [Test]
    public async Task EnsureWritableDirectory_CreatesDirectory()
    {
        using var temp = new MyImapDownloader.Core.Infrastructure.TempDirectory("path_test");
        var subDir = Path.Combine(temp.Path, "subdir");

        var result = PathResolver.EnsureWritableDirectory(subDir);

        await Assert.That(result).IsTrue();
        await Assert.That(Directory.Exists(subDir)).IsTrue();
    }

    [Test]
    public async Task FindFirstExisting_ReturnsFirstMatch()
    {
        using var temp = new MyImapDownloader.Core.Infrastructure.TempDirectory("find_test");
        
        var result = PathResolver.FindFirstExisting(
            "/nonexistent/path",
            temp.Path,
            "/another/nonexistent");

        await Assert.That(result).IsEqualTo(temp.Path);
    }
}
CSHARP

# Test: TempDirectoryTests.cs
cat > "$CORE_TESTS_DIR/Infrastructure/TempDirectoryTests.cs" << 'CSHARP'
using MyImapDownloader.Core.Infrastructure;

namespace MyImapDownloader.Core.Tests.Infrastructure;

public class TempDirectoryTests
{
    [Test]
    public async Task Constructor_CreatesDirectory()
    {
        using var temp = new TempDirectory("test");
        await Assert.That(Directory.Exists(temp.Path)).IsTrue();
    }

    [Test]
    public async Task Dispose_DeletesDirectory()
    {
        string path;
        using (var temp = new TempDirectory("dispose_test"))
        {
            path = temp.Path;
            await Assert.That(Directory.Exists(path)).IsTrue();
        }
        
        await Task.Delay(100); // Give filesystem time
        await Assert.That(Directory.Exists(path)).IsFalse();
    }

    [Test]
    public async Task Path_ContainsPrefix()
    {
        using var temp = new TempDirectory("myprefix");
        await Assert.That(temp.Path).Contains("myprefix");
    }
}
CSHARP

# Test: SqliteHelperTests.cs
cat > "$CORE_TESTS_DIR/Infrastructure/SqliteHelperTests.cs" << 'CSHARP'
using Microsoft.Data.Sqlite;
using MyImapDownloader.Core.Infrastructure;

namespace MyImapDownloader.Core.Tests.Infrastructure;

public class SqliteHelperTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("sqlite_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    [Test]
    public async Task CreateConnectionString_IncludesDataSource()
    {
        var dbPath = Path.Combine(_temp.Path, "test.db");
        var connStr = SqliteHelper.CreateConnectionString(dbPath);

        await Assert.That(connStr).Contains(dbPath);
    }

    [Test]
    public async Task ApplyRecommendedPragmas_DoesNotThrow()
    {
        var dbPath = Path.Combine(_temp.Path, "pragmas.db");
        await using var conn = new SqliteConnection($"Data Source={dbPath}");
        await conn.OpenAsync();

        await SqliteHelper.ApplyRecommendedPragmasAsync(conn);

        // Verify WAL mode is set
        using var cmd = conn.CreateCommand();
        cmd.CommandText = "PRAGMA journal_mode;";
        var mode = await cmd.ExecuteScalarAsync();
        await Assert.That(mode?.ToString()?.ToLower()).IsEqualTo("wal");
    }

    [Test]
    public async Task ExecuteNonQueryAsync_CreatesTable()
    {
        var dbPath = Path.Combine(_temp.Path, "nonquery.db");
        await using var conn = new SqliteConnection($"Data Source={dbPath}");
        await conn.OpenAsync();

        var result = await SqliteHelper.ExecuteNonQueryAsync(
            conn,
            "CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)");

        await Assert.That(result).IsEqualTo(0); // DDL returns 0

        // Verify table exists
        var count = await SqliteHelper.ExecuteScalarAsync<long>(
            conn,
            "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='test'");
        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task ExecuteScalarAsync_WithParameters_ReturnsValue()
    {
        var dbPath = Path.Combine(_temp.Path, "scalar.db");
        await using var conn = new SqliteConnection($"Data Source={dbPath}");
        await conn.OpenAsync();

        await SqliteHelper.ExecuteNonQueryAsync(conn, 
            "CREATE TABLE kv (key TEXT PRIMARY KEY, value TEXT)");
        await SqliteHelper.ExecuteNonQueryAsync(conn,
            "INSERT INTO kv (key, value) VALUES (@k, @v)",
            new Dictionary<string, object?> { ["@k"] = "test", ["@v"] = "hello" });

        var result = await SqliteHelper.ExecuteScalarAsync<string>(
            conn,
            "SELECT value FROM kv WHERE key = @k",
            new Dictionary<string, object?> { ["@k"] = "test" });

        await Assert.That(result).IsEqualTo("hello");
    }
}
CSHARP

# Test: ActivityExtensionsTests.cs
cat > "$CORE_TESTS_DIR/Telemetry/ActivityExtensionsTests.cs" << 'CSHARP'
using System.Diagnostics;
using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Core.Tests.Telemetry;

public class ActivityExtensionsTests
{
    private readonly ActivitySource _source = new("TestSource", "1.0.0");

    [Test]
    public async Task RecordException_AddsExceptionEvent()
    {
        using var activity = _source.StartActivity("test");
        var ex = new InvalidOperationException("Test error");

        activity?.RecordException(ex);

        var events = activity?.Events.ToList() ?? [];
        await Assert.That(events.Count).IsGreaterThanOrEqualTo(1);
        await Assert.That(events[0].Name).IsEqualTo("exception");
    }

    [Test]
    public async Task RecordException_SetsErrorStatus()
    {
        using var activity = _source.StartActivity("test");
        var ex = new InvalidOperationException("Test error");

        activity?.RecordException(ex);

        await Assert.That(activity?.Status).IsEqualTo(ActivityStatusCode.Error);
    }

    [Test]
    public async Task SetSuccess_SetsOkStatus()
    {
        using var activity = _source.StartActivity("test");

        activity?.SetSuccess("All good");

        await Assert.That(activity?.Status).IsEqualTo(ActivityStatusCode.Ok);
    }

    [Test]
    public async Task SetError_SetsErrorStatus()
    {
        using var activity = _source.StartActivity("test");

        activity?.SetError("Something failed");

        await Assert.That(activity?.Status).IsEqualTo(ActivityStatusCode.Error);
    }

    [Test]
    public async Task SetTagIfNotEmpty_AddsTag_WhenValueNotEmpty()
    {
        using var activity = _source.StartActivity("test");

        activity?.SetTagIfNotEmpty("key", "value");

        var tag = activity?.Tags.FirstOrDefault(t => t.Key == "key");
        await Assert.That(tag?.Value).IsEqualTo("value");
    }

    [Test]
    public async Task SetTagIfNotEmpty_DoesNotAddTag_WhenValueEmpty()
    {
        using var activity = _source.StartActivity("test");

        activity?.SetTagIfNotEmpty("key", "");

        var hasTag = activity?.Tags.Any(t => t.Key == "key") ?? false;
        await Assert.That(hasTag).IsFalse();
    }

    [Test]
    public async Task RecordException_HandlesNullActivity()
    {
        Activity? activity = null;
        var ex = new InvalidOperationException("Test");

        // Should not throw
        activity.RecordException(ex);
        
        await Assert.That(true).IsTrue(); // Just verify no exception
    }
}
CSHARP

# Test: JsonTelemetryFileWriterTests.cs
cat > "$CORE_TESTS_DIR/Telemetry/JsonTelemetryFileWriterTests.cs" << 'CSHARP'
using MyImapDownloader.Core.Infrastructure;
using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Core.Tests.Telemetry;

public class JsonTelemetryFileWriterTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("writer_test");
    private readonly List<JsonTelemetryFileWriter> _writers = [];

    public async ValueTask DisposeAsync()
    {
        foreach (var writer in _writers)
        {
            writer.Dispose();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private JsonTelemetryFileWriter CreateWriter(
        string? subDir = null,
        string prefix = "test",
        long maxSize = 1024 * 1024)
    {
        var dir = subDir != null
            ? Path.Combine(_temp.Path, subDir)
            : _temp.Path;
        Directory.CreateDirectory(dir);

        var writer = new JsonTelemetryFileWriter(
            dir, prefix, maxSize, TimeSpan.FromSeconds(30));
        _writers.Add(writer);
        return writer;
    }

    [Test]
    public async Task Enqueue_CreatesFile_AfterFlush()
    {
        var writer = CreateWriter("enqueue_test");

        writer.Enqueue(new { Message = "test" });
        await writer.FlushAsync();

        var files = Directory.GetFiles(_temp.Path, "*.jsonl", SearchOption.AllDirectories);
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }

    [Test]
    public async Task Enqueue_WritesJsonLines()
    {
        var writer = CreateWriter("jsonl_test");

        writer.Enqueue(new { Id = 1, Name = "First" });
        writer.Enqueue(new { Id = 2, Name = "Second" });
        await writer.FlushAsync();

        var files = Directory.GetFiles(Path.Combine(_temp.Path, "jsonl_test"), "*.jsonl");
        await Assert.That(files.Length).IsEqualTo(1);

        var lines = await File.ReadAllLinesAsync(files[0]);
        await Assert.That(lines.Length).IsEqualTo(2);
        await Assert.That(lines[0]).Contains("\"Id\":1");
        await Assert.That(lines[1]).Contains("\"Id\":2");
    }

    [Test]
    public async Task Writer_RotatesFile_WhenSizeExceeded()
    {
        var writer = CreateWriter("rotate_test", maxSize: 100);

        // Write enough data to trigger rotation
        for (int i = 0; i < 10; i++)
        {
            writer.Enqueue(new { Index = i, Data = new string('x', 50) });
            await writer.FlushAsync();
        }

        var files = Directory.GetFiles(Path.Combine(_temp.Path, "rotate_test"), "*.jsonl");
        await Assert.That(files.Length).IsGreaterThan(1);
    }

    [Test]
    public async Task Dispose_FlushesRemainingRecords()
    {
        var subDir = Path.Combine(_temp.Path, "dispose_test");
        Directory.CreateDirectory(subDir);

        var writer = new JsonTelemetryFileWriter(
            subDir, "test", 1024 * 1024, TimeSpan.FromMinutes(5));

        writer.Enqueue(new { FinalRecord = true });
        writer.Dispose();

        await Task.Delay(100);

        var files = Directory.GetFiles(subDir, "*.jsonl");
        await Assert.That(files.Length).IsGreaterThanOrEqualTo(1);
    }
}
CSHARP

# Test: EmailMetadataTests.cs
cat > "$CORE_TESTS_DIR/Data/EmailMetadataTests.cs" << 'CSHARP'
using MyImapDownloader.Core.Data;

namespace MyImapDownloader.Core.Tests.Data;

public class EmailMetadataTests
{
    [Test]
    public async Task EmailMetadata_RequiredProperties_MustBeSet()
    {
        var metadata = new EmailMetadata
        {
            MessageId = "test@example.com"
        };

        await Assert.That(metadata.MessageId).IsEqualTo("test@example.com");
    }

    [Test]
    public async Task EmailMetadata_OptionalProperties_CanBeNull()
    {
        var metadata = new EmailMetadata
        {
            MessageId = "test@example.com"
        };

        await Assert.That(metadata.Subject).IsNull();
        await Assert.That(metadata.From).IsNull();
        await Assert.That(metadata.To).IsNull();
        await Assert.That(metadata.Date).IsNull();
    }

    [Test]
    public async Task EmailMetadata_WithAllProperties_PreservesValues()
    {
        var now = DateTimeOffset.UtcNow;
        var metadata = new EmailMetadata
        {
            MessageId = "full@example.com",
            Subject = "Test Subject",
            From = "sender@example.com",
            To = "recipient@example.com",
            Cc = "cc@example.com",
            Date = now,
            Folder = "INBOX",
            ArchivedAt = now,
            HasAttachments = true,
            SizeBytes = 1024,
            Account = "user@example.com"
        };

        await Assert.That(metadata.Subject).IsEqualTo("Test Subject");
        await Assert.That(metadata.From).IsEqualTo("sender@example.com");
        await Assert.That(metadata.HasAttachments).IsTrue();
        await Assert.That(metadata.SizeBytes).IsEqualTo(1024);
    }
}
CSHARP

# =============================================================================
# 8. Update solution and project references
# =============================================================================
echo "[8/8] Updating solution and project references..."

# Update MyImapDownloader.slnx to include new projects
if [ -f "$PROJECT_ROOT/MyImapDownloader.slnx" ]; then
    cat > "$PROJECT_ROOT/MyImapDownloader.slnx" << 'SLNX'
<Solution>
  <Folder Name="/Solution Items/">
    <File Path="README.md" />
    <File Path="LICENSE" />
    <File Path=".editorconfig" />
    <File Path="Directory.Build.props" />
    <File Path="Directory.Packages.props" />
    <File Path="global.json" />
  </Folder>
  <Project Path="MyImapDownloader.Core/MyImapDownloader.Core.csproj" />
  <Project Path="MyImapDownloader.Core.Tests/MyImapDownloader.Core.Tests.csproj" />
  <Project Path="MyImapDownloader/MyImapDownloader.csproj" />
  <Project Path="MyImapDownloader.Tests/MyImapDownloader.Tests.csproj" />
  <Project Path="MyEmailSearch/MyEmailSearch.csproj" />
  <Project Path="MyEmailSearch.Tests/MyEmailSearch.Tests.csproj" />
</Solution>
SLNX
fi

echo ""
echo "=========================================="
echo "✅ MyImapDownloader.Core created successfully!"
echo ""
echo "New project structure:"
echo "  MyImapDownloader.Core/"
echo "    ├── Telemetry/"
echo "    │   ├── DiagnosticsConfig.cs"
echo "    │   ├── TelemetryConfiguration.cs"
echo "    │   ├── JsonTelemetryFileWriter.cs"
echo "    │   ├── ActivityExtensions.cs"
echo "    │   ├── JsonFileLogExporter.cs"
echo "    │   ├── JsonFileTraceExporter.cs"
echo "    │   ├── JsonFileMetricsExporter.cs"
echo "    │   ├── TelemetryDirectoryResolver.cs"
echo "    │   └── TelemetryExtensions.cs"
echo "    ├── Configuration/"
echo "    │   └── PathResolver.cs"
echo "    ├── Data/"
echo "    │   └── EmailMetadata.cs"
echo "    └── Infrastructure/"
echo "        ├── SqliteHelper.cs"
echo "        ├── TempDirectory.cs"
echo "        └── TestLogger.cs"
echo ""
echo "  MyImapDownloader.Core.Tests/"
echo "    ├── Telemetry/"
echo "    ├── Configuration/"
echo "    ├── Infrastructure/"
echo "    └── Data/"
echo ""
echo "Next steps:"
echo "  1. Update MyImapDownloader to reference MyImapDownloader.Core"
echo "  2. Update MyEmailSearch to reference MyImapDownloader.Core"
echo "  3. Remove duplicate code from original projects"
echo "  4. Run: dotnet build"
echo "  5. Run: dotnet test"
echo "=========================================="
==========================================
Creating MyImapDownloader.Core Library
Project Root: /home/kushal/src/dotnet/MyImapDownloader
==========================================

[1/8] Creating directory structure...
[2/8] Creating MyImapDownloader.Core.csproj...
[3/8] Creating Telemetry components...
[4/8] Creating Configuration components...
[5/8] Creating Data models...
[6/8] Creating Infrastructure components...
[7/8] Creating Core Tests project...
implement-common-core.sh: line 1775: /home/kushal/src/dotnet/MyImapDownloader/MyImapDownloader.Core.Tests/Data/EmailMetadataTests.cs: No such file or directory

real	0m0.025s
user	0m0.010s
sys	0m0.016s
#!/bin/bash
# =============================================================================
# Update Existing Projects to Use MyImapDownloader.Core
# =============================================================================
# This script updates MyImapDownloader and MyEmailSearch to reference the
# new shared Core library and removes duplicated code.
# =============================================================================

set -euo pipefail

PROJECT_ROOT="${1:-$(pwd)}"

echo "=========================================="
echo "Updating projects to use Core library"
echo "=========================================="

# =============================================================================
# 1. Update MyImapDownloader.csproj
# =============================================================================
echo ""
echo "[1/6] Updating MyImapDownloader.csproj..."

cat > "$PROJECT_ROOT/MyImapDownloader/MyImapDownloader.csproj" << 'CSPROJ'
<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyImapDownloader - Email Archive Downloader
    
    Downloads emails from IMAP servers and archives them locally.
    Uses MyImapDownloader.Core for shared infrastructure.
  -->
  
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <RootNamespace>MyImapDownloader</RootNamespace>
    <AssemblyName>MyImapDownloader</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <!-- Core library reference -->
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- CLI -->
    <PackageReference Include="CommandLineParser" />
    
    <!-- IMAP -->
    <PackageReference Include="MailKit" />
    
    <!-- Resilience -->
    <PackageReference Include="Polly" />
    
    <!-- Configuration & Hosting -->
    <PackageReference Include="Microsoft.Extensions.Hosting" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
CSPROJ

# =============================================================================
# 2. Update MyImapDownloader to use Core telemetry
# =============================================================================
echo "[2/6] Updating MyImapDownloader/Telemetry/DiagnosticsConfig.cs..."

cat > "$PROJECT_ROOT/MyImapDownloader/Telemetry/DiagnosticsConfig.cs" << 'CSHARP'
using System.Diagnostics.Metrics;
using MyImapDownloader.Core.Telemetry;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Application-specific diagnostics configuration for MyImapDownloader.
/// Extends the core telemetry infrastructure with email-specific metrics.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyImapDownloader";
    public const string ServiceVersion = "1.0.0";

    private static readonly DiagnosticsConfigBase _base = new(ServiceName, ServiceVersion);

    public static System.Diagnostics.ActivitySource ActivitySource => _base.ActivitySource;
    public static Meter Meter => _base.Meter;

    // Email download metrics
    public static readonly Counter<long> EmailsDownloaded = _base.CreateCounter<long>(
        "emails.downloaded", "emails", "Total emails downloaded");

    public static readonly Counter<long> BytesDownloaded = _base.CreateCounter<long>(
        "bytes.downloaded", "bytes", "Total bytes downloaded");

    public static readonly Histogram<double> DownloadLatency = _base.CreateHistogram<double>(
        "download.latency", "ms", "Email download latency");

    public static readonly Counter<long> RetryAttempts = _base.CreateCounter<long>(
        "retry.attempts", "attempts", "Number of retry attempts");

    // Storage metrics
    public static readonly Counter<long> FilesWritten = _base.CreateCounter<long>(
        "storage.files.written", "files", "Number of email files written");

    public static readonly Counter<long> BytesWritten = _base.CreateCounter<long>(
        "storage.bytes.written", "bytes", "Total bytes written to disk");

    public static readonly Histogram<double> WriteLatency = _base.CreateHistogram<double>(
        "storage.write.latency", "ms", "Disk write latency");

    // Connection metrics
    private static int _activeConnections;
    private static int _queuedEmails;
    private static long _totalEmailsInSession;

    public static readonly ObservableGauge<int> ActiveConnections = _base.Meter.CreateObservableGauge(
        "connections.active", () => _activeConnections, "connections", "Active IMAP connections");

    public static readonly ObservableGauge<int> QueuedEmails = _base.Meter.CreateObservableGauge(
        "emails.queued", () => _queuedEmails, "emails", "Emails queued for processing");

    public static readonly ObservableGauge<long> TotalEmailsInSession = _base.Meter.CreateObservableGauge(
        "emails.total.session", () => _totalEmailsInSession, "emails", "Total emails in session");

    public static void SetActiveConnections(int count) => _activeConnections = count;
    public static void IncrementActiveConnections() => Interlocked.Increment(ref _activeConnections);
    public static void DecrementActiveConnections() => Interlocked.Decrement(ref _activeConnections);
    public static void SetQueuedEmails(int count) => _queuedEmails = count;
    public static void IncrementTotalEmails() => Interlocked.Increment(ref _totalEmailsInSession);
}
CSHARP

# =============================================================================
# 3. Create MyImapDownloader TelemetryExtensions that uses Core
# =============================================================================
echo "[3/6] Updating MyImapDownloader/Telemetry/TelemetryExtensions.cs..."

cat > "$PROJECT_ROOT/MyImapDownloader/Telemetry/TelemetryExtensions.cs" << 'CSHARP'
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using MyImapDownloader.Core.Telemetry;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace MyImapDownloader.Telemetry;

/// <summary>
/// Extension methods for configuring telemetry in MyImapDownloader.
/// </summary>
public static class TelemetryExtensions
{
    /// <summary>
    /// Adds telemetry services using the Core infrastructure.
    /// </summary>
    public static IServiceCollection AddTelemetry(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        return services.AddCoreTelemetry(
            configuration,
            DiagnosticsConfig.ServiceName,
            DiagnosticsConfig.ServiceVersion);
    }

    /// <summary>
    /// Adds telemetry logging.
    /// </summary>
    public static ILoggingBuilder AddTelemetryLogging(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        var config = new TelemetryConfiguration();
        configuration.GetSection(TelemetryConfiguration.SectionName).Bind(config);

        if (!config.EnableLogging)
            return builder;

        var telemetryBaseDir = TelemetryDirectoryResolver.ResolveTelemetryDirectory(config.ServiceName);
        if (telemetryBaseDir == null)
            return builder;

        var logsDir = Path.Combine(telemetryBaseDir, "logs");
        Directory.CreateDirectory(logsDir);

        var flushInterval = TimeSpan.FromSeconds(config.FlushIntervalSeconds);

        try
        {
            var logsWriter = new JsonTelemetryFileWriter(
                logsDir, "logs", config.MaxFileSizeBytes, flushInterval);

            builder.AddOpenTelemetry(options =>
            {
                options.IncludeFormattedMessage = true;
                options.IncludeScopes = true;
                options.ParseStateValues = true;
                options.AddProcessor(new BatchLogRecordExportProcessor(
                    new JsonFileLogExporter(logsWriter),
                    maxQueueSize: 2048,
                    scheduledDelayMilliseconds: (int)flushInterval.TotalMilliseconds,
                    exporterTimeoutMilliseconds: 30000,
                    maxExportBatchSize: 512));
            });
        }
        catch
        {
            // Continue without log telemetry
        }

        return builder;
    }
}
CSHARP

# =============================================================================
# 4. Update MyEmailSearch.csproj
# =============================================================================
echo "[4/6] Updating MyEmailSearch.csproj..."

cat > "$PROJECT_ROOT/MyEmailSearch/MyEmailSearch.csproj" << 'CSPROJ'
<Project Sdk="Microsoft.NET.Sdk">
  <!--
    MyEmailSearch - Email Archive Search Utility
    
    Provides search capabilities over archived emails.
    Uses MyImapDownloader.Core for shared infrastructure.
  -->
  
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <RootNamespace>MyEmailSearch</RootNamespace>
    <AssemblyName>MyEmailSearch</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <!-- Core library reference -->
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <!-- CLI Framework -->
    <PackageReference Include="System.CommandLine" />
    
    <!-- Email Parsing -->
    <PackageReference Include="MimeKit" />
    
    <!-- SQLite (additional to Core for FTS5) -->
    <PackageReference Include="SQLitePCLRaw.bundle_e_sqlite3" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
CSPROJ

# =============================================================================
# 5. Create MyEmailSearch DiagnosticsConfig
# =============================================================================
echo "[5/6] Creating MyEmailSearch/Telemetry/DiagnosticsConfig.cs..."

mkdir -p "$PROJECT_ROOT/MyEmailSearch/Telemetry"

cat > "$PROJECT_ROOT/MyEmailSearch/Telemetry/DiagnosticsConfig.cs" << 'CSHARP'
using System.Diagnostics.Metrics;
using MyImapDownloader.Core.Telemetry;

namespace MyEmailSearch.Telemetry;

/// <summary>
/// Application-specific diagnostics configuration for MyEmailSearch.
/// </summary>
public static class DiagnosticsConfig
{
    public const string ServiceName = "MyEmailSearch";
    public const string ServiceVersion = "1.0.0";

    private static readonly DiagnosticsConfigBase _base = new(ServiceName, ServiceVersion);

    public static System.Diagnostics.ActivitySource ActivitySource => _base.ActivitySource;
    public static Meter Meter => _base.Meter;

    // Search metrics
    public static readonly Counter<long> SearchesExecuted = _base.CreateCounter<long>(
        "searches.executed", "queries", "Total search queries executed");

    public static readonly Counter<long> SearchErrors = _base.CreateCounter<long>(
        "searches.errors", "errors", "Search query errors");

    public static readonly Histogram<double> SearchDuration = _base.CreateHistogram<double>(
        "search.duration", "ms", "Search query execution time");

    public static readonly Histogram<long> SearchResultCount = _base.CreateHistogram<long>(
        "search.results", "emails", "Number of results per search");

    // Indexing metrics
    public static readonly Counter<long> EmailsIndexed = _base.CreateCounter<long>(
        "indexing.emails", "emails", "Emails indexed");

    public static readonly Counter<long> IndexingErrors = _base.CreateCounter<long>(
        "indexing.errors", "errors", "Indexing errors");

    public static readonly Histogram<double> IndexingDuration = _base.CreateHistogram<double>(
        "indexing.duration", "ms", "Indexing operation duration");
}
CSHARP

# =============================================================================
# 6. Update test projects
# =============================================================================
echo "[6/6] Updating test projects..."

# Update MyImapDownloader.Tests.csproj
cat > "$PROJECT_ROOT/MyImapDownloader.Tests/MyImapDownloader.Tests.csproj" << 'CSPROJ'
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="AwesomeAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyImapDownloader\MyImapDownloader.csproj" />
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>
</Project>
CSPROJ

# Update MyEmailSearch.Tests.csproj
cat > "$PROJECT_ROOT/MyEmailSearch.Tests/MyEmailSearch.Tests.csproj" << 'CSPROJ'
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="TUnit" />
    <PackageReference Include="NSubstitute" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="AwesomeAssertions" />
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyEmailSearch\MyEmailSearch.csproj" />
    <ProjectReference Include="..\MyImapDownloader.Core\MyImapDownloader.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Update="TestFixtures\SampleEmails\**\*">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>
CSPROJ

echo ""
echo "=========================================="
echo "✅ Projects updated to use Core library!"
echo ""
echo "Changes made:"
echo "  - MyImapDownloader now references MyImapDownloader.Core"
echo "  - MyEmailSearch now references MyImapDownloader.Core"
echo "  - DiagnosticsConfig classes use Core's DiagnosticsConfigBase"
echo "  - Test projects reference both app and Core projects"
echo ""
echo "Files you can now delete (duplicates):"
echo "  - MyImapDownloader/Telemetry/TelemetryConfiguration.cs"
echo "  - MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs"
echo "  - MyImapDownloader/Telemetry/JsonFileLogExporter.cs"
echo "  - MyImapDownloader/Telemetry/JsonFileTraceExporter.cs"
echo "  - MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs"
echo "  - MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs"
echo "  - MyImapDownloader/Telemetry/ActivityExtension.cs"
echo "  - MyEmailSearch/Configuration/PathResolver.cs (use Core's)"
echo ""
echo "Next steps:"
echo "  1. Delete the duplicate files listed above"
echo "  2. Update 'using' statements in remaining files"
echo "  3. Run: dotnet build"
echo "  4. Run: dotnet test"
echo "=========================================="
==========================================
Updating projects to use Core library
==========================================

[1/6] Updating MyImapDownloader.csproj...
[2/6] Updating MyImapDownloader/Telemetry/DiagnosticsConfig.cs...
[3/6] Updating MyImapDownloader/Telemetry/TelemetryExtensions.cs...
[4/6] Updating MyEmailSearch.csproj...
[5/6] Creating MyEmailSearch/Telemetry/DiagnosticsConfig.cs...
[6/6] Updating test projects...

==========================================
✅ Projects updated to use Core library!

Changes made:
  - MyImapDownloader now references MyImapDownloader.Core
  - MyEmailSearch now references MyImapDownloader.Core
  - DiagnosticsConfig classes use Core's DiagnosticsConfigBase
  - Test projects reference both app and Core projects

Files you can now delete (duplicates):
  - MyImapDownloader/Telemetry/TelemetryConfiguration.cs
  - MyImapDownloader/Telemetry/JsonTelemetryFileWriter.cs
  - MyImapDownloader/Telemetry/JsonFileLogExporter.cs
  - MyImapDownloader/Telemetry/JsonFileTraceExporter.cs
  - MyImapDownloader/Telemetry/JsonFileMetricsExporter.cs
  - MyImapDownloader/Telemetry/TelemetryDirectoryResolver.cs
  - MyImapDownloader/Telemetry/ActivityExtension.cs
  - MyEmailSearch/Configuration/PathResolver.cs (use Core's)

Next steps:
  1. Delete the duplicate files listed above
  2. Update 'using' statements in remaining files
  3. Run: dotnet build
  4. Run: dotnet test
==========================================

real	0m0.008s
user	0m0.003s
sys	0m0.006s
#!/bin/bash
# =============================================================================
# Create Comprehensive Unit Tests for MyImapDownloader System
# =============================================================================
# This script creates ALL unit tests for:
#   - MyImapDownloader.Core (shared infrastructure)
#   - MyImapDownloader (email downloader)
#   - MyEmailSearch (email search)
# =============================================================================

set -euo pipefail

PROJECT_ROOT="${1:-$(pwd)}"

echo "=========================================="
echo "Creating Comprehensive Unit Tests"
echo "=========================================="

# =============================================================================
# PART 1: MyImapDownloader Tests
# =============================================================================
echo ""
echo "[PART 1] Creating MyImapDownloader Tests..."

DOWNLOADER_TESTS="$PROJECT_ROOT/MyImapDownloader.Tests"
mkdir -p "$DOWNLOADER_TESTS/Telemetry"
mkdir -p "$DOWNLOADER_TESTS/Services"

# -----------------------------------------------------------------------------
# DownloadOptionsTests.cs
# -----------------------------------------------------------------------------
cat > "$DOWNLOADER_TESTS/DownloadOptionsTests.cs" << 'CSHARP'
namespace MyImapDownloader.Tests;

public class DownloadOptionsTests
{
    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var options = new DownloadOptions
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret",
            OutputDirectory = "/output"
        };

        await Assert.That(options.Server).IsEqualTo("imap.example.com");
        await Assert.That(options.Username).IsEqualTo("user@example.com");
        await Assert.That(options.Password).IsEqualTo("secret");
        await Assert.That(options.OutputDirectory).IsEqualTo("/output");
    }

    [Test]
    public async Task Port_DefaultsToZero()
    {
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test"
        };

        await Assert.That(options.Port).IsEqualTo(993);
    }

    [Test]
    public async Task AllFolders_DefaultsToFalse()
    {
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test"
        };

        await Assert.That(options.AllFolders).IsFalse();
    }

    [Test]
    public async Task Verbose_DefaultsToFalse()
    {
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test"
        };

        await Assert.That(options.Verbose).IsFalse();
    }

    [Test]
    public async Task StartDate_CanBeSet()
    {
        var date = new DateTime(2024, 1, 1);
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test",
            StartDate = date
        };

        await Assert.That(options.StartDate).IsEqualTo(date);
    }

    [Test]
    public async Task EndDate_CanBeSet()
    {
        var date = new DateTime(2024, 12, 31);
        var options = new DownloadOptions
        {
            Server = "test",
            Username = "test",
            Password = "test",
            OutputDirectory = "test",
            EndDate = date
        };

        await Assert.That(options.EndDate).IsEqualTo(date);
    }
}
CSHARP

# -----------------------------------------------------------------------------
# ImapConfigurationTests.cs
# -----------------------------------------------------------------------------
cat > "$DOWNLOADER_TESTS/ImapConfigurationTests.cs" << 'CSHARP'
namespace MyImapDownloader.Tests;

public class ImapConfigurationTests
{
    [Test]
    public async Task RequiredProperties_MustBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret"
        };

        await Assert.That(config.Server).IsEqualTo("imap.example.com");
        await Assert.That(config.Username).IsEqualTo("user@example.com");
        await Assert.That(config.Password).IsEqualTo("secret");
    }

    [Test]
    public async Task UseSsl_DefaultsToTrue()
    {
        var config = new ImapConfiguration
        {
            Server = "test",
            Username = "test",
            Password = "test"
        };

        await Assert.That(config.UseSsl).IsTrue();
    }

    [Test]
    public async Task Port_CanBeSet()
    {
        var config = new ImapConfiguration
        {
            Server = "test",
            Username = "test",
            Password = "test",
            Port = 143
        };

        await Assert.That(config.Port).IsEqualTo(143);
    }

    [Test]
    [Arguments(993, true)]
    [Arguments(143, false)]
    [Arguments(587, false)]
    public async Task CommonConfigurations_AreValid(int port, bool useSsl)
    {
        var config = new ImapConfiguration
        {
            Server = "imap.example.com",
            Username = "user@example.com",
            Password = "secret",
            Port = port,
            UseSsl = useSsl
        };

        await Assert.That(config.Port).IsEqualTo(port);
        await Assert.That(config.UseSsl).IsEqualTo(useSsl);
    }
}
CSHARP

# -----------------------------------------------------------------------------
# EmailDownloadExceptionTests.cs
# -----------------------------------------------------------------------------
cat > "$DOWNLOADER_TESTS/EmailDownloadExceptionTests.cs" << 'CSHARP'
namespace MyImapDownloader.Tests;

public class EmailDownloadExceptionTests
{
    [Test]
    public async Task Constructor_SetsMessage()
    {
        var ex = new EmailDownloadException(
            "Test error",
            42,
            new InvalidOperationException("Inner"));

        await Assert.That(ex.Message).IsEqualTo("Test error");
    }

    [Test]
    public async Task Constructor_SetsMessageIndex()
    {
        var ex = new EmailDownloadException(
            "Test error",
            42,
            new InvalidOperationException("Inner"));

        await Assert.That(ex.MessageIndex).IsEqualTo(42);
    }

    [Test]
    public async Task Constructor_SetsInnerException()
    {
        var inner = new InvalidOperationException("Inner error");
        var ex = new EmailDownloadException("Test", 0, inner);

        await Assert.That(ex.InnerException).IsEqualTo(inner);
    }

    [Test]
    public async Task Exception_CanBeThrown()
    {
        var act = () =>
        {
            throw new EmailDownloadException(
                "Download failed",
                5,
                new IOException("Network error"));
        };

        await Assert.That(act).ThrowsException();
    }

    [Test]
    [Arguments(0)]
    [Arguments(1)]
    [Arguments(100)]
    [Arguments(int.MaxValue)]
    public async Task MessageIndex_AcceptsVariousValues(int index)
    {
        var ex = new EmailDownloadException(
            "Test",
            index,
            new Exception());

        await Assert.That(ex.MessageIndex).IsEqualTo(index);
    }
}
CSHARP

# -----------------------------------------------------------------------------
# EmailStorageServiceTests.cs
# -----------------------------------------------------------------------------
cat > "$DOWNLOADER_TESTS/Services/EmailStorageServiceTests.cs" << 'CSHARP'
using AwesomeAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using MimeKit;
using MyImapDownloader.Core.Infrastructure;

namespace MyImapDownloader.Tests.Services;

public class EmailStorageServiceTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("storage_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    private EmailStorageService CreateService()
    {
        return new EmailStorageService(
            NullLogger<EmailStorageService>.Instance,
            _temp.Path);
    }

    private static MemoryStream CreateSimpleEmail(
        string messageId,
        string subject = "Test",
        string body = "Hello")
    {
        var msg = new MimeMessage();
        msg.From.Add(new MailboxAddress("Sender", "sender@test.com"));
        msg.To.Add(new MailboxAddress("Receiver", "receiver@test.com"));
        msg.Subject = subject;
        msg.MessageId = messageId;
        msg.Body = new TextPart("plain") { Text = body };

        var ms = new MemoryStream();
        msg.WriteTo(ms);
        ms.Position = 0;
        return ms;
    }

    [Test]
    public async Task InitializeAsync_CreatesDatabase()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        var dbPath = Path.Combine(_temp.Path, "index.v1.db");
        await Assert.That(File.Exists(dbPath)).IsTrue();
    }

    [Test]
    public async Task SaveStreamAsync_CreatesMaildirStructure()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<test1@example.com>");
        var saved = await service.SaveStreamAsync(
            stream,
            "<test1@example.com>",
            DateTimeOffset.UtcNow,
            "INBOX",
            CancellationToken.None);

        await Assert.That(saved).IsTrue();

        var inboxPath = Path.Combine(_temp.Path, "INBOX");
        await Assert.That(Directory.Exists(Path.Combine(inboxPath, "cur"))).IsTrue();
        await Assert.That(Directory.Exists(Path.Combine(inboxPath, "new"))).IsTrue();
        await Assert.That(Directory.Exists(Path.Combine(inboxPath, "tmp"))).IsTrue();
    }

    [Test]
    public async Task SaveStreamAsync_DeduplicatesByMessageId()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream1 = CreateSimpleEmail("<dup@test.com>");
        using var stream2 = CreateSimpleEmail("<dup@test.com>");

        var first = await service.SaveStreamAsync(
            stream1, "<dup@test.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);
        var second = await service.SaveStreamAsync(
            stream2, "<dup@test.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);

        await Assert.That(first).IsTrue();
        await Assert.That(second).IsFalse();
    }

    [Test]
    public async Task SaveStreamAsync_CreatesSidecarMetadata()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<meta@test.com>", "Test Subject");
        await service.SaveStreamAsync(
            stream, "<meta@test.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);

        var curPath = Path.Combine(_temp.Path, "INBOX", "cur");
        var metaFiles = Directory.GetFiles(curPath, "*.meta.json");
        
        await Assert.That(metaFiles.Length).IsEqualTo(1);
        
        var content = await File.ReadAllTextAsync(metaFiles[0]);
        content.Should().Contain("Test Subject");
    }

    [Test]
    public async Task SaveStreamAsync_SanitizesMessageIdWithSlashes()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        using var stream = CreateSimpleEmail("<user/repo/test@github.com>");
        var saved = await service.SaveStreamAsync(
            stream, "<user/repo/test@github.com>", DateTimeOffset.UtcNow, "INBOX", CancellationToken.None);

        await Assert.That(saved).IsTrue();

        var curPath = Path.Combine(_temp.Path, "INBOX", "cur");
        var files = Directory.GetFiles(curPath, "*.eml");
        await Assert.That(files.Length).IsEqualTo(1);

        var fileName = Path.GetFileName(files[0]);
        fileName.Should().NotContain("/");
        fileName.Should().NotContain("\\");
    }

    [Test]
    public async Task GetLastUidAsync_ReturnsZero_WhenNoSyncState()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        var lastUid = await service.GetLastUidAsync("INBOX", 12345, CancellationToken.None);

        await Assert.That(lastUid).IsEqualTo(0);
    }

    [Test]
    public async Task UpdateLastUidAsync_PersistsUid()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        await service.UpdateLastUidAsync("INBOX", 100, 12345, CancellationToken.None);
        var lastUid = await service.GetLastUidAsync("INBOX", 12345, CancellationToken.None);

        await Assert.That(lastUid).IsEqualTo(100);
    }

    [Test]
    public async Task GetLastUidAsync_ResetsOnUidValidityChange()
    {
        var service = CreateService();
        await service.InitializeAsync(CancellationToken.None);

        await service.UpdateLastUidAsync("INBOX", 100, 12345, CancellationToken.None);
        var sameValidity = await service.GetLastUidAsync("INBOX", 12345, CancellationToken.None);
        var changedValidity = await service.GetLastUidAsync("INBOX", 99999, CancellationToken.None);

        await Assert.That(sameValidity).IsEqualTo(100);
        await Assert.That(changedValidity).IsEqualTo(0);
    }

    [Test]
    public async Task NormalizeMessageId_RemovesInvalidCharacters()
    {
        var normalized = EmailStorageService.NormalizeMessageId("<test/path:id@example.com>");
        
        normalized.Should().NotContain("/");
        normalized.Should().NotContain(":");
        normalized.Should().NotContain("<");
        normalized.Should().NotContain(">");
    }

    [Test]
    public async Task ComputeHash_ReturnsConsistentHash()
    {
        var hash1 = EmailStorageService.ComputeHash("test input");
        var hash2 = EmailStorageService.ComputeHash("test input");
        var hash3 = EmailStorageService.ComputeHash("different input");

        await Assert.That(hash1).IsEqualTo(hash2);
        await Assert.That(hash1).IsNotEqualTo(hash3);
    }
}
CSHARP

# -----------------------------------------------------------------------------
# EmailStorageSanitizationTests.cs
# -----------------------------------------------------------------------------
cat > "$DOWNLOADER_TESTS/Services/EmailStorageSanitizationTests.cs" << 'CSHARP'
using AwesomeAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using MyImapDownloader.Core.Infrastructure;

namespace MyImapDownloader.Tests.Services;

public class EmailStorageSanitizationTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("sanitize_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    [Test]
    [Arguments("<simple@test.com>", "simple_test.com")]
    [Arguments("<path/with/slashes@test.com>", "path_with_slashes_test.com")]
    [Arguments("<spaces here@test.com>", "spaces_here_test.com")]
    public async Task NormalizeMessageId_SanitizesCorrectly(string input, string expected)
    {
        var result = EmailStorageService.NormalizeMessageId(input);
        result.Should().NotContain("/");
        result.Should().NotContain("\\");
        result.Should().NotContain("<");
        result.Should().NotContain(">");
    }

    [Test]
    public async Task SanitizeForFilename_TruncatesLongInput()
    {
        var longInput = new string('a', 200);
        var result = EmailStorageService.SanitizeForFilename(longInput, 50);
        
        await Assert.That(result.Length).IsLessThanOrEqualTo(50);
    }

    [Test]
    public async Task SanitizeForFilename_RemovesInvalidChars()
    {
        var input = "test<>:\"/\\|?*file";
        var result = EmailStorageService.SanitizeForFilename(input, 100);
        
        result.Should().NotContain("<");
        result.Should().NotContain(">");
        result.Should().NotContain(":");
        result.Should().NotContain("/");
        result.Should().NotContain("\\");
    }

    [Test]
    public async Task GenerateFilename_IsValidFilename()
    {
        var date = DateTimeOffset.FromUnixTimeSeconds(1700000000);
        var filename = EmailStorageService.GenerateFilename(date, "test_id");

        await Assert.That(Path.GetFileName(filename)).IsEqualTo(filename);
        filename.Should().EndWith(".eml");
    }
}
CSHARP

# =============================================================================
# PART 2: MyEmailSearch Tests
# =============================================================================
echo ""
echo "[PART 2] Creating MyEmailSearch Tests..."

SEARCH_TESTS="$PROJECT_ROOT/MyEmailSearch.Tests"
mkdir -p "$SEARCH_TESTS/Data"
mkdir -p "$SEARCH_TESTS/Search"
mkdir -p "$SEARCH_TESTS/Indexing"
mkdir -p "$SEARCH_TESTS/Integration"

# -----------------------------------------------------------------------------
# SearchDatabaseTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Data/SearchDatabaseTests.cs" << 'CSHARP'
using AwesomeAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using MyEmailSearch.Data;
using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Data;

public class SearchDatabaseTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("search_db_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<SearchDatabase> CreateDatabaseAsync()
    {
        var dbPath = Path.Combine(_temp.Path, "search.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;
        return db;
    }

    [Test]
    public async Task InitializeAsync_CreatesDatabase()
    {
        var db = await CreateDatabaseAsync();
        var dbPath = Path.Combine(_temp.Path, "search.db");
        await Assert.That(File.Exists(dbPath)).IsTrue();
    }

    [Test]
    public async Task UpsertEmailAsync_InsertsNewEmail()
    {
        var db = await CreateDatabaseAsync();
        var doc = CreateEmailDocument("test1@example.com");

        await db.UpsertEmailAsync(doc);
        var count = await db.GetEmailCountAsync();

        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task UpsertEmailAsync_UpdatesExistingEmail()
    {
        var db = await CreateDatabaseAsync();
        var doc1 = CreateEmailDocument("update@example.com", subject: "Original");
        var doc2 = CreateEmailDocument("update@example.com", subject: "Updated");

        await db.UpsertEmailAsync(doc1);
        await db.UpsertEmailAsync(doc2);
        var count = await db.GetEmailCountAsync();

        await Assert.That(count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_FindsByFullText()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("find1@example.com", subject: "Important Meeting"));
        await db.UpsertEmailAsync(CreateEmailDocument("find2@example.com", subject: "Casual Chat"));

        var results = await db.SearchAsync(new SearchQuery { ContentTerms = "important" });

        await Assert.That(results.Count).IsEqualTo(1);
        results[0].Subject.Should().Contain("Important");
    }

    [Test]
    public async Task SearchAsync_FiltersByFromAddress()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("from1@example.com", from: "alice@example.com"));
        await db.UpsertEmailAsync(CreateEmailDocument("from2@example.com", from: "bob@example.com"));

        var results = await db.SearchAsync(new SearchQuery { FromAddress = "alice@example.com" });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_FiltersByToAddress()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("to1@example.com", to: "recipient1@example.com"));
        await db.UpsertEmailAsync(CreateEmailDocument("to2@example.com", to: "recipient2@example.com"));

        var results = await db.SearchAsync(new SearchQuery { ToAddress = "recipient1@example.com" });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_FiltersByDateRange()
    {
        var db = await CreateDatabaseAsync();
        var jan = new DateTimeOffset(2024, 1, 15, 0, 0, 0, TimeSpan.Zero);
        var mar = new DateTimeOffset(2024, 3, 15, 0, 0, 0, TimeSpan.Zero);
        
        await db.UpsertEmailAsync(CreateEmailDocument("jan@example.com", date: jan));
        await db.UpsertEmailAsync(CreateEmailDocument("mar@example.com", date: mar));

        var results = await db.SearchAsync(new SearchQuery 
        { 
            DateFrom = new DateTimeOffset(2024, 2, 1, 0, 0, 0, TimeSpan.Zero),
            DateTo = new DateTimeOffset(2024, 4, 1, 0, 0, 0, TimeSpan.Zero)
        });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_CombinesMultipleFilters()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("combo1@example.com", 
            from: "alice@example.com", subject: "Project Update"));
        await db.UpsertEmailAsync(CreateEmailDocument("combo2@example.com", 
            from: "alice@example.com", subject: "Meeting Notes"));
        await db.UpsertEmailAsync(CreateEmailDocument("combo3@example.com", 
            from: "bob@example.com", subject: "Project Update"));

        var results = await db.SearchAsync(new SearchQuery 
        { 
            FromAddress = "alice@example.com",
            ContentTerms = "project"
        });

        await Assert.That(results.Count).IsEqualTo(1);
    }

    [Test]
    public async Task GetKnownFilesAsync_ReturnsAllFiles()
    {
        var db = await CreateDatabaseAsync();
        await db.UpsertEmailAsync(CreateEmailDocument("file1@example.com", filePath: "/path/to/file1.eml"));
        await db.UpsertEmailAsync(CreateEmailDocument("file2@example.com", filePath: "/path/to/file2.eml"));

        var files = await db.GetKnownFilesAsync();

        await Assert.That(files.Count).IsEqualTo(2);
    }

    [Test]
    public async Task IsHealthyAsync_ReturnsTrue_ForValidDatabase()
    {
        var db = await CreateDatabaseAsync();
        var healthy = await db.IsHealthyAsync();
        await Assert.That(healthy).IsTrue();
    }

    private static EmailDocument CreateEmailDocument(
        string messageId,
        string? subject = null,
        string? from = null,
        string? to = null,
        string? filePath = null,
        DateTimeOffset? date = null)
    {
        return new EmailDocument
        {
            MessageId = messageId,
            FilePath = filePath ?? $"/test/{messageId}.eml",
            Subject = subject ?? "Test Subject",
            FromAddress = from ?? "sender@example.com",
            ToAddress = to ?? "recipient@example.com",
            DateSent = date ?? DateTimeOffset.UtcNow,
            DateSentUnix = (date ?? DateTimeOffset.UtcNow).ToUnixTimeSeconds(),
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            LastModifiedTicks = DateTime.UtcNow.Ticks
        };
    }
}
CSHARP

# -----------------------------------------------------------------------------
# QueryParserTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Search/QueryParserTests.cs" << 'CSHARP'
using AwesomeAssertions;
using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

public class QueryParserTests
{
    private readonly QueryParser _parser = new();

    [Test]
    public async Task Parse_SimpleText_SetsContentTerms()
    {
        var result = _parser.Parse("hello world");
        
        await Assert.That(result.ContentTerms).IsEqualTo("hello world");
    }

    [Test]
    public async Task Parse_FromFilter_SetsFromAddress()
    {
        var result = _parser.Parse("from:alice@example.com");
        
        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
    }

    [Test]
    public async Task Parse_ToFilter_SetsToAddress()
    {
        var result = _parser.Parse("to:bob@example.com");
        
        await Assert.That(result.ToAddress).IsEqualTo("bob@example.com");
    }

    [Test]
    public async Task Parse_SubjectFilter_SetsSubject()
    {
        var result = _parser.Parse("subject:meeting");
        
        await Assert.That(result.Subject).IsEqualTo("meeting");
    }

    [Test]
    public async Task Parse_QuotedSubject_PreservesSpaces()
    {
        var result = _parser.Parse("subject:\"project update\"");
        
        await Assert.That(result.Subject).IsEqualTo("project update");
    }

    [Test]
    public async Task Parse_DateRange_SetsDateFromAndTo()
    {
        var result = _parser.Parse("date:2024-01-01..2024-12-31");
        
        await Assert.That(result.DateFrom?.Year).IsEqualTo(2024);
        await Assert.That(result.DateFrom?.Month).IsEqualTo(1);
        await Assert.That(result.DateTo?.Year).IsEqualTo(2024);
        await Assert.That(result.DateTo?.Month).IsEqualTo(12);
    }

    [Test]
    public async Task Parse_AfterDate_SetsDateFrom()
    {
        var result = _parser.Parse("after:2024-06-01");
        
        await Assert.That(result.DateFrom?.Year).IsEqualTo(2024);
        await Assert.That(result.DateFrom?.Month).IsEqualTo(6);
    }

    [Test]
    public async Task Parse_BeforeDate_SetsDateTo()
    {
        var result = _parser.Parse("before:2024-06-30");
        
        await Assert.That(result.DateTo?.Year).IsEqualTo(2024);
        await Assert.That(result.DateTo?.Month).IsEqualTo(6);
    }

    [Test]
    public async Task Parse_FolderFilter_SetsFolder()
    {
        var result = _parser.Parse("folder:INBOX");
        
        await Assert.That(result.Folder).IsEqualTo("INBOX");
    }

    [Test]
    public async Task Parse_AccountFilter_SetsAccount()
    {
        var result = _parser.Parse("account:user@example.com");
        
        await Assert.That(result.Account).IsEqualTo("user@example.com");
    }

    [Test]
    public async Task Parse_CombinedFilters_SetsAllFields()
    {
        var result = _parser.Parse("from:alice@example.com to:bob@example.com subject:meeting kafka");
        
        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(result.ToAddress).IsEqualTo("bob@example.com");
        await Assert.That(result.Subject).IsEqualTo("meeting");
        result.ContentTerms.Should().Contain("kafka");
    }

    [Test]
    public async Task Parse_EmptyQuery_ReturnsEmptySearchQuery()
    {
        var result = _parser.Parse("");
        
        await Assert.That(result.FromAddress).IsNull();
        await Assert.That(result.ToAddress).IsNull();
        await Assert.That(result.ContentTerms).IsNull();
    }

    [Test]
    public async Task Parse_CaseInsensitiveFilters_Works()
    {
        var result = _parser.Parse("FROM:alice@example.com SUBJECT:test");
        
        await Assert.That(result.FromAddress).IsEqualTo("alice@example.com");
        await Assert.That(result.Subject).IsEqualTo("test");
    }
}
CSHARP

# -----------------------------------------------------------------------------
# SnippetGeneratorTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Search/SnippetGeneratorTests.cs" << 'CSHARP'
using AwesomeAssertions;
using MyEmailSearch.Search;

namespace MyEmailSearch.Tests.Search;

public class SnippetGeneratorTests
{
    private readonly SnippetGenerator _generator = new();

    [Test]
    public async Task Generate_FindsMatchingTerm()
    {
        var text = "This is a test document with some important content.";
        var snippet = _generator.Generate(text, ["important"]);
        
        snippet.Should().Contain("important");
    }

    [Test]
    public async Task Generate_ReturnsEmptyForNullText()
    {
        var snippet = _generator.Generate(null, ["test"]);
        
        await Assert.That(snippet).IsEmpty();
    }

    [Test]
    public async Task Generate_ReturnsEmptyForNoTerms()
    {
        var text = "Some text here";
        var snippet = _generator.Generate(text, []);
        
        await Assert.That(snippet).IsNotNull();
    }

    [Test]
    public async Task Generate_TruncatesLongText()
    {
        var text = new string('a', 1000) + " important " + new string('b', 1000);
        var snippet = _generator.Generate(text, ["important"], maxLength: 100);
        
        await Assert.That(snippet.Length).IsLessThanOrEqualTo(110); // Allow some margin
    }

    [Test]
    public async Task Generate_HandlesMultipleTerms()
    {
        var text = "The quick brown fox jumps over the lazy dog.";
        var snippet = _generator.Generate(text, ["quick", "lazy"]);
        
        snippet.Should().NotBeEmpty();
    }
}
CSHARP

# -----------------------------------------------------------------------------
# ArchiveScannerTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Indexing/ArchiveScannerTests.cs" << 'CSHARP'
using Microsoft.Extensions.Logging.Abstractions;
using MyEmailSearch.Indexing;
using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

public class ArchiveScannerTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("scanner_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    [Test]
    public async Task ScanForEmails_FindsEmlFiles()
    {
        // Create test .eml files
        var curDir = Path.Combine(_temp.Path, "INBOX", "cur");
        Directory.CreateDirectory(curDir);
        await File.WriteAllTextAsync(Path.Combine(curDir, "test1.eml"), "Content 1");
        await File.WriteAllTextAsync(Path.Combine(curDir, "test2.eml"), "Content 2");

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(2);
    }

    [Test]
    public async Task ScanForEmails_RecursivelySearchesSubfolders()
    {
        var inbox = Path.Combine(_temp.Path, "INBOX", "cur");
        var sent = Path.Combine(_temp.Path, "Sent", "cur");
        Directory.CreateDirectory(inbox);
        Directory.CreateDirectory(sent);
        await File.WriteAllTextAsync(Path.Combine(inbox, "inbox.eml"), "Inbox");
        await File.WriteAllTextAsync(Path.Combine(sent, "sent.eml"), "Sent");

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(2);
    }

    [Test]
    public async Task ScanForEmails_IgnoresNonEmlFiles()
    {
        var curDir = Path.Combine(_temp.Path, "INBOX", "cur");
        Directory.CreateDirectory(curDir);
        await File.WriteAllTextAsync(Path.Combine(curDir, "test.eml"), "Email");
        await File.WriteAllTextAsync(Path.Combine(curDir, "test.meta.json"), "Metadata");
        await File.WriteAllTextAsync(Path.Combine(curDir, "test.txt"), "Text");

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(1);
        await Assert.That(files[0]).EndsWith(".eml");
    }

    [Test]
    public async Task ScanForEmails_ReturnsEmptyForEmptyDirectory()
    {
        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var files = scanner.ScanForEmails(_temp.Path).ToList();

        await Assert.That(files.Count).IsEqualTo(0);
    }
}
CSHARP

# -----------------------------------------------------------------------------
# EmailParserTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Indexing/EmailParserTests.cs" << 'CSHARP'
using AwesomeAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using MyEmailSearch.Indexing;
using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

public class EmailParserTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("parser_test");

    public async ValueTask DisposeAsync()
    {
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<string> CreateEmlFileAsync(string content)
    {
        var path = Path.Combine(_temp.Path, $"{Guid.NewGuid()}.eml");
        await File.WriteAllTextAsync(path, content);
        return path;
    }

    [Test]
    public async Task ParseAsync_ExtractsMessageId()
    {
        var emlContent = """
            Message-ID: <test123@example.com>
            Subject: Test
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Hello world
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc.Should().NotBeNull();
        await Assert.That(doc!.MessageId).IsEqualTo("test123@example.com");
    }

    [Test]
    public async Task ParseAsync_ExtractsSubject()
    {
        var emlContent = """
            Message-ID: <subject@example.com>
            Subject: Important Meeting Tomorrow
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Body
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc!.Subject).IsEqualTo("Important Meeting Tomorrow");
    }

    [Test]
    public async Task ParseAsync_ExtractsFromAddress()
    {
        var emlContent = """
            Message-ID: <from@example.com>
            Subject: Test
            From: Alice Smith <alice@example.com>
            To: bob@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Body
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        doc!.FromAddress.Should().Contain("alice@example.com");
    }

    [Test]
    public async Task ParseAsync_ExtractsBodyText_WhenRequested()
    {
        var emlContent = """
            Message-ID: <body@example.com>
            Subject: Test
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            This is the email body content.
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: true);

        doc!.BodyText.Should().Contain("email body content");
    }

    [Test]
    public async Task ParseAsync_SetsIndexedAtUnix()
    {
        var emlContent = """
            Message-ID: <indexed@example.com>
            Subject: Test
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Body
            """;

        var path = await CreateEmlFileAsync(emlContent);
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc!.IndexedAtUnix).IsGreaterThan(0);
    }

    [Test]
    public async Task ParseAsync_ReturnsNullForInvalidFile()
    {
        var path = Path.Combine(_temp.Path, "nonexistent.eml");
        var parser = new EmailParser(_temp.Path, NullLogger<EmailParser>.Instance);
        var doc = await parser.ParseAsync(path, includeFullBody: false);

        await Assert.That(doc).IsNull();
    }
}
CSHARP

# -----------------------------------------------------------------------------
# IndexManagerTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Indexing/IndexManagerTests.cs" << 'CSHARP'
using Microsoft.Extensions.Logging.Abstractions;
using MyEmailSearch.Data;
using MyEmailSearch.Indexing;
using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Indexing;

public class IndexManagerTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("index_mgr_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<string> CreateEmlFileAsync(string folder, string messageId, string subject)
    {
        var curDir = Path.Combine(_temp.Path, "archive", folder, "cur");
        Directory.CreateDirectory(curDir);
        
        var content = $"""
            Message-ID: <{messageId}>
            Subject: {subject}
            From: sender@example.com
            To: recipient@example.com
            Date: Mon, 01 Jan 2024 12:00:00 +0000
            Content-Type: text/plain

            Email body for {subject}
            """;
        
        var path = Path.Combine(curDir, $"{messageId.Replace("@", "_")}.eml");
        await File.WriteAllTextAsync(path, content);
        return path;
    }

    [Test]
    public async Task IndexAsync_IndexesNewEmails()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dbPath = Path.Combine(_temp.Path, "search.db");
        
        await CreateEmlFileAsync("INBOX", "test1@example.com", "First Email");
        await CreateEmlFileAsync("INBOX", "test2@example.com", "Second Email");

        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        var result = await manager.IndexAsync(archivePath, includeContent: true);

        await Assert.That(result.Indexed).IsEqualTo(2);
        await Assert.That(result.Errors).IsEqualTo(0);
    }

    [Test]
    public async Task IndexAsync_SkipsAlreadyIndexedFiles()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dbPath = Path.Combine(_temp.Path, "search.db");
        
        await CreateEmlFileAsync("INBOX", "existing@example.com", "Existing Email");

        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        // Index twice
        var result1 = await manager.IndexAsync(archivePath, includeContent: true);
        var result2 = await manager.IndexAsync(archivePath, includeContent: true);

        await Assert.That(result1.Indexed).IsEqualTo(1);
        await Assert.That(result2.Indexed).IsEqualTo(0);
        await Assert.That(result2.Skipped).IsEqualTo(1);
    }

    [Test]
    public async Task RebuildIndexAsync_ReindexesAllEmails()
    {
        var archivePath = Path.Combine(_temp.Path, "archive");
        var dbPath = Path.Combine(_temp.Path, "search.db");
        
        await CreateEmlFileAsync("INBOX", "rebuild@example.com", "Rebuild Test");

        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var scanner = new ArchiveScanner(NullLogger<ArchiveScanner>.Instance);
        var parser = new EmailParser(archivePath, NullLogger<EmailParser>.Instance);
        var manager = new IndexManager(db, scanner, parser, NullLogger<IndexManager>.Instance);

        // Index first
        await manager.IndexAsync(archivePath, includeContent: true);
        
        // Rebuild
        var result = await manager.RebuildIndexAsync(archivePath, includeContent: true);

        await Assert.That(result.Indexed).IsEqualTo(1);
    }
}
CSHARP

# -----------------------------------------------------------------------------
# SearchEngineTests.cs
# -----------------------------------------------------------------------------
cat > "$SEARCH_TESTS/Search/SearchEngineTests.cs" << 'CSHARP'
using AwesomeAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using MyEmailSearch.Data;
using MyEmailSearch.Search;
using MyImapDownloader.Core.Infrastructure;

namespace MyEmailSearch.Tests.Search;

public class SearchEngineTests : IAsyncDisposable
{
    private readonly TempDirectory _temp = new("search_engine_test");
    private SearchDatabase? _database;

    public async ValueTask DisposeAsync()
    {
        if (_database != null)
        {
            await _database.DisposeAsync();
        }
        await Task.Delay(100);
        _temp.Dispose();
    }

    private async Task<(SearchDatabase db, SearchEngine engine)> CreateServicesAsync()
    {
        var dbPath = Path.Combine(_temp.Path, "test.db");
        var db = new SearchDatabase(dbPath, NullLogger<SearchDatabase>.Instance);
        await db.InitializeAsync();
        _database = db;

        var queryParser = new QueryParser();
        var snippetGenerator = new SnippetGenerator();
        var engine = new SearchEngine(db, queryParser, snippetGenerator, 
            NullLogger<SearchEngine>.Instance);

        return (db, engine);
    }

    [Test]
    public async Task SearchAsync_ReturnsResults()
    {
        var (db, engine) = await CreateServicesAsync();
        await db.UpsertEmailAsync(CreateDocument("search@example.com", "Test Subject"));

        var results = await engine.SearchAsync("test");

        await Assert.That(results.TotalCount).IsEqualTo(1);
    }

    [Test]
    public async Task SearchAsync_AppliesPagination()
    {
        var (db, engine) = await CreateServicesAsync();
        for (int i = 0; i < 15; i++)
        {
            await db.UpsertEmailAsync(CreateDocument($"page{i}@example.com", $"Page Test {i}"));
        }

        var results = await engine.SearchAsync("page", limit: 5, offset: 0);

        await Assert.That(results.Results.Count).IsEqualTo(5);
        await Assert.That(results.TotalCount).IsEqualTo(15);
        await Assert.That(results.HasMore).IsTrue();
    }

    [Test]
    public async Task SearchAsync_EmptyQuery_ReturnsEmptyResults()
    {
        var (db, engine) = await CreateServicesAsync();
        await db.UpsertEmailAsync(CreateDocument("empty@example.com", "Subject"));

        var results = await engine.SearchAsync("");

        await Assert.That(results.TotalCount).IsEqualTo(0);
    }

    [Test]
    public async Task SearchAsync_ReturnsQueryTime()
    {
        var (db, engine) = await CreateServicesAsync();
        await db.UpsertEmailAsync(CreateDocument("time@example.com", "Subject"));

        var results = await engine.SearchAsync("subject");

        await Assert.That(results.QueryTime.TotalMilliseconds).IsGreaterThanOrEqualTo(0);
    }

    private static EmailDocument CreateDocument(string messageId, string subject)
    {
        return new EmailDocument
        {
            MessageId = messageId,
            FilePath = $"/test/{messageId}.eml",
            Subject = subject,
            FromAddress = "sender@example.com",
            ToAddress = "recipient@example.com",
            DateSent = DateTimeOffset.UtcNow,
            DateSentUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            IndexedAtUnix = DateTimeOffset.UtcNow.ToUnixTimeSeconds(),
            LastModifiedTicks = DateTime.UtcNow.Ticks
        };
    }
}
CSHARP

echo ""
echo "=========================================="
echo "✅ All unit tests created successfully!"
echo ""
echo "Test counts by project:"
echo ""
echo "MyImapDownloader.Tests:"
echo "  - DownloadOptionsTests: 6 tests"
echo "  - ImapConfigurationTests: 4 tests"
echo "  - EmailDownloadExceptionTests: 5 tests"
echo "  - EmailStorageServiceTests: 10 tests"
echo "  - EmailStorageSanitizationTests: 4 tests"
echo ""
echo "MyEmailSearch.Tests:"
echo "  - SearchDatabaseTests: 10 tests"
echo "  - QueryParserTests: 13 tests"
echo "  - SnippetGeneratorTests: 5 tests"
echo "  - ArchiveScannerTests: 4 tests"
echo "  - EmailParserTests: 6 tests"
echo "  - IndexManagerTests: 3 tests"
echo "  - SearchEngineTests: 4 tests"
echo ""
echo "MyImapDownloader.Core.Tests (from previous script):"
echo "  - TelemetryConfigurationTests: 3 tests"
echo "  - PathResolverTests: 5 tests"
echo "  - TempDirectoryTests: 3 tests"
echo "  - SqliteHelperTests: 4 tests"
echo "  - ActivityExtensionsTests: 7 tests"
echo "  - JsonTelemetryFileWriterTests: 4 tests"
echo "  - EmailMetadataTests: 3 tests"
echo ""
echo "Total: ~99 tests"
echo ""
echo "Run tests with:"
echo "  dotnet test"
echo "=========================================="
==========================================
Creating Comprehensive Unit Tests
==========================================

[PART 1] Creating MyImapDownloader Tests...

[PART 2] Creating MyEmailSearch Tests...

==========================================
✅ All unit tests created successfully!

Test counts by project:

MyImapDownloader.Tests:
  - DownloadOptionsTests: 6 tests
  - ImapConfigurationTests: 4 tests
  - EmailDownloadExceptionTests: 5 tests
  - EmailStorageServiceTests: 10 tests
  - EmailStorageSanitizationTests: 4 tests

MyEmailSearch.Tests:
  - SearchDatabaseTests: 10 tests
  - QueryParserTests: 13 tests
  - SnippetGeneratorTests: 5 tests
  - ArchiveScannerTests: 4 tests
  - EmailParserTests: 6 tests
  - IndexManagerTests: 3 tests
  - SearchEngineTests: 4 tests

MyImapDownloader.Core.Tests (from previous script):
  - TelemetryConfigurationTests: 3 tests
  - PathResolverTests: 5 tests
  - TempDirectoryTests: 3 tests
  - SqliteHelperTests: 4 tests
  - ActivityExtensionsTests: 7 tests
  - JsonTelemetryFileWriterTests: 4 tests
  - EmailMetadataTests: 3 tests

Total: ~99 tests

Run tests with:
  dotnet test
==========================================

real	0m0.015s
user	0m0.008s
sys	0m0.007s
kushal@fedora:~/src/dotnet/MyImapDownloader$ 

